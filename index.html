<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wild Destiny</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&family=Exo+2:wght@300;400;600;800&display=swap');

        :root {
            /* ═══════════════════════════════════════════════════════════════
               🎮 Wild Destiny - AAA GAME DESIGN SYSTEM
               ═══════════════════════════════════════════════════════════════ */

            /* Primary Colors - Neon Cyber */
            --primary: #00f0ff;
            --primary-dark: #00a8b5;
            --primary-glow: rgba(0, 240, 255, 0.6);

            /* Secondary Colors - Magenta Energy */
            --secondary: #ff0080;
            --secondary-dark: #b8005c;
            --secondary-glow: rgba(255, 0, 128, 0.6);

            /* Accent Colors - Gold Legendary */
            --accent: #ffd700;
            --accent-dark: #b89800;
            --accent-glow: rgba(255, 215, 0, 0.6);

            /* Tertiary - Purple Mystic */
            --tertiary: #9d4edd;
            --tertiary-dark: #6b21a8;
            --tertiary-glow: rgba(157, 78, 221, 0.6);

            /* Background System - Ultra Dark */
            --bg-void: #000000;
            --bg-abyss: #020408;
            --bg-deep: #050a14;
            --bg-dark: #0a1628;
            --bg-medium: #0f2040;
            --bg-light: #162a50;

            /* Surface Colors */
            --surface-1: rgba(10, 22, 40, 0.95);
            --surface-2: rgba(15, 32, 64, 0.9);
            --surface-3: rgba(22, 42, 80, 0.85);
            --surface-glass: rgba(0, 240, 255, 0.03);

            /* Text Colors */
            --text-primary: #ffffff;
            --text-secondary: #b4c7e7;
            --text-muted: #6a7fa8;
            --text-dim: #3d5580;

            /* Status Colors */
            --success: #00ff88;
            --warning: #ffaa00;
            --danger: #ff3366;
            --info: #00b4ff;

            /* Gradients */
            --gradient-primary: linear-gradient(135deg, var(--primary), var(--secondary));
            --gradient-legendary: linear-gradient(135deg, var(--accent), #ff8800, var(--secondary));
            --gradient-mystic: linear-gradient(135deg, var(--tertiary), var(--primary));
            --gradient-dark: linear-gradient(180deg, var(--bg-deep), var(--bg-void));
            --gradient-surface: linear-gradient(135deg, var(--surface-1), var(--surface-2));

            /* Shadows */
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.5);
            --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.6);
            --shadow-lg: 0 8px 40px rgba(0, 0, 0, 0.7);
            --shadow-glow-primary: 0 0 30px var(--primary-glow);
            --shadow-glow-secondary: 0 0 30px var(--secondary-glow);

            /* Borders */
            --border-subtle: 1px solid rgba(0, 240, 255, 0.1);
            --border-normal: 1px solid rgba(0, 240, 255, 0.2);
            --border-strong: 2px solid rgba(0, 240, 255, 0.3);
            --border-glow: 2px solid var(--primary);

            /* Border Radius */
            --radius-sm: 6px;
            --radius-md: 12px;
            --radius-lg: 20px;
            --radius-xl: 30px;

            /* Transitions */
            --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 0.5s cubic-bezier(0.4, 0, 0.2, 1);

            /* Typography */
            --font-display: 'Orbitron', sans-serif;
            --font-heading: 'Rajdhani', sans-serif;
            --font-body: 'Exo 2', sans-serif;

            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 40px;

            /* Legacy compatibility */
            --dark: var(--bg-dark);
            --darker: var(--bg-void);
            --light: var(--text-secondary);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        *::selection {
            background: var(--primary);
            color: var(--bg-void);
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-body);
            background: var(--bg-void);
            color: var(--text-secondary);
            overflow: hidden;
            height: 100vh;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Custom Scrollbar - Global */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-abyss);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--gradient-primary);
            border-radius: 4px;
            border: 2px solid var(--bg-abyss);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        /* ═══════════════════════════════════════════════════════════════
           🎮 PARTICLES BACKGROUND - COSMIC DUST
           ═══════════════════════════════════════════════════════════════ */
        #particles-bg {
            position: fixed;
            inset: 0;
            z-index: 0;
            background:
                radial-gradient(ellipse 100% 100% at 50% 0%, rgba(0, 240, 255, 0.03) 0%, transparent 50%),
                radial-gradient(ellipse 80% 80% at 80% 80%, rgba(157, 78, 221, 0.03) 0%, transparent 40%),
                radial-gradient(ellipse 60% 60% at 20% 100%, rgba(255, 0, 128, 0.02) 0%, transparent 40%),
                var(--bg-void);
        }

        /* ═══════════════════════════════════════════════════════════════
           🏛️ MAIN GAME LAYOUT - COMMAND CENTER STYLE
           ═══════════════════════════════════════════════════════════════ */
        .game-layout {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: var(--bg-void);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* ═══════════════════════════════════════════════════════════════
           🎖️ HEADER - TACTICAL HUD BAR
           ═══════════════════════════════════════════════════════════════ */
        .game-header {
            height: 64px;
            width: 100%;
            z-index: 1000;
            position: relative;
            background: linear-gradient(180deg,
                    rgba(10, 22, 40, 0.98) 0%,
                    rgba(5, 10, 20, 0.95) 100%);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border-bottom: 1px solid rgba(0, 240, 255, 0.15);
            box-shadow:
                0 4px 30px rgba(0, 0, 0, 0.7),
                0 1px 0 rgba(0, 240, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 24px;
        }

        /* Header glow line */
        .game-header::before {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg,
                    transparent 0%,
                    var(--primary) 20%,
                    var(--secondary) 50%,
                    var(--primary) 80%,
                    transparent 100%);
            opacity: 0.6;
            animation: headerPulse 4s ease-in-out infinite;
        }

        @keyframes headerPulse {

            0%,
            100% {
                opacity: 0.4;
                filter: blur(1px);
            }

            50% {
                opacity: 0.8;
                filter: blur(0px);
            }
        }

        /* ═══════════════════════════════════════════════════════════════
           🖥️ MAIN CANVAS - BATTLE VIEWPORT
           ═══════════════════════════════════════════════════════════════ */
        .main-canvas {
            position: absolute;
            inset: 0;
            z-index: 0;
            background: var(--bg-abyss);
        }

        .main-canvas canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Grid overlay effect */
        .main-canvas::before {
            content: '';
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(rgba(0, 240, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 240, 255, 0.02) 1px, transparent 1px);
            background-size: 60px 60px;
            pointer-events: none;
            z-index: 1;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════
           📊 HUD CONTAINERS - TACTICAL OVERLAY
           ═══════════════════════════════════════════════════════════════ */
        .hud-container {
            position: absolute;
            top: 64px;
            left: 0;
            width: 100%;
            height: calc(100% - 64px);
            pointer-events: none;
            z-index: 100;
            padding: 16px;
            display: flex;
            justify-content: space-between;
        }

        /* ═══════════════════════════════════════════════════════════════
           📁 LEFT SIDEBAR - LOADOUT PANEL (COLLAPSIBLE)
           ═══════════════════════════════════════════════════════════════ */
        .sidebar {
            pointer-events: auto;
            width: 72px;
            height: calc(100% - 120px);
            background: linear-gradient(180deg,
                    rgba(10, 22, 40, 0.9) 0%,
                    rgba(5, 12, 25, 0.95) 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 240, 255, 0.1);
            border-radius: var(--radius-lg);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow:
                var(--shadow-lg),
                inset 0 0 30px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(0, 240, 255, 0.05);
        }

        .sidebar:hover {
            width: 280px;
            background: linear-gradient(180deg,
                    rgba(10, 22, 40, 0.98) 0%,
                    rgba(5, 12, 25, 0.98) 100%);
            border-color: rgba(0, 240, 255, 0.3);
            box-shadow:
                var(--shadow-lg),
                var(--shadow-glow-primary),
                inset 0 0 40px rgba(0, 0, 0, 0.4);
        }

        /* Collapsed state styling */
        .sidebar:not(:hover) .section-title {
            opacity: 0;
            height: 0;
            margin: 0;
            overflow: hidden;
            transition: all 0.2s;
        }

        .sidebar:not(:hover) .equip-card-content {
            opacity: 0;
            width: 0;
            display: none;
        }

        .sidebar:not(:hover) .equip-card {
            justify-content: center;
            padding: 8px;
        }

        /* ═══════════════════════════════════════════════════════════════
           📋 SIDEBAR SECTIONS
           ═══════════════════════════════════════════════════════════════ */
        .sidebar-section {
            margin-bottom: 16px;
            padding: 12px;
            width: 100%;
        }

        .section-title {
            font-family: var(--font-heading);
            font-size: 11px;
            font-weight: 600;
            color: var(--secondary);
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 12px;
            padding-left: 10px;
            border-left: 3px solid var(--secondary);
            white-space: nowrap;
            overflow: hidden;
            transition: opacity 0.3s, height 0.3s;
        }

        /* ═══════════════════════════════════════════════════════════════
           🎴 EQUIP CARDS - LOADOUT ITEMS
           ═══════════════════════════════════════════════════════════════ */
        .equip-card {
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.4) 0%,
                    rgba(10, 22, 40, 0.3) 100%);
            border: 1px solid rgba(0, 240, 255, 0.1);
            border-radius: var(--radius-md);
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            overflow: hidden;
            width: 100%;
            position: relative;
        }

        .equip-card::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(0, 240, 255, 0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        .equip-card:hover::before {
            transform: translateX(100%);
        }

        .equip-card:hover {
            background: linear-gradient(135deg,
                    rgba(0, 240, 255, 0.1) 0%,
                    rgba(0, 0, 0, 0.4) 100%);
            border-color: rgba(0, 240, 255, 0.4);
            transform: translateX(4px);
            box-shadow:
                var(--shadow-md),
                0 0 20px rgba(0, 240, 255, 0.1);
        }

        .equip-card-image {
            width: 45px;
            min-width: 45px;
            height: 45px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            position: relative;
        }

        .equip-card-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .equip-card-image-fallback {
            font-size: 20px;
        }

        .equip-card-content {
            flex: 1;
            min-width: 0;
            /* Allow text truncation */
        }

        .equip-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .equip-info h3 {
            font-size: 14px;
            font-weight: 700;
            color: var(--light);
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .equip-type {
            font-size: 10px;
            color: var(--primary);
            text-transform: uppercase;
        }

        .equip-status {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* Right Panel - Stats & Map */
        .stats-panel {
            pointer-events: auto;
            width: 280px;
            background: linear-gradient(200deg, rgba(10, 14, 30, 0.8), rgba(5, 8, 15, 0.9));
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 0, 110, 0.2);
            border-radius: 15px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 80vh;
            overflow-y: auto;
            transform: translateX(0);
            transition: transform 0.3s;
        }

        /* Hide Scrollbars on panels */
        .sidebar::-webkit-scrollbar,
        .stats-panel::-webkit-scrollbar {
            width: 0;
        }

        /* ═══════════════════════════════════════════════════════════════
           ⚡ ABILITY DOCK - BOTTOM CENTER DOCK
           ═══════════════════════════════════════════════════════════════ */
        .ability-bar {
            pointer-events: auto;
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(180deg,
                    rgba(10, 22, 40, 0.95) 0%,
                    rgba(5, 12, 25, 0.98) 100%);
            backdrop-filter: blur(30px) saturate(180%);
            -webkit-backdrop-filter: blur(30px) saturate(180%);
            border: 1px solid rgba(0, 240, 255, 0.15);
            border-radius: var(--radius-xl);
            padding: 12px 20px;
            display: flex;
            gap: 10px;
            box-shadow:
                var(--shadow-lg),
                0 0 40px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.05),
                0 0 0 1px rgba(0, 240, 255, 0.05);
            z-index: 200;
        }

        /* Dock glow effect */
        .ability-bar::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: var(--radius-xl);
            background: var(--gradient-primary);
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s;
        }

        .ability-bar:hover::before {
            opacity: 0.1;
        }

        /* ═══════════════════════════════════════════════════════════════
           🖼️ GAME CANVAS - BATTLE ARENA
           ═══════════════════════════════════════════════════════════════ */

        /* Grid now defined in main-canvas::before above */

        #game-canvas {
            border: 1px solid rgba(0, 240, 255, 0.2);
            border-radius: var(--radius-md);
            box-shadow:
                0 0 40px rgba(0, 0, 0, 0.8),
                0 0 100px rgba(0, 240, 255, 0.05),
                inset 0 0 0 1px rgba(0, 240, 255, 0.05);
            max-width: 100%;
            max-height: 100%;
            position: relative;
            z-index: 10;
        }

        /* Fullscreen Canvas Override */
        #game-canvas:fullscreen {
            width: 100vw;
            height: 100vh;
            border: none;
            border-radius: 0;
            padding: 0;
            margin: 0;
            background: var(--bg-void);
        }

        @keyframes borderGlow {

            0%,
            100% {
                box-shadow:
                    0 0 100px rgba(0, 240, 255, 0.3),
                    0 0 60px rgba(255, 0, 128, 0.15),
                    inset 0 0 80px rgba(0, 0, 0, 0.6);
            }

            50% {
                box-shadow:
                    0 0 120px rgba(0, 240, 255, 0.5),
                    0 0 80px rgba(255, 0, 128, 0.25),
                    inset 0 0 100px rgba(0, 0, 0, 0.7);
            }
        }

        @keyframes canvasPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.001);
            }
        }

        .canvas-overlay {
            position: absolute;
            top: 25px;
            right: 25px;
            background: linear-gradient(135deg, rgba(10, 14, 39, 0.95), rgba(5, 8, 20, 0.95));
            backdrop-filter: blur(15px);
            border: 3px solid transparent;
            border-image: linear-gradient(135deg, var(--primary), var(--secondary)) 1;
            border-radius: 15px;
            padding: 15px 22px;
            box-shadow:
                0 10px 40px rgba(0, 0, 0, 0.8),
                0 0 30px rgba(0, 217, 255, 0.3),
                inset 0 0 20px rgba(0, 217, 255, 0.05);
            display: flex;
            gap: 25px;
            align-items: center;
            animation: overlayFloat 3s ease-in-out infinite;
        }

        @keyframes overlayFloat {

            0%,
            100% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-3px);
            }
        }

        .overlay-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            position: relative;
        }

        .overlay-item::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
            opacity: 0.3;
        }

        .overlay-item:last-child::after {
            display: none;
        }

        .overlay-label {
            color: var(--primary);
            font-weight: 800;
            font-size: 24px;
            filter: drop-shadow(0 0 8px rgba(0, 217, 255, 0.6));
            animation: iconPulse 2s ease-in-out infinite;
        }

        @keyframes iconPulse {

            0%,
            100% {
                transform: scale(1);
                filter: drop-shadow(0 0 8px rgba(0, 217, 255, 0.6));
            }

            50% {
                transform: scale(1.1);
                filter: drop-shadow(0 0 12px rgba(0, 217, 255, 0.9));
            }
        }

        .overlay-value {
            color: var(--accent);
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            text-shadow:
                0 0 15px rgba(255, 190, 11, 0.8),
                0 2px 4px rgba(0, 0, 0, 0.8);
            letter-spacing: 1px;
        }



        .stat-card {
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.05), rgba(255, 0, 110, 0.05));
            border: 1px solid rgba(0, 217, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .stat-card h4 {
            font-size: 12px;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .stat-bar {
            background: rgba(0, 0, 0, 0.3);
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 4px;
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        .stat-text {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--light);
        }

        .minimap {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 217, 255, 0.3);
            border-radius: 10px;
            padding: 10px;
            margin-top: 20px;
        }

        .minimap-title {
            font-size: 11px;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            font-weight: 700;
        }

        .minimap-canvas {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
        }

        /* Ability Bar - Item Styles (Slots) */

        .ability-bar::-webkit-scrollbar {
            height: 10px;
        }

        .ability-bar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 5px;
            margin: 0 10px;
        }

        .ability-bar::-webkit-scrollbar-thumb {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 5px;
            border: 2px solid rgba(0, 217, 255, 0.5);
        }

        .ability-bar::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(90deg, var(--secondary), var(--accent));
        }

        .ability-slot {
            position: relative;
            width: 78px;
            min-width: 78px;
            max-width: 78px;
            height: 140px;
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.08), rgba(255, 0, 110, 0.08));
            border: 2px solid rgba(0, 217, 255, 0.3);
            border-radius: 12px;
            padding: 6px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: visible;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
        }

        .ability-slot::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            transform: scaleX(0);
            transition: transform 0.3s;
        }

        .ability-slot:hover::after {
            transform: scaleX(1);
        }

        .ability-slot:hover {
            transform: translateY(-8px);
            border-color: var(--primary);
            box-shadow: 0 15px 40px rgba(0, 217, 255, 0.4);
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.15), rgba(255, 0, 110, 0.15));
        }

        .ability-slot.ultimate {
            border-color: rgba(255, 190, 11, 0.5);
            background: linear-gradient(135deg, rgba(255, 190, 11, 0.1), rgba(255, 0, 110, 0.1));
        }

        .ability-slot.ultimate::after {
            background: linear-gradient(90deg, var(--accent), var(--secondary));
        }

        .ability-slot.ultimate:hover {
            border-color: var(--accent);
            box-shadow: 0 15px 40px rgba(255, 190, 11, 0.5);
        }

        .ability-slot.on-cooldown {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }

        .ability-icon {
            width: 64px;
            height: 60px;
            margin: 0 auto 5px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            border: 1px solid rgba(0, 217, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .ability-icon::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 217, 255, 0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.6s;
        }

        .ability-slot:hover .ability-icon::before {
            left: 100%;
        }

        .ability-name {
            font-size: 10px;
            text-align: center;
            color: var(--light);
            font-weight: 700;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            line-height: 1.1;
            width: 100%;
            max-width: 74px;
            display: block;
        }

        /* 2D Canvas Icon Styles */
        .icon-2d {
            display: inline-block;
            vertical-align: middle;
            image-rendering: crisp-edges;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
            transition: transform 0.2s ease, filter 0.2s ease;
        }

        .icon-2d:hover {
            transform: scale(1.1);
            filter: drop-shadow(0 4px 8px rgba(0, 217, 255, 0.6));
        }

        .role-card-icon .icon-2d {
            filter: drop-shadow(0 2px 8px rgba(0, 217, 255, 0.4));
        }

        .ability-key {
            text-align: center;
            font-size: 13px;
            color: var(--accent);
            font-weight: 900;
            background: rgba(255, 190, 11, 0.2);
            border: 1px solid rgba(255, 190, 11, 0.4);
            border-radius: 6px;
            padding: 4px 10px;
            display: inline-block;
            font-family: 'Orbitron', sans-serif;
            box-shadow: 0 2px 8px rgba(255, 190, 11, 0.3);
        }

        .ability-cooldown {
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            bottom: 8px;
            background: rgba(0, 0, 0, 0.92);
            border-radius: 12px;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: 900;
            color: var(--secondary);
            font-family: 'Orbitron', sans-serif;
            backdrop-filter: blur(5px);
        }

        .ability-cooldown::before {
            content: 'CD';
            font-size: 10px;
            color: var(--primary);
            margin-bottom: 5px;
        }

        .ability-slot.on-cooldown .ability-cooldown {
            display: flex;
        }

        /* ═══════════════════════════════════════════════════════════════
           🎭 MODAL SYSTEM - CINEMATIC OVERLAYS
           ═══════════════════════════════════════════════════════════════ */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(20px) saturate(150%);
            -webkit-backdrop-filter: blur(20px) saturate(150%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5000;
            animation: modalFadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .modal.hidden {
            display: none;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                backdrop-filter: blur(0px);
            }

            to {
                opacity: 1;
                backdrop-filter: blur(20px);
            }
        }

        @keyframes levelUpPulse {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }

            50% {
                transform: translate(-50%, -50%) scale(1.05);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }

        .modal-content {
            background: linear-gradient(135deg,
                    rgba(10, 22, 40, 0.98) 0%,
                    rgba(5, 10, 20, 0.99) 100%);
            border: 1px solid rgba(0, 240, 255, 0.2);
            border-radius: var(--radius-xl);
            width: 92%;
            max-width: 1200px;
            max-height: 88vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow:
                var(--shadow-lg),
                0 0 100px rgba(0, 0, 0, 0.8),
                0 0 60px rgba(0, 240, 255, 0.1),
                inset 0 0 0 1px rgba(255, 255, 255, 0.03);
            animation: modalSlideIn 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        /* Modal glow border */
        .modal-content::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: var(--radius-xl);
            background: var(--gradient-primary);
            z-index: -1;
            opacity: 0.3;
            filter: blur(10px);
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(40px) scale(0.95);
                opacity: 0;
            }

            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes slideInRight {
            from {
                transform: translateX(40px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes scaleIn {
            from {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }

            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        /* Modal Header */
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 28px;
            background: linear-gradient(90deg,
                    rgba(0, 240, 255, 0.08) 0%,
                    rgba(255, 0, 128, 0.05) 50%,
                    rgba(0, 240, 255, 0.08) 100%);
            border-bottom: 1px solid rgba(0, 240, 255, 0.15);
            position: relative;
        }

        .modal-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: var(--gradient-primary);
            opacity: 0.3;
        }

        .modal-header h2 {
            font-family: var(--font-display);
            font-size: 24px;
            font-weight: 900;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 3px;
            text-shadow: none;
        }

        .close-button {
            background: rgba(255, 0, 128, 0.1);
            border: 1px solid rgba(255, 0, 128, 0.3);
            color: var(--secondary);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .close-button:hover {
            background: var(--secondary);
            border-color: var(--secondary);
            color: var(--text-primary);
            transform: rotate(90deg) scale(1.1);
            box-shadow: var(--shadow-glow-secondary);
        }

        /* Modal Tabs */
        .modal-tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.4);
            padding: 12px 20px;
            gap: 8px;
            border-bottom: 1px solid rgba(0, 240, 255, 0.1);
        }

        .tab-button {
            flex: 1;
            padding: 14px 20px;

            background: rgba(0, 217, 255, 0.05);
            border: 2px solid rgba(0, 217, 255, 0.2);
            border-radius: 10px;
            color: var(--light);
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 700;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Exo 2', sans-serif;
        }

        .tab-button:hover {
            background: rgba(0, 217, 255, 0.1);
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        .tab-button.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-color: var(--primary);
            box-shadow: 0 6px 20px rgba(0, 217, 255, 0.4);
            color: var(--darker);
        }

        .modal-body {
            padding: 30px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-body::-webkit-scrollbar {
            width: 10px;
        }

        .modal-body::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .modal-body::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--primary), var(--secondary));
            border-radius: 5px;
        }

        .role-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 25px;
        }

        .role-card {
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.08), rgba(255, 0, 110, 0.08));
            border: 2px solid rgba(0, 217, 255, 0.2);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .role-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 217, 255, 0.2), transparent);
            transition: left 0.6s;
        }

        .role-card:hover::before {
            left: 100%;
        }

        .role-card:hover {
            transform: translateY(-10px);
            border-color: var(--primary);
            box-shadow: 0 20px 50px rgba(0, 217, 255, 0.4);
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.15), rgba(255, 0, 110, 0.15));
        }

        .role-card-icon {
            width: 110px;
            height: 110px;
            margin: 0 auto 18px;
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.2), rgba(255, 0, 110, 0.2));
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 55px;
            border: 2px solid rgba(0, 217, 255, 0.3);
            transition: all 0.3s;
        }

        .role-card:hover .role-card-icon {
            transform: scale(1.15) rotate(5deg);
            border-color: var(--primary);
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.5);
        }

        .role-card-name {
            font-weight: 800;
            font-size: 18px;
            color: var(--light);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .role-card-type {
            font-size: 12px;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            background: rgba(0, 217, 255, 0.1);
            padding: 4px 12px;
            border-radius: 6px;
            display: inline-block;
        }

        /* ═══════════════════════════════════════════════════════════════
           🌌 LOADING SCREEN - COSMIC RIFT DESIGN
           ═══════════════════════════════════════════════════════════════ */

        #loading-screen {
            position: fixed;
            inset: 0;
            background: var(--bg-void);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            overflow: hidden;
        }

        /* Multi-layer cosmic background */
        #loading-screen::before {
            content: '';
            position: absolute;
            inset: -100%;
            background:
                radial-gradient(ellipse 80% 50% at 50% 50%, rgba(0, 240, 255, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse 60% 80% at 30% 20%, rgba(157, 78, 221, 0.1) 0%, transparent 40%),
                radial-gradient(ellipse 50% 60% at 70% 80%, rgba(255, 0, 128, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, var(--bg-deep) 0%, var(--bg-void) 70%);
            animation: cosmicDrift 20s ease-in-out infinite alternate;
        }

        #loading-screen::after {
            content: '';
            position: absolute;
            inset: 0;
            background:
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(0, 240, 255, 0.02) 2px, rgba(0, 240, 255, 0.02) 4px),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 240, 255, 0.02) 2px, rgba(0, 240, 255, 0.02) 4px);
            background-size: 100px 100px;
            animation: gridScan 3s linear infinite;
            pointer-events: none;
        }

        @keyframes cosmicDrift {
            0% {
                transform: scale(1) rotate(0deg);
            }

            100% {
                transform: scale(1.2) rotate(5deg);
            }
        }

        @keyframes gridScan {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 100px 100px;
            }
        }

        /* Singularity Container - Enhanced */
        .singularity-container {
            position: relative;
            width: 280px;
            height: 280px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 50px;
            z-index: 10;
        }

        /* Central Black Hole */
        .singularity-black-hole {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, var(--bg-void) 0%, var(--bg-void) 70%, transparent 100%);
            border-radius: 50%;
            position: absolute;
            z-index: 20;
            box-shadow:
                0 0 60px 30px var(--bg-void),
                0 0 100px 60px rgba(0, 0, 0, 0.8),
                inset 0 0 30px rgba(0, 240, 255, 0.1);
            animation: singularityPulse 4s ease-in-out infinite;
        }

        @keyframes singularityPulse {

            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 0 60px 30px var(--bg-void), 0 0 100px 60px rgba(0, 0, 0, 0.8), inset 0 0 30px rgba(0, 240, 255, 0.1);
            }

            50% {
                transform: scale(1.1);
                box-shadow: 0 0 80px 40px var(--bg-void), 0 0 120px 80px rgba(0, 0, 0, 0.9), inset 0 0 40px rgba(0, 240, 255, 0.2);
            }
        }

        /* Accretion Disk - Primary */
        .singularity-accretion-disk {
            position: absolute;
            width: 260px;
            height: 260px;
            border-radius: 50%;
            background: conic-gradient(from 0deg,
                    transparent 0deg,
                    var(--primary) 60deg,
                    var(--secondary) 120deg,
                    var(--tertiary) 180deg,
                    var(--secondary) 240deg,
                    var(--primary) 300deg,
                    transparent 360deg);
            animation: diskRotate 2s linear infinite;
            filter: blur(6px);
            opacity: 0.9;
            mask: radial-gradient(transparent 28%, black 35%, black 65%, transparent 75%);
            -webkit-mask: radial-gradient(transparent 28%, black 35%, black 65%, transparent 75%);
        }

        @keyframes diskRotate {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* Energy Rings */
        .singularity-particles {
            position: absolute;
            width: 320px;
            height: 320px;
            border-radius: 50%;
            border: 2px solid transparent;
            border-top-color: var(--primary);
            border-bottom-color: var(--secondary);
            animation: ringRotate 8s linear infinite;
            filter: blur(1px);
        }

        .singularity-particles::before {
            content: '';
            position: absolute;
            inset: -20px;
            border-radius: 50%;
            border: 1px dashed rgba(0, 240, 255, 0.3);
            animation: ringRotate 15s linear infinite reverse;
        }

        .singularity-particles::after {
            content: '';
            position: absolute;
            inset: 15px;
            border-radius: 50%;
            border: 1px solid rgba(255, 0, 128, 0.2);
            animation: ringRotate 12s linear infinite;
        }

        @keyframes ringRotate {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* Loader Content - Title Area */
        .loader-content-new {
            position: relative;
            z-index: 30;
            text-align: center;
            margin-top: 20px;
        }

        .loader-title-new {
            font-family: var(--font-display);
            font-size: 56px;
            font-weight: 900;
            color: var(--text-primary);
            letter-spacing: 16px;
            text-shadow:
                0 0 40px var(--primary-glow),
                0 0 80px var(--primary-glow),
                0 4px 0 var(--bg-void);
            margin-bottom: 12px;
            animation: titleGlow 3s ease-in-out infinite;
            position: relative;
        }

        .loader-title-new::before {
            content: 'Wild Destiny';
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glitchText 5s infinite;
            opacity: 0;
        }

        @keyframes titleGlow {

            0%,
            100% {
                filter: brightness(1);
                text-shadow: 0 0 40px var(--primary-glow), 0 0 80px var(--primary-glow), 0 4px 0 var(--bg-void);
            }

            50% {
                filter: brightness(1.2);
                text-shadow: 0 0 60px var(--primary-glow), 0 0 120px var(--primary-glow), 0 4px 0 var(--bg-void);
            }
        }

        @keyframes glitchText {

            0%,
            90%,
            100% {
                opacity: 0;
                transform: translateX(0);
            }

            92% {
                opacity: 0.8;
                transform: translateX(-5px);
            }

            94% {
                opacity: 0;
                transform: translateX(5px);
            }

            96% {
                opacity: 0.5;
                transform: translateX(-3px);
            }
        }

        .loader-subtitle-new {
            font-family: var(--font-heading);
            font-size: 18px;
            color: var(--secondary);
            letter-spacing: 12px;
            text-transform: uppercase;
            font-weight: 600;
            text-shadow: 0 0 20px var(--secondary-glow);
            animation: subtitlePulse 2s ease-in-out infinite;
        }

        @keyframes subtitlePulse {

            0%,
            100% {
                opacity: 0.7;
            }

            50% {
                opacity: 1;
            }
        }

        /* Legacy loader elements (keep for compatibility) */
        .loader-core {
            position: absolute;
            width: 150px;
            height: 150px;
            animation: coreFloat 4s ease-in-out infinite;
        }

        .core-inner {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, #fff, var(--primary));
            border-radius: 50%;
            filter: blur(10px);
            opacity: 0.8;
            animation: corePulse 2s ease-in-out infinite;
        }

        .core-outer {
            position: absolute;
            inset: -20px;
            border: 2px solid var(--primary);
            border-radius: 50%;
            border-top-color: transparent;
            border-bottom-color: transparent;
            animation: spin 3s linear infinite;
        }

        .core-ring {
            position: absolute;
            inset: -40px;
            border: 1px dashed var(--secondary);
            border-radius: 50%;
            opacity: 0.5;
            animation: spinReverse 10s linear infinite;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        @keyframes spinReverse {
            from {
                transform: rotate(360deg);
            }

            to {
                transform: rotate(0deg);
            }
        }

        @keyframes corePulse {

            0%,
            100% {
                transform: scale(0.8);
                opacity: 0.8;
            }

            50% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes coreFloat {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-20px);
            }
        }

        .loader-content {
            position: absolute;
            text-align: center;
            z-index: 10;
        }

        .loader-logo {
            font-size: 60px;
            filter: drop-shadow(0 0 20px var(--primary));
        }

        #loading-screen h1 {
            font-family: var(--font-display);
            font-size: 48px;
            font-weight: 900;
            color: var(--text-primary);
            letter-spacing: 8px;
            margin: 15px 0;
            text-shadow: 0 0 30px var(--primary-glow);
        }

        .loader-subtitle {
            font-family: var(--font-heading);
            font-size: 16px;
            color: var(--secondary);
            letter-spacing: 10px;
            text-transform: uppercase;
        }

        /* Loading Bar - Premium Design */
        .loading-bar-container {
            width: 500px;
            max-width: 90vw;
            position: relative;
            z-index: 30;
            margin-top: 50px;
        }

        .loading-bar {
            height: 6px;
            background: var(--surface-1);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
            position: relative;
            border: 1px solid rgba(0, 240, 255, 0.2);
            box-shadow:
                var(--shadow-md),
                inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .loading-bar::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: barShimmer 2s infinite;
            transform: translateX(-100%);
        }

        @keyframes barShimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(200%);
            }
        }

        .loading-progress {
            height: 100%;
            width: 0%;
            background: var(--gradient-primary);
            border-radius: 10px;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow:
                0 0 20px var(--primary-glow),
                0 0 40px var(--primary-glow);
        }

        .loading-progress::after {
            content: '';
            position: absolute;
            right: 0;
            top: -4px;
            bottom: -4px;
            width: 20px;
            background: radial-gradient(circle at center, var(--text-primary), transparent);
            filter: blur(2px);
            animation: progressGlow 0.5s ease-in-out infinite alternate;
        }

        @keyframes progressGlow {
            0% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .loading-percentage {
            font-family: var(--font-display);
            font-size: 28px;
            font-weight: 900;
            color: var(--accent);
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 20px var(--accent-glow);
            letter-spacing: 4px;
        }

        .loading-status {
            text-align: center;
            font-family: var(--font-heading);
            color: var(--text-muted);
            font-size: 14px;
            letter-spacing: 4px;
            text-transform: uppercase;
            animation: statusBlink 1.5s ease-in-out infinite;
        }

        @keyframes statusBlink {

            0%,
            100% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
            transition: all 1s cubic-bezier(0.4, 0, 0.2, 1);
            transform: scale(1.05);
            filter: blur(10px);
        }



        .loading-bar-container {
            width: 100%;
            max-width: 1400px;
            position: relative;
            z-index: 2;
        }

        .loading-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 217, 255, 0.1);
            border-radius: 20px;
            overflow: hidden;
            border: 2px solid rgba(0, 217, 255, 0.3);
            box-shadow:
                0 0 20px rgba(0, 217, 255, 0.2),
                inset 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .loading-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                left: -100%;
            }

            100% {
                left: 200%;
            }
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
            width: 0%;
            transition: width 0.3s ease-out;
            box-shadow: 0 0 30px rgba(0, 217, 255, 1);
            position: relative;
            border-radius: 20px;
        }

        .loading-progress::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4));
            filter: blur(10px);
        }

        .loading-percentage {
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            font-weight: 900;
            color: var(--accent);
            margin-top: 15px;
            text-align: center;
            text-shadow: 0 0 20px rgba(255, 190, 11, 0.8);
            position: relative;
            z-index: 2;
        }

        .loading-status {
            color: var(--primary);
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-top: 20px;
            opacity: 0.8;
            position: relative;
            z-index: 2;
            animation: statusBlink 1.5s ease-in-out infinite;
        }

        @keyframes statusBlink {

            0%,
            100% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }
        }

        .loading-particles {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
        }

        .loading-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--primary);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--primary);
            animation: particleFloat 3s ease-in-out infinite;
        }

        /* Enhanced Header Styles */
        .game-header {
            height: 80px;
            background: rgba(5, 8, 20, 0.85);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(0, 217, 255, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 30px;
            position: relative;
            z-index: 1000;
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.8);
        }

        .game-header::before {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary), var(--secondary), var(--primary), transparent);
            box-shadow: 0 0 10px var(--primary);
            animation: headerGlow 3s infinite linear;
        }

        @keyframes headerGlow {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 100% 50%;
            }
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════
           🎯 LOGO - BRAND IDENTITY
           ═══════════════════════════════════════════════════════════════ */
        .logo-icon {
            font-size: 28px;
            color: var(--primary);
            filter: drop-shadow(0 0 15px var(--primary-glow));
            animation: logoIconPulse 3s ease-in-out infinite;
        }

        @keyframes logoIconPulse {

            0%,
            100% {
                transform: scale(1) rotate(0deg);
                filter: drop-shadow(0 0 15px var(--primary-glow));
            }

            50% {
                transform: scale(1.1) rotate(5deg);
                filter: drop-shadow(0 0 25px var(--primary-glow));
            }
        }

        .logo-text h1 {
            font-family: var(--font-display);
            font-size: 22px;
            font-weight: 900;
            letter-spacing: 3px;
            background: linear-gradient(90deg,
                    var(--text-primary) 0%,
                    var(--primary) 50%,
                    var(--text-primary) 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            line-height: 1;
            animation: titleShimmer 4s linear infinite;
        }

        @keyframes titleShimmer {
            0% {
                background-position: 200% center;
            }

            100% {
                background-position: -200% center;
            }
        }

        .logo-text p {
            font-family: var(--font-heading);
            font-size: 9px;
            color: var(--secondary);
            font-weight: 600;
            letter-spacing: 5px;
            text-transform: uppercase;
            margin-top: 3px;
            text-shadow: 0 0 10px var(--secondary-glow);
        }

        /* ═══════════════════════════════════════════════════════════════
           ☰ MENU TOGGLE - HAMBURGER BUTTON
           ═══════════════════════════════════════════════════════════════ */
        .menu-toggle {
            width: 42px;
            height: 42px;
            background: rgba(0, 240, 255, 0.05);
            border: 1px solid rgba(0, 240, 255, 0.2);
            border-radius: var(--radius-sm);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 1001;
        }

        .menu-toggle:hover {
            background: rgba(0, 240, 255, 0.15);
            border-color: var(--primary);
            box-shadow: var(--shadow-glow-primary);
            transform: scale(1.05);
        }

        .menu-toggle span {
            width: 20px;
            height: 2px;
            background: var(--text-secondary);
            border-radius: 2px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .menu-toggle:hover span {
            background: var(--primary);
            box-shadow: 0 0 8px var(--primary-glow);
        }

        /* Active state animation */
        .menu-toggle.active span:nth-child(1) {
            transform: translateY(7px) rotate(45deg);
        }

        .menu-toggle.active span:nth-child(2) {
            opacity: 0;
            transform: scaleX(0);
        }

        .menu-toggle.active span:nth-child(3) {
            transform: translateY(-7px) rotate(-45deg);
        }

        @keyframes particleFloat {

            0%,
            100% {
                transform: translateY(0) translateX(0);
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }
        }

        /* ===== LOADER MÓVIL ===== */
        @media screen and (max-width: 768px) {
            #loading-screen {
                padding: 20px;
            }

            .loading-content {
                flex-direction: column;
                gap: 30px;
                margin-bottom: 30px;
            }

            .loading-left {
                align-items: center;
                text-align: center;
            }

            .loading-logo {
                font-size: 80px;
                margin-bottom: 15px;
            }

            #loading-screen h1 {
                font-size: 42px;
                letter-spacing: 4px;
                margin-bottom: 10px;
            }

            .loading-subtitle {
                font-size: 16px;
                letter-spacing: 3px;
            }

            .loading-right {
                display: none;
                /* Ocultar video en móvil */
            }

            .loading-bar-container {
                max-width: 100%;
            }

            .loading-percentage {
                font-size: 24px;
                margin-top: 12px;
            }

            .loading-status {
                font-size: 12px;
                margin-top: 15px;
            }
        }

        /* ===== LOADER MÓVIL LANDSCAPE ===== */
        @media screen and (max-width: 768px) and (orientation: landscape) {
            #loading-screen {
                padding: 15px;
            }

            .loading-logo {
                font-size: 60px;
                margin-bottom: 10px;
            }

            #loading-screen h1 {
                font-size: 32px;
                letter-spacing: 3px;
                margin-bottom: 8px;
            }

            .loading-subtitle {
                font-size: 14px;
                letter-spacing: 2px;
            }

            .loading-percentage {
                font-size: 20px;
                margin-top: 10px;
            }

            .loading-status {
                font-size: 11px;
                margin-top: 10px;
            }
        }

        /* ===== MINIMAL LOADER OVERRIDE ===== */
        #loading-screen {
            background: radial-gradient(circle at 50% 20%, rgba(0, 217, 255, 0.08) 0%, rgba(5, 10, 20, 0.95) 45%, #020408 100%) !important;
            gap: 28px;
            padding: 28px;
        }

        #loading-screen::before,
        #loading-screen::after {
            display: none !important;
        }

        .singularity-container {
            display: none !important;
        }

        .loader-content-new {
            margin-top: 0 !important;
            text-align: center;
        }

        .loader-title-new {
            font-family: var(--font-display);
            font-size: clamp(30px, 4.2vw, 44px);
            letter-spacing: 4px;
            font-weight: 800;
            color: #e9f6ff;
            text-shadow: 0 0 16px rgba(0, 217, 255, 0.25);
            animation: loaderPulseMinimal 2.8s ease-in-out infinite;
            margin: 0 0 10px 0;
        }

        .loader-title-new::before {
            display: none !important;
        }

        .loader-subtitle-new {
            font-family: var(--font-heading);
            font-size: clamp(12px, 1.8vw, 16px);
            letter-spacing: 3px;
            text-transform: uppercase;
            color: rgba(207, 227, 247, 0.8);
            text-shadow: none;
            animation: none;
        }

        .loading-bar-container {
            width: min(560px, 88vw) !important;
            max-width: min(560px, 88vw) !important;
            margin-top: 0 !important;
            z-index: 10;
        }

        .loading-bar {
            height: 10px !important;
            border-radius: 999px !important;
            border: 1px solid rgba(0, 217, 255, 0.28) !important;
            background: rgba(0, 217, 255, 0.08) !important;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03), 0 8px 24px rgba(0, 0, 0, 0.45) !important;
        }

        .loading-bar::before {
            animation: none !important;
            opacity: 0.4;
        }

        .loading-progress {
            background: linear-gradient(90deg, #00d9ff, #54f2ff) !important;
            box-shadow: 0 0 14px rgba(0, 217, 255, 0.5) !important;
            transition: width 0.25s ease !important;
        }

        .loading-progress::after {
            width: 22px !important;
            background: radial-gradient(circle at center, rgba(255, 255, 255, 0.82), rgba(255, 255, 255, 0)) !important;
            filter: blur(1px) !important;
            animation: none !important;
            top: -2px !important;
            bottom: -2px !important;
        }

        .loading-percentage {
            margin-top: 14px !important;
            margin-bottom: 8px !important;
            font-size: clamp(22px, 3vw, 30px) !important;
            letter-spacing: 2px !important;
            color: #d8f7ff !important;
            text-shadow: 0 0 12px rgba(0, 217, 255, 0.28) !important;
        }

        .loading-status {
            margin-top: 0 !important;
            font-size: clamp(11px, 1.7vw, 14px) !important;
            letter-spacing: 1.5px !important;
            color: rgba(207, 227, 247, 0.75) !important;
            text-transform: none !important;
            animation: none !important;
        }

        #loading-screen.hidden {
            transition: opacity 0.45s ease, transform 0.45s ease !important;
            transform: scale(1.01) !important;
            filter: none !important;
        }

        @keyframes loaderPulseMinimal {
            0%, 100% { opacity: 0.92; }
            50% { opacity: 1; }
        }

        @media screen and (max-width: 768px) {
            #loading-screen {
                gap: 20px;
                padding: 22px;
            }

            .loading-bar-container {
                width: min(460px, 92vw) !important;
                max-width: min(460px, 92vw) !important;
            }

            .loader-title-new {
                letter-spacing: 2px;
            }
        }

        @media screen and (max-width: 768px) and (orientation: landscape) {
            #loading-screen {
                gap: 14px;
                padding: 14px;
            }
        }

        @keyframes particleFloatComplete {
            100% {
                transform: translateY(-100vh) translateX(50px);
                opacity: 0;
            }
        }

        /* Animations */
        @keyframes popupFade {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }

            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }

            80% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translateX(-10px);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translateX(10px);
            }
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-100px);
                opacity: 0;
            }
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .game-layout {
                grid-template-columns: 250px 1fr 280px;
            }

            .ability-bar {
                gap: 8px;
                padding: 15px 15px;
            }

            .ability-slot {
                width: 85px;
            }
        }

        @media (max-width: 1200px) {
            .game-layout {
                grid-template-areas:
                    "header header"
                    "main main"
                    "abilities abilities";
                grid-template-columns: 1fr 1fr;
                grid-template-rows: 80px 1fr 150px;
            }

            .sidebar,
            .stats-panel {
                display: none;
            }

            .ability-bar {
                gap: 6px;
                padding: 12px 10px;
            }

            .ability-slot {
                width: 80px;
                height: 105px;
            }
        }

        @media (max-width: 900px) {
            .ability-bar {
                gap: 5px;
                padding: 10px 8px;
                overflow-x: auto;
            }

            .ability-slot {
                width: 75px;
                height: 100px;
            }

            .ability-icon {
                width: 60px;
                height: 55px;
            }

            .ability-name {
                font-size: 9px;
            }

            .ability-key {
                font-size: 11px;
                padding: 3px 8px;
            }
        }

        /* Side Menu & Overlay - RESTORED */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 1001;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .menu-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .side-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 340px;
            height: 100vh;
            background:
                radial-gradient(120% 90% at 0% 0%, rgba(103, 240, 255, 0.12), transparent 55%),
                linear-gradient(180deg, rgba(8, 13, 29, 0.97), rgba(7, 12, 24, 0.98));
            backdrop-filter: blur(18px);
            border-right: 1px solid rgba(103, 240, 255, 0.22);
            z-index: 1002;
            transform: translateX(-100%);
            transition: transform 0.32s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            box-shadow: 18px 0 64px rgba(0, 0, 0, 0.62), inset -1px 0 0 rgba(255, 255, 255, 0.04);
            overflow-y: auto;
        }

        /* Custom Scrollbar for Side Menu */
        .side-menu::-webkit-scrollbar {
            width: 5px;
        }

        .side-menu::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .side-menu::-webkit-scrollbar-thumb {
            background: rgba(0, 217, 255, 0.3);
            border-radius: 3px;
        }

        .side-menu::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 217, 255, 0.6);
        }

        .side-menu.open {
            transform: translateX(0);
        }

        .side-menu-header {
            padding: 24px;
            background: linear-gradient(90deg, rgba(7, 12, 24, 0.98), rgba(10, 17, 35, 0.98));
            border-bottom: 1px solid rgba(103, 240, 255, 0.2);
            padding-top: 92px;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .side-menu-header h2 {
            font-family: 'Orbitron', sans-serif;
            color: #f3fbff;
            font-size: 23px;
            margin-bottom: 4px;
            letter-spacing: 1.2px;
        }

        .side-menu-header p {
            font-size: 11px;
            color: rgba(206, 220, 244, 0.72);
            letter-spacing: 0.8px;
        }

        .menu-section {
            padding: 18px 18px 14px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .menu-section-title {
            font-size: 11px;
            color: rgba(142, 241, 255, 0.94);
            text-transform: uppercase;
            letter-spacing: 1.6px;
            margin-bottom: 10px;
            font-weight: 800;
            padding: 0 8px;
        }

        .menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 11px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 6px;
            border: 1px solid rgba(103, 240, 255, 0.12);
            background: linear-gradient(135deg, rgba(103, 240, 255, 0.05), rgba(255, 79, 160, 0.03));
        }

        .menu-item:hover {
            background: linear-gradient(135deg, rgba(103, 240, 255, 0.14), rgba(255, 79, 160, 0.1));
            border-color: rgba(103, 240, 255, 0.4);
            transform: translateX(4px);
            box-shadow: 0 10px 22px rgba(0, 0, 0, 0.3);
        }

        .menu-item-icon {
            font-size: 17px;
            width: 36px;
            height: 36px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            border: 1px solid rgba(103, 240, 255, 0.3);
            background: rgba(4, 10, 20, 0.8);
            color: #dff8ff;
            flex-shrink: 0;
        }

        .menu-item-title {
            color: #f1f8ff;
            font-weight: 800;
            font-size: 13px;
            letter-spacing: 0.2px;
            line-height: 1.2;
        }

        .menu-item-desc {
            color: rgba(197, 212, 236, 0.74);
            font-size: 11px;
            margin-top: 3px;
            line-height: 1.2;
        }

        /* ===========================================
           VISUAL REWORK PATCH (NON-GAMEPLAY)
           =========================================== */
        :root {
            --primary: #67f0ff;
            --primary-dark: #17c4da;
            --primary-glow: rgba(103, 240, 255, 0.5);
            --secondary: #ff4fa0;
            --secondary-dark: #cb2f76;
            --secondary-glow: rgba(255, 79, 160, 0.42);
            --accent: #ffd166;
            --bg-void: #04070f;
            --bg-abyss: #080d1d;
            --bg-deep: #0b1329;
            --surface-1: rgba(14, 22, 46, 0.9);
            --surface-2: rgba(18, 29, 58, 0.86);
            --surface-3: rgba(28, 42, 79, 0.82);
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            z-index: 0;
            pointer-events: none;
            background:
                radial-gradient(55% 45% at 82% 10%, rgba(103, 240, 255, 0.12), transparent 70%),
                radial-gradient(45% 40% at 18% 80%, rgba(255, 79, 160, 0.1), transparent 70%),
                linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent 20%, rgba(0, 0, 0, 0.25) 100%);
        }

        #particles-bg {
            filter: saturate(1.1) contrast(1.04);
        }

        .game-header {
            height: 70px;
            border-bottom-color: rgba(103, 240, 255, 0.28);
            box-shadow:
                0 10px 36px rgba(0, 0, 0, 0.58),
                0 0 0 1px rgba(103, 240, 255, 0.16),
                inset 0 -1px 0 rgba(255, 255, 255, 0.06);
        }

        .logo h1 {
            letter-spacing: 1.3px;
            text-shadow: 0 0 18px rgba(103, 240, 255, 0.3);
        }

        .logo p {
            color: rgba(224, 231, 255, 0.82);
            letter-spacing: 2.1px;
        }

        .logo-icon {
            position: relative;
            color: var(--accent);
            text-shadow: 0 0 18px rgba(255, 209, 102, 0.42);
            transform: translateZ(0);
        }

        .logo-icon::after {
            content: '';
            position: absolute;
            inset: -8px;
            border: 1px solid rgba(103, 240, 255, 0.28);
            border-radius: 999px;
            animation: logoPulseRing 2.8s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes logoPulseRing {
            0%,
            100% {
                transform: scale(0.94);
                opacity: 0.3;
            }

            50% {
                transform: scale(1.08);
                opacity: 0.85;
            }
        }

        .menu-toggle {
            border: 1px solid rgba(103, 240, 255, 0.28);
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.04) inset;
        }

        .menu-toggle:hover {
            box-shadow: 0 0 24px rgba(103, 240, 255, 0.26);
            transform: translateY(-1px);
        }

        .side-menu {
            border-left: 1px solid rgba(103, 240, 255, 0.2);
            box-shadow: -24px 0 44px rgba(0, 0, 0, 0.48);
        }

        .side-menu-header {
            border-bottom: 1px solid rgba(103, 240, 255, 0.18);
        }

        .menu-section-title {
            color: var(--primary);
            letter-spacing: 1.3px;
        }

        .menu-item {
            border: 1px solid transparent;
            background: linear-gradient(135deg, rgba(103, 240, 255, 0.03), rgba(255, 79, 160, 0.03));
        }

        .menu-item:hover {
            border-color: rgba(103, 240, 255, 0.34);
            background: linear-gradient(135deg, rgba(103, 240, 255, 0.12), rgba(255, 79, 160, 0.09));
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.28);
        }

        .canvas-overlay {
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(103, 240, 255, 0.2);
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(14, 22, 46, 0.78), rgba(8, 13, 29, 0.84));
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.32);
        }

        .overlay-item {
            border-right-color: rgba(103, 240, 255, 0.22);
        }

        .sidebar,
        .stats-panel {
            border-color: rgba(103, 240, 255, 0.26);
            box-shadow:
                0 16px 36px rgba(0, 0, 0, 0.42),
                0 0 0 1px rgba(103, 240, 255, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.04);
        }

        .sidebar:hover {
            box-shadow:
                0 16px 36px rgba(0, 0, 0, 0.5),
                0 0 30px rgba(103, 240, 255, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.06);
        }

        .section-title {
            color: rgba(255, 255, 255, 0.8);
            border-left-color: var(--primary);
            text-shadow: 0 0 12px rgba(103, 240, 255, 0.25);
        }

        .equip-card {
            border-color: rgba(103, 240, 255, 0.18);
            background: linear-gradient(135deg, rgba(103, 240, 255, 0.06), rgba(255, 79, 160, 0.04));
        }

        .equip-card:hover {
            transform: translateX(6px) scale(1.01);
            border-color: rgba(103, 240, 255, 0.45);
            box-shadow:
                0 14px 28px rgba(0, 0, 0, 0.36),
                0 0 18px rgba(103, 240, 255, 0.18);
        }

        .equip-card-image {
            border: 1px solid rgba(103, 240, 255, 0.24);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
        }

        .equip-status {
            background: linear-gradient(135deg, rgba(103, 240, 255, 0.15), rgba(255, 79, 160, 0.14));
            border: 1px solid rgba(103, 240, 255, 0.24);
        }

        .stat-card {
            border: 1px solid rgba(103, 240, 255, 0.15);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
        }

        .stat-card:hover {
            transform: translateY(-2px);
            border-color: rgba(103, 240, 255, 0.34);
            box-shadow: 0 10px 18px rgba(0, 0, 0, 0.28);
        }

        .stat-bar {
            background: rgba(0, 0, 0, 0.44);
        }

        .stat-bar-fill {
            box-shadow: 0 0 16px rgba(103, 240, 255, 0.35);
        }

        .minimap {
            border: 1px solid rgba(103, 240, 255, 0.22);
            box-shadow: 0 12px 22px rgba(0, 0, 0, 0.32);
        }

        .ability-bar {
            background: linear-gradient(135deg, rgba(14, 22, 46, 0.9), rgba(8, 13, 29, 0.9));
            border: 1px solid rgba(103, 240, 255, 0.24);
            border-radius: 16px;
            box-shadow:
                0 20px 40px rgba(0, 0, 0, 0.44),
                0 0 0 1px rgba(255, 255, 255, 0.03) inset;
        }

        .modal-content {
            border: 1px solid rgba(103, 240, 255, 0.25);
            box-shadow:
                0 26px 56px rgba(0, 0, 0, 0.55),
                0 0 0 1px rgba(255, 255, 255, 0.04) inset;
        }

        .modal-header {
            border-bottom: 1px solid rgba(103, 240, 255, 0.16);
        }

        .tab-button {
            border: 1px solid rgba(103, 240, 255, 0.15);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
        }

        .tab-button.active {
            border-color: rgba(103, 240, 255, 0.45);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }

        .close-button {
            border: 1px solid rgba(255, 79, 160, 0.25);
        }

        .update-item {
            transition: transform 0.22s ease, box-shadow 0.22s ease, border-color 0.22s ease !important;
        }

        .update-item:hover {
            transform: translateX(4px);
            border-left-color: var(--primary) !important;
            box-shadow: 0 10px 18px rgba(0, 0, 0, 0.28);
        }

        /* ===========================================
           LOADOUT MINIMAL REWORK (SELECTOR UI)
           =========================================== */
        #loadout-modal .modal-content {
            border: 1px solid rgba(103, 240, 255, 0.28) !important;
            box-shadow:
                0 32px 70px rgba(0, 0, 0, 0.58),
                0 0 0 1px rgba(103, 240, 255, 0.16),
                inset 0 1px 0 rgba(255, 255, 255, 0.06) !important;
        }

        #loadout-modal .loadout-nav-item {
            border-left: 0 !important;
            border-right: 1px solid rgba(103, 240, 255, 0.12) !important;
            background: linear-gradient(135deg, rgba(103, 240, 255, 0.04), rgba(255, 79, 160, 0.02)) !important;
            opacity: 0.8 !important;
        }

        #loadout-modal .loadout-nav-item.active {
            opacity: 1 !important;
            background: linear-gradient(135deg, rgba(103, 240, 255, 0.14), rgba(255, 79, 160, 0.1)) !important;
            box-shadow: inset 0 -2px 0 rgba(103, 240, 255, 0.65);
        }

        #loadout-modal .loadout-nav-item:hover {
            opacity: 1 !important;
            background: linear-gradient(135deg, rgba(103, 240, 255, 0.1), rgba(255, 79, 160, 0.08)) !important;
        }

        #loadout-modal .loadout-selector-shell {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        #loadout-modal .loadout-selector-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 14px;
            flex-wrap: wrap;
            padding: 14px;
            border: 1px solid rgba(103, 240, 255, 0.2);
            border-radius: 14px;
            background: linear-gradient(135deg, rgba(10, 18, 36, 0.9), rgba(14, 24, 45, 0.85));
        }

        #loadout-modal .loadout-selector-head {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 210px;
        }

        #loadout-modal .loadout-selector-title {
            font-family: var(--font-display);
            font-size: 16px;
            color: #f7fbff;
            letter-spacing: 1px;
            font-weight: 800;
        }

        #loadout-modal .loadout-selector-subtitle {
            color: rgba(208, 219, 243, 0.72);
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.3px;
        }

        #loadout-modal .loadout-selector-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        #loadout-modal .loadout-selector-search {
            min-width: 220px;
            height: 38px;
            padding: 0 12px;
            border-radius: 10px;
            border: 1px solid rgba(103, 240, 255, 0.24);
            background: rgba(4, 9, 20, 0.88);
            color: #f0f8ff;
            font-family: var(--font-body);
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        #loadout-modal .loadout-selector-search:focus {
            border-color: rgba(103, 240, 255, 0.55);
            box-shadow: 0 0 0 3px rgba(103, 240, 255, 0.12);
        }

        #loadout-modal .loadout-filter-pill {
            height: 34px;
            padding: 0 12px;
            border-radius: 999px;
            border: 1px solid rgba(103, 240, 255, 0.22);
            background: rgba(103, 240, 255, 0.06);
            color: rgba(236, 243, 255, 0.8);
            font-family: var(--font-heading);
            font-weight: 700;
            font-size: 12px;
            letter-spacing: 0.6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #loadout-modal .loadout-filter-pill:hover {
            border-color: rgba(103, 240, 255, 0.46);
            color: #f4faff;
        }

        #loadout-modal .loadout-filter-pill.active {
            background: linear-gradient(135deg, rgba(103, 240, 255, 0.24), rgba(255, 79, 160, 0.2));
            border-color: rgba(103, 240, 255, 0.68);
            color: #ffffff;
            box-shadow: 0 8px 18px rgba(7, 14, 31, 0.45);
        }

        #loadout-modal .loadout-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
        }

        #loadout-modal .loadout-role-card {
            background: linear-gradient(145deg, rgba(10, 18, 35, 0.94), rgba(13, 24, 48, 0.86)) !important;
            border: 1px solid rgba(103, 240, 255, 0.2) !important;
            border-radius: 16px !important;
            overflow: hidden;
            transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
        }

        #loadout-modal .loadout-role-card:hover {
            transform: translateY(-4px);
            border-color: rgba(103, 240, 255, 0.48) !important;
            box-shadow: 0 16px 30px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(103, 240, 255, 0.18);
        }

        #loadout-modal .loadout-role-card.active {
            border-color: rgba(103, 240, 255, 0.78) !important;
            box-shadow: 0 0 0 1px rgba(103, 240, 255, 0.5), 0 18px 34px rgba(0, 0, 0, 0.4);
        }

        #loadout-modal .loadout-card-visual {
            height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at 50% 40%, rgba(103, 240, 255, 0.18), rgba(8, 14, 29, 0.2) 65%, transparent 95%);
            border-bottom: 1px solid rgba(103, 240, 255, 0.16);
            position: relative;
        }

        #loadout-modal .loadout-card-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-family: var(--font-display);
            font-size: 10px;
            font-weight: 800;
            letter-spacing: 0.8px;
            background: rgba(10, 16, 30, 0.88);
            color: rgba(229, 238, 255, 0.85);
        }

        #loadout-modal .loadout-card-body {
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #loadout-modal .loadout-card-name {
            font-family: var(--font-heading);
            color: #f6faff;
            font-size: 19px;
            font-weight: 800;
            line-height: 1.2;
        }

        #loadout-modal .loadout-card-meta {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            font-size: 11px;
            color: rgba(214, 226, 247, 0.72);
            text-transform: uppercase;
            letter-spacing: 0.7px;
            font-weight: 700;
        }

        #loadout-modal .loadout-card-desc {
            font-size: 12px;
            color: rgba(214, 226, 247, 0.8);
            line-height: 1.45;
            min-height: 36px;
        }

        #loadout-modal .loadout-card-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-top: 2px;
        }

        #loadout-modal .loadout-card-chip {
            padding: 4px 10px;
            border-radius: 8px;
            border: 1px solid rgba(103, 240, 255, 0.24);
            background: rgba(103, 240, 255, 0.08);
            color: rgba(223, 235, 255, 0.86);
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.3px;
        }

        #loadout-modal .loadout-card-cta {
            flex: 1;
            height: 34px;
            border-radius: 9px;
            border: 1px solid rgba(103, 240, 255, 0.28);
            background: rgba(103, 240, 255, 0.08);
            color: #eef7ff;
            font-family: var(--font-heading);
            font-size: 12px;
            font-weight: 800;
            letter-spacing: 0.8px;
            text-transform: uppercase;
            cursor: pointer;
        }

        #loadout-modal .loadout-card-cta.ready {
            border-color: rgba(255, 209, 102, 0.55);
            background: rgba(255, 209, 102, 0.14);
            color: #ffe6b0;
        }

        #loadout-modal .loadout-group {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        #loadout-modal .loadout-group-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        #loadout-modal .loadout-group-title {
            font-family: var(--font-display);
            font-size: 18px;
            color: #f4f9ff;
            letter-spacing: 1.5px;
            font-weight: 900;
        }

        #loadout-modal .loadout-group-line {
            flex: 1;
            height: 1px;
            background: linear-gradient(90deg, rgba(103, 240, 255, 0.28), rgba(103, 240, 255, 0.03));
        }
    </style>
</head>

<body>
    <canvas id="particles-bg"></canvas>

    <div class="game-layout">
        <!-- Header -->
        <div class="game-header">
            <div class="logo">
                <div class="logo-icon">⚔️</div>
                <div class="logo-text">
                    <h1>Wild Destiny</h1>
                    <p>Core Edition</p>
                </div>
            </div>
            <div class="header-actions">
                <div class="menu-toggle" id="menu-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>

        <!-- Menu Overlay & Side Menu -->
        <div class="menu-overlay" id="menu-overlay"></div>
        <div class="side-menu" id="side-menu">
            <div class="side-menu-header">
                <h2>MEN&Uacute;</h2>
                <p>Wild Destiny</p>
            </div>

            <div class="menu-section">
                <div class="menu-section-title">&#x2694;&#xFE0F; Combate</div>
                <div class="menu-item" id="menu-raid-btn">
                    <div class="menu-item-icon">&#x1F5E1;&#xFE0F;</div>
                    <div class="menu-item-text">
                        <div class="menu-item-title">Raids (Survival)</div>
                        <div class="menu-item-desc">Sobrevive oleadas infinitas - Premios Generales</div>
                    </div>
                </div>
                <div class="menu-item" id="menu-dungeon-btn">
                    <div class="menu-item-icon">&#x1F3F0;</div>
                    <div class="menu-item-text">
                        <div class="menu-item-title">Dungeons</div>
                        <div class="menu-item-desc">Misiones Espec&iacute;ficas - Tickets de Clase</div>
                    </div>
                </div>
                <div class="menu-item" id="menu-custom-raid-btn">
                    <div class="menu-item-icon">&#x1F3AE;</div>
                    <div class="menu-item-text">
                        <div class="menu-item-title">Custom Raid</div>
                        <div class="menu-item-desc">Personaliza tus enemigos y desaf&iacute;os</div>
                    </div>
                </div>
                <div class="menu-item" id="menu-practice-btn">
                    <div class="menu-item-icon">&#x1F3AF;</div>
                    <div class="menu-item-text">
                        <div class="menu-item-title">Modo Pr&aacute;ctica</div>
                        <div class="menu-item-desc">Practica combos y habilidades sin l&iacute;mites</div>
                    </div>
                </div>
            </div>

            <div class="menu-section">
                <div class="menu-section-title">&#x2694;&#xFE0F; Equipamiento</div>
                <div class="menu-item" id="menu-loadout-btn">
                    <div class="menu-item-icon">&#x2694;&#xFE0F;</div>
                    <div class="menu-item-text">
                        <div class="menu-item-title">Loadout &amp; Maestr&iacute;as</div>
                        <div class="menu-item-desc">Gestiona tu equipamiento y misiones</div>
                    </div>
                </div>
                <div class="menu-item" id="menu-class-upgrades-btn">
                    <div class="menu-item-icon">&#x1F4CA;</div>
                    <div class="menu-item-text">
                        <div class="menu-item-title">Mejoras de Clase</div>
                        <div class="menu-item-desc">Ver progresi&oacute;n y mejoras desbloqueadas</div>
                    </div>
                </div>
            </div>

            <div class="menu-section">
                <div class="menu-section-title">&#x2139;&#xFE0F; Informaci&oacute;n</div>
                <div class="menu-item" id="menu-update-log-btn">
                    <div class="menu-item-icon">&#x1F4CB;</div>
                    <div class="menu-item-text">
                        <div class="menu-item-title">Update Log</div>
                        <div class="menu-item-desc">Ver historial de actualizaciones</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Canvas Frame -->
        <div class="main-canvas">
            <canvas id="game-canvas" width="1100" height="700"></canvas>
            <div class="canvas-overlay">
                <div class="overlay-item">
                    <span class="overlay-label">⚡</span>
                    <span class="overlay-value" id="fps-counter" style="color: #00ff88;">60</span>
                </div>
                <div class="overlay-item">
                    <span class="overlay-label">🎫</span>
                    <span class="overlay-value" id="ticket-counter"
                        style="color: #ffd700; text-shadow: 0 0 15px rgba(255, 215, 0, 0.8);">0</span>
                </div>
            </div>
        </div>

        <!-- HUD Containers (Overlays) -->
        <div class="hud-container">
            <!-- Sidebar - Equipment -->
            <div class="sidebar">
                <div class="sidebar-section">
                    <div class="section-title">⚔️ Loadout</div>

                    <div class="equip-card" id="card-character">
                        <div class="equip-card-image" id="char-image">
                            <div class="equip-card-image-fallback">👤</div>
                        </div>
                        <div class="equip-card-content">
                            <div class="equip-card-header">
                                <div class="equip-info">
                                    <h3 id="char-name">Sin Personaje</h3>
                                    <div class="equip-type">Personaje</div>
                                </div>
                                <div class="equip-status">Vacío</div>
                            </div>
                        </div>
                    </div>

                    <div class="equip-card" id="card-class">
                        <div class="equip-card-image" id="class-image">
                            <div class="equip-card-image-fallback">🎯</div>
                        </div>
                        <div class="equip-card-content">
                            <div class="equip-card-header">
                                <div class="equip-info">
                                    <h3 id="class-name">Sin Clase</h3>
                                    <div class="equip-type">Clase</div>
                                </div>
                                <div class="equip-status">Vacío</div>
                            </div>
                        </div>
                    </div>

                    <div class="equip-card" id="card-fruit">
                        <div class="equip-card-image" id="fruit-image">
                            <div class="equip-card-image-fallback">🍎</div>
                        </div>
                        <div class="equip-card-content">
                            <div class="equip-card-header">
                                <div class="equip-info">
                                    <h3 id="fruit-name">Sin Fruta</h3>
                                    <div class="equip-type">Poder de Fruta</div>
                                </div>
                                <div class="equip-status">Vacío</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Stats Panel -->
            <div class="stats-panel">
                <!-- Hero Card -->
                <div style="margin-bottom: 20px;">
                    <div class="section-title" id="stats-hero-section-title">👤 Héroe</div>
                    <div class="equip-card" id="stats-hero-card">
                        <div class="equip-card-image" id="stats-hero-image">
                            <div class="equip-card-image-fallback">?</div>
                        </div>
                        <div class="equip-card-content">
                            <div style="text-align: center;">
                                <h3 id="stats-hero-name"
                                    style="font-size: 16px; font-weight: 800; color: var(--light); margin-bottom: 5px;">
                                    Sin
                                    Equipamiento</h3>
                                <div id="stats-hero-type"
                                    style="font-size: 10px; color: var(--primary); text-transform: uppercase; letter-spacing: 1px; font-weight: 600;">
                                    Selecciona un personaje o clase</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sidebar-section">
                    <div class="section-title">📊 Estadísticas</div>

                    <div class="stat-card">
                        <h4>Salud</h4>
                        <div class="stat-bar">
                            <div class="stat-bar-fill" style="width: 100%"></div>
                        </div>
                        <div class="stat-text">
                            <span>100 / 100</span>
                            <span>100%</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <h4>Energía</h4>
                        <div class="stat-bar">
                            <div class="stat-bar-fill" style="width: 100%"></div>
                        </div>
                        <div class="stat-text">
                            <span>100 / 100</span>
                            <span>100%</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <h4>Experiencia</h4>
                        <div class="stat-bar">
                            <div class="stat-bar-fill" style="width: 45%"></div>
                        </div>
                        <div class="stat-text">
                            <span>Nivel 5</span>
                            <span>45%</span>
                        </div>
                    </div>
                </div>

                <div class="minimap">
                    <div class="minimap-title">🗺️ Minimapa</div>
                    <canvas class="minimap-canvas" id="minimap" width="260" height="150"></canvas>
                </div>
            </div>
        </div>

        <!-- Ability Bar (Floating Dock) -->
        <div class="ability-bar">
            <!-- Player Stats -->
            <div style="display: flex; gap: 30px; align-items: center;">
                <div style="text-align: center;">
                    <div
                        style="font-size: 10px; color: var(--primary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px;">
                        Tickets</div>
                    <div style="font-size: 24px; font-weight: 900; color: var(--accent); font-family: 'Orbitron', sans-serif;"
                        id="total-tickets-display">0</div>
                </div>
                <div
                    style="width: 1px; height: 30px; background: linear-gradient(180deg, var(--primary), var(--secondary));">
                </div>
                <div style="text-align: center;">
                    <div
                        style="font-size: 10px; color: var(--primary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px;">
                        Clases</div>
                    <div style="font-size: 24px; font-weight: 900; color: var(--light); font-family: 'Orbitron', sans-serif;"
                        id="unlocked-classes-display">0</div>
                </div>
                <div
                    style="width: 1px; height: 30px; background: linear-gradient(180deg, var(--primary), var(--secondary));">
                </div>
                <div style="text-align: center;">
                    <div
                        style="font-size: 10px; color: var(--primary); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px;">
                        Maestrías</div>
                    <div style="font-size: 24px; font-weight: 900; color: #ff00ff; font-family: 'Orbitron', sans-serif;"
                        id="masteries-completed-display">0</div>
                </div>
            </div>

            <!-- Quick Info -->
            <div
                style="text-align: center; margin-left: 20px; border-left: 1px solid rgba(255,255,255,0.1); padding-left: 20px;">
                <div
                    style="font-size: 9px; color: rgba(224, 231, 255, 0.6); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px;">
                    Estado</div>
                <div style="font-size: 12px; color: var(--primary); font-weight: 700;">🟢 Listo</div>
            </div>
        </div>
    </div>

    <!-- Modal -->
    <div id="role-selection-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>SELECT LOADOUT</h2>
                <button class="close-button">✕</button>
            </div>
            <div class="modal-tabs">
                <button class="tab-button active" data-tab="characters">👤 Characters</button>
                <button class="tab-button" data-tab="classes">🎯 Classes</button>
                <button class="tab-button" data-tab="fruits">🍎 Fruits</button>
            </div>
            <div class="modal-body">
                <div id="role-grid" class="role-grid"></div>
            </div>
        </div>
    </div>

    <!-- Update Log Modal -->
    <div id="update-log-modal" class="modal hidden">
        <div class="modal-content" style="max-width: 1600px; height: 90vh;">
            <div class="modal-header">
                <h2>📋 UPDATE LOG - Wild Destiny</h2>
                <button class="close-button" id="close-update-log">✕</button>
            </div>
            <div class="modal-body" style="height: calc(100% - 80px); display: flex; gap: 0;">
                <!-- Left Sidebar - Update List -->
                <div
                    style="width: 300px; background: linear-gradient(180deg, rgba(0, 217, 255, 0.1), rgba(255, 0, 110, 0.1)); border-right: 2px solid rgba(0, 217, 255, 0.3); overflow-y: auto;">
                    <div style="padding: 20px;">
                        <h3 style="color: var(--primary); font-size: 18px; margin-bottom: 20px; text-align: center;">
                            Historial de Updates</h3>

                        <div class="update-item active" data-update="v24-11-2025"
                            style="padding: 15px; margin-bottom: 10px; background: rgba(0, 217, 255, 0.2); border-radius: 10px; cursor: pointer; border-left: 4px solid var(--primary);">
                            <div style="font-weight: 700; color: var(--primary); margin-bottom: 5px;">v24.11.2025</div>
                            <div style="font-size: 12px; color: rgba(224, 231, 255, 0.8);">Loader Épico & Header
                                Rediseñado</div>
                        </div>

                        <div class="update-item" data-update="v23-11-2025"
                            style="padding: 15px; margin-bottom: 10px; background: rgba(0, 217, 255, 0.1); border-radius: 10px; cursor: pointer; border-left: 4px solid transparent;">
                            <div style="font-weight: 700; color: var(--light); margin-bottom: 5px;">v23.11.2025</div>
                            <div style="font-size: 12px; color: rgba(224, 231, 255, 0.8);">🔧 Polish Update -
                                Correcciones Masivas</div>
                        </div>

                        <div class="update-item" data-update="v20-11-2025"
                            style="padding: 15px; margin-bottom: 10px; background: rgba(0, 217, 255, 0.1); border-radius: 10px; cursor: pointer; border-left: 4px solid transparent;">
                            <div style="font-weight: 700; color: var(--light); margin-bottom: 5px;">v20.11.2025</div>
                            <div style="font-size: 12px; color: rgba(224, 231, 255, 0.8);">🏆 Complete Edition -
                                Lanzamiento Global</div>
                        </div>

                        <div class="update-item" data-update="v3-0"
                            style="padding: 15px; margin-bottom: 10px; background: rgba(0, 217, 255, 0.1); border-radius: 10px; cursor: pointer; border-left: 4px solid transparent;">
                            <div style="font-weight: 700; color: var(--light); margin-bottom: 5px;">v3.0</div>
                            <div style="font-size: 12px; color: rgba(224, 231, 255, 0.8);">🌪️ Wind Master -
                                Actualización Masiva</div>
                        </div>
                    </div>
                </div>

                <!-- Right Content - Update Details -->
                <div style="flex: 1; overflow-y: auto; padding: 30px;">
                    <div id="update-content">
                        <!-- v24.11.2025 Content (Default) -->
                        <div class="update-content active" data-update="v24-11-2025">
                            <div
                                style="text-align: center; margin-bottom: 40px; padding: 30px; background: linear-gradient(135deg, rgba(0, 217, 255, 0.2), rgba(255, 0, 110, 0.2)); border-radius: 20px; border: 3px solid var(--primary);">
                                <h2
                                    style="font-size: 48px; margin-bottom: 15px; background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 900;">
                                    ⚔️ v24.11.2025 - EPIC REDESIGN ⚔️
                                </h2>
                                <p style="font-size: 18px; color: var(--primary); letter-spacing: 2px;">LOADER ÉPICO &
                                    HEADER REDISEÑADO</p>
                            </div>

                            <!-- Loader Épico -->
                            <div style="margin-bottom: 30px;">
                                <h3 style="color: var(--accent); font-size: 24px; margin-bottom: 15px;">🎬 LOADER
                                    COMPLETAMENTE REDISEÑADO</h3>
                                <div style="background: rgba(0, 217, 255, 0.1); border-radius: 15px; padding: 20px;">
                                    <div
                                        style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: var(--primary); margin-bottom: 10px;">🎥 Video Intro</h4>
                                            <p style="font-size: 14px;">• Video de introducción épico</p>
                                            <p style="font-size: 14px;">• Espera automática hasta que termine</p>
                                            <p style="font-size: 14px;">• Fallback visual si no hay video</p>
                                        </div>
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: var(--secondary); margin-bottom: 10px;">✨ Efectos Visuales
                                            </h4>
                                            <p style="font-size: 14px;">• 30 partículas animadas flotantes</p>
                                            <p style="font-size: 14px;">• Fondo rotatorio con luces</p>
                                            <p style="font-size: 14px;">• Barra de progreso con shimmer</p>
                                        </div>
                                    </div>
                                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                        <h4 style="color: var(--accent); margin-bottom: 10px;">📊 Progreso Inteligente
                                        </h4>
                                        <p style="font-size: 14px;">• Mensajes de estado dinámicos • Porcentaje visible
                                            • Layout horizontal épico</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Header Rediseñado -->
                            <div style="margin-bottom: 30px;">
                                <h3 style="color: var(--accent); font-size: 24px; margin-bottom: 15px;">🎨 HEADER
                                    COMPLETAMENTE REDISEÑADO</h3>
                                <div style="background: rgba(255, 0, 110, 0.1); border-radius: 15px; padding: 20px;">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: var(--primary); margin-bottom: 10px;">⚔️ Logo Épico</h4>
                                            <p style="font-size: 14px;">• Icono flotante con rotación</p>
                                            <p style="font-size: 14px;">• Borde con gradiente rotatorio</p>
                                            <p style="font-size: 14px;">• Múltiples efectos glow</p>
                                        </div>
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: var(--secondary); margin-bottom: 10px;">✨ Efectos
                                                Avanzados</h4>
                                            <p style="font-size: 14px;">• Brillo que cruza el header</p>
                                            <p style="font-size: 14px;">• Gradiente animado en título</p>
                                            <p style="font-size: 14px;">• Subtítulo con pulso</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Correcciones -->
                            <div style="margin-bottom: 30px;">
                                <h3 style="color: var(--accent); font-size: 24px; margin-bottom: 15px;">🔧 CORRECCIONES
                                    MASIVAS</h3>
                                <div style="background: rgba(255, 190, 11, 0.1); border-radius: 15px; padding: 20px;">
                                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                        <h4 style="color: var(--accent); margin-bottom: 10px;">📝 Caracteres Corruptos
                                        </h4>
                                        <p style="font-size: 14px;">• Todos los "í" reemplazados por caracteres
                                            correctos</p>
                                        <p style="font-size: 14px;">• Todos los "??" reemplazados por emojis apropiados
                                        </p>
                                        <p style="font-size: 14px;">• Texto completamente legible en español</p>
                                        <p style="font-size: 14px;">• Iconos consistentes en toda la UI</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Other update contents will be added here -->
                        <div class="update-content" data-update="v23-11-2025" style="display: none;">
                            <div
                                style="text-align: center; margin-bottom: 40px; padding: 30px; background: linear-gradient(135deg, rgba(255, 190, 11, 0.2), rgba(255, 0, 110, 0.2)); border-radius: 20px; border: 3px solid var(--accent);">
                                <h2
                                    style="font-size: 48px; margin-bottom: 15px; background: linear-gradient(90deg, var(--accent), var(--secondary), var(--primary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 900;">
                                    🔧 v23.11.2025 - POLISH UPDATE 🔧
                                </h2>
                                <p style="font-size: 18px; color: var(--accent); letter-spacing: 2px;">CORRECCIÓN MASIVA
                                    & MEJORAS DE UI</p>
                            </div>

                            <!-- Corrección de Caracteres -->
                            <div style="margin-bottom: 30px;">
                                <h3 style="color: var(--accent); font-size: 24px; margin-bottom: 15px;">📝 CORRECCIÓN
                                    MASIVA DE CARACTERES</h3>
                                <div style="background: rgba(255, 190, 11, 0.1); border-radius: 15px; padding: 20px;">
                                    <div
                                        style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: var(--accent); margin-bottom: 10px;">🔤 Caracteres
                                                Corruptos</h4>
                                            <p style="font-size: 14px;">• Todos los "í" corregidos</p>
                                            <p style="font-size: 14px;">• Acentos restaurados (á, é, í, ó, ú)</p>
                                            <p style="font-size: 14px;">• Ñ y caracteres especiales</p>
                                        </div>
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: var(--primary); margin-bottom: 10px;">🎯 Iconos
                                                Consistentes</h4>
                                            <p style="font-size: 14px;">• Todos los "??" reemplazados</p>
                                            <p style="font-size: 14px;">• Emojis apropiados por sección</p>
                                            <p style="font-size: 14px;">• Consistencia visual total</p>
                                        </div>
                                    </div>
                                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                        <h4 style="color: var(--secondary); margin-bottom: 10px;">🌍 Localización
                                            Completa</h4>
                                        <p style="font-size: 14px;">• Menús completamente en español • Habilidades
                                            legibles • Estadísticas corregidas</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Mejoras de UI -->
                            <div style="margin-bottom: 30px;">
                                <h3 style="color: var(--primary); font-size: 24px; margin-bottom: 15px;">🎨 MEJORAS DE
                                    INTERFAZ</h3>
                                <div style="background: rgba(0, 217, 255, 0.1); border-radius: 15px; padding: 20px;">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: var(--primary); margin-bottom: 10px;">⚔️ Sidebar Mejorado
                                            </h4>
                                            <p style="font-size: 14px;">• Iconos de equipamiento claros</p>
                                            <p style="font-size: 14px;">• Estados "Vacío" corregidos</p>
                                            <p style="font-size: 14px;">• Navegación más intuitiva</p>
                                        </div>
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: var(--secondary); margin-bottom: 10px;">📊 Estadísticas
                                                Claras</h4>
                                            <p style="font-size: 14px;">• "Energía" correctamente escrito</p>
                                            <p style="font-size: 14px;">• Minimapa con icono apropiado</p>
                                            <p style="font-size: 14px;">• Overlay de FPS y Tickets</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="update-content" data-update="v20-11-2025" style="display: none;">
                            <div
                                style="text-align: center; margin-bottom: 40px; padding: 30px; background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 140, 0, 0.3)); border-radius: 20px; border: 3px solid #ffd700;">
                                <h2
                                    style="font-size: 48px; margin-bottom: 15px; background: linear-gradient(90deg, #ffd700, #ff8c00, #ff4500); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 900;">
                                    🏆 v20.11.2025 - COMPLETE EDITION 🏆
                                </h2>
                                <p style="font-size: 18px; color: #ffd700; letter-spacing: 2px;">EL JUEGO DEFINITIVO
                                    ESTÁ AQUÍ</p>
                                <p style="font-size: 14px; color: rgba(255, 255, 255, 0.9);">Sistema de Maestrías •
                                    Clases Maestras • Misiones Épicas • Balance Perfecto</p>
                            </div>

                            <!-- Sistema de Maestrías -->
                            <div style="margin-bottom: 30px;">
                                <h3 style="color: #ff00ff; font-size: 24px; margin-bottom: 15px;">🏆 SISTEMA DE
                                    MAESTRÍAS COMPLETO</h3>
                                <div
                                    style="background: linear-gradient(135deg, rgba(255, 0, 255, 0.15), rgba(138, 43, 226, 0.15)); border-radius: 15px; padding: 20px;">
                                    <div
                                        style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: #ff00ff; margin-bottom: 10px;">🎯 Misiones Épicas</h4>
                                            <p style="font-size: 14px;">• Desafíos únicos por clase</p>
                                            <p style="font-size: 14px;">• Objetivos progresivos</p>
                                            <p style="font-size: 14px;">• Recompensas exclusivas</p>
                                        </div>
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: #ffd700; margin-bottom: 10px;">👑 Clases Maestras</h4>
                                            <p style="font-size: 14px;">• Versiones supremas desbloqueables</p>
                                            <p style="font-size: 14px;">• Habilidades mejoradas</p>
                                            <p style="font-size: 14px;">• Efectos visuales únicos</p>
                                        </div>
                                    </div>
                                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                        <h4 style="color: #00d9ff; margin-bottom: 10px;">📈 Progresión Avanzada</h4>
                                        <p style="font-size: 14px;">• Sistema de tracking automático • Interfaz de
                                            progreso visual • Recompensas escaladas</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Regeneración Pasiva -->
                            <div style="margin-bottom: 30px;">
                                <h3 style="color: #00ff88; font-size: 24px; margin-bottom: 15px;">✨ REGENERACIÓN PASIVA
                                </h3>
                                <div style="background: rgba(0, 255, 136, 0.1); border-radius: 15px; padding: 20px;">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px; text-align: center;">
                                            <div style="font-size: 32px; color: #00ff88; margin-bottom: 10px;">3s</div>
                                            <p style="font-size: 14px;">Delay sin daño</p>
                                        </div>
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px; text-align: center;">
                                            <div style="font-size: 32px; color: #00ff88; margin-bottom: 10px;">2 HP/s
                                            </div>
                                            <p style="font-size: 14px;">Tasa de regeneración</p>
                                        </div>
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px; text-align: center;">
                                            <div style="font-size: 32px; color: #00ff88; margin-bottom: 10px;">∞</div>
                                            <p style="font-size: 14px;">Hasta HP máximo</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Correcciones Críticas -->
                            <div style="margin-bottom: 30px;">
                                <h3 style="color: #ffbe0b; font-size: 24px; margin-bottom: 15px;">🔧 CORRECCIONES
                                    CRÍTICAS</h3>
                                <div style="background: rgba(255, 190, 11, 0.1); border-radius: 15px; padding: 20px;">
                                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                        <h4 style="color: #ffbe0b; margin-bottom: 10px;">⚡ Bug de Velocidad Permanente
                                        </h4>
                                        <p style="font-size: 14px;">• Efectos de atracción corregidos • Sistema de
                                            velocidad base restaurado • Slows temporales funcionan correctamente</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="update-content" data-update="v3-0" style="display: none;">
                            <div
                                style="text-align: center; margin-bottom: 40px; padding: 30px; background: linear-gradient(135deg, rgba(57, 255, 20, 0.2), rgba(138, 43, 226, 0.2)); border-radius: 20px; border: 3px solid #39ff14;">
                                <h2
                                    style="font-size: 48px; margin-bottom: 15px; background: linear-gradient(90deg, #39ff14, #00ffaa, #8a2be2); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 900;">
                                    🌪️ v3.0 - WIND MASTER UPDATE 🌪️
                                </h2>
                                <p style="font-size: 18px; color: #39ff14; letter-spacing: 2px;">LA ACTUALIZACIÓN MÁS
                                    GRANDE HASTA AHORA</p>
                                <p style="font-size: 14px; color: rgba(224, 231, 255, 0.7);">Nueva clase S-Tier •
                                    Enemigos extremos • Rediseños completos • Sistema de información</p>
                            </div>

                            <!-- Nueva Clase S-Tier -->
                            <div style="margin-bottom: 30px;">
                                <h3 style="color: #39ff14; font-size: 24px; margin-bottom: 15px;">🌪️ WIND MASTER -
                                    NUEVA CLASE S-TIER</h3>
                                <div
                                    style="background: linear-gradient(135deg, rgba(57, 255, 20, 0.15), rgba(0, 255, 170, 0.15)); border-radius: 15px; padding: 20px;">
                                    <div style="text-align: center; margin-bottom: 20px;">
                                        <div style="font-size: 60px; margin-bottom: 10px;">🌪️</div>
                                        <h4 style="color: #39ff14; font-size: 20px; margin-bottom: 10px;">Wind Master -
                                            TIER S</h4>
                                        <p style="color: #ff0080; font-weight: 900; font-size: 16px;">🎫 REQUIERE 3
                                            TICKETS 🎫</p>
                                    </div>
                                    <div
                                        style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px; margin-bottom: 15px;">
                                        <p style="margin: 10px 0; font-size: 14px;"><strong style="color: #39ff14;">🌪️
                                                Viento Radioactivo (E):</strong> Lanza viento en 4 direcciones que
                                            aplica radioactividad por 7s</p>
                                        <p style="margin: 10px 0; font-size: 14px;"><strong style="color: #00ff88;">💚
                                                Burbujas de Aire Tóxico (T):</strong> Despliega 5 burbujas explosivas
                                            con envenenamiento</p>
                                        <p style="margin: 10px 0; font-size: 14px;"><strong style="color: #00ffaa;">🌀
                                                Atracción del Viento Fuerte (F):</strong> Atrae enemigos con
                                            invulnerabilidad de 6s</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Enemigos Extremos -->
                            <div style="margin-bottom: 30px;">
                                <h3 style="color: #ff0080; font-size: 24px; margin-bottom: 15px;">👹 NUEVOS ENEMIGOS
                                    EXTREMOS</h3>
                                <div style="background: rgba(255, 0, 128, 0.1); border-radius: 15px; padding: 20px;">
                                    <div
                                        style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: #39ff14; margin-bottom: 10px;">🌪️ Toxic Zephyr</h4>
                                            <p style="font-size: 14px;">HP: 60 | Speed: 95 | Damage: 15</p>
                                            <p style="font-size: 12px;">• 25% Evasión • Radiación constante • Toxic Dash
                                            </p>
                                        </div>
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: #00ff88; margin-bottom: 10px;">☢️ Radioactive Cyclone</h4>
                                            <p style="font-size: 14px;">HP: 70 | Speed: 85 | Damage: 18</p>
                                            <p style="font-size: 12px;">• Pull Effect • Radiation Pulse • Infección</p>
                                        </div>
                                    </div>
                                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                        <h4 style="color: #00ffaa; margin-bottom: 10px;">👑 Tempest Lord - BOSS EXTREMO
                                        </h4>
                                        <p style="font-size: 14px;">HP: 380 | Speed: 60 | Damage: 42 • Wind Barrier •
                                            Phase Shift • Enrage <25% HP</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Clases Rediseñadas -->
                            <div style="margin-bottom: 30px;">
                                <h3 style="color: #9d4edd; font-size: 24px; margin-bottom: 15px;">🔄 CLASES
                                    COMPLETAMENTE REDISEÑADAS</h3>
                                <div style="background: rgba(157, 78, 221, 0.1); border-radius: 15px; padding: 20px;">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: #9d4edd; margin-bottom: 10px;">🥷 Shadow Ninja</h4>
                                            <p style="font-size: 14px;">• Marca de Muerte • Paso Fantasma • Asesino de
                                                Sombras</p>
                                        </div>
                                        <div
                                            style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                                            <h4 style="color: #ff4500; margin-bottom: 10px;">⚔️ Wild Berserker
                                            </h4>
                                            <p style="font-size: 14px;">• Furia Sangrienta • Torbellino de Muerte •
                                                Golpe Titánico • Frenesí de Dios</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- News Video Slider -->

    <div style="padding: 20px;">

        <!-- LATEST UPDATE v20.11.2025 -->
        <div
            style="text-align: center; margin-bottom: 50px; padding: 40px; background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 140, 0, 0.3), rgba(255, 69, 0, 0.3)); border-radius: 20px; border: 3px solid #ffd700; box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);">
            <h2
                style="font-size: 60px; margin-bottom: 15px; background: linear-gradient(90deg, #ffd700, #ff8c00, #ff4500, #ff1493); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: 900;">
                ? v20.11.2025 - COMPLETE EDITION ?
            </h2>
            <p
                style="font-size: 22px; color: rgba(255, 255, 255, 0.95); letter-spacing: 2px; margin-bottom: 15px; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);">
                EL JUEGO DEFINITIVO ESTÁ AQUÍ</p>
            <p style="font-size: 15px; color: rgba(255, 255, 255, 0.9);">Sistema de Maestrías • Clases Maestras •
                Misiones Épicas • Balance Perfecto</p>
        </div>

        <!-- MASTERY SYSTEM -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: #ff00ff; font-size: 36px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center; text-shadow: 0 0 25px #ff00ff;">
                🏆 SISTEMA DE MAESTRÍAS - NUEVO</h3>

            <div
                style="background: linear-gradient(135deg, rgba(0, 217, 255, 0.15), rgba(157, 78, 221, 0.15)); border: 3px solid #00d9ff; border-radius: 15px; padding: 30px; margin-bottom: 25px;">

                <!-- Passive Regeneration -->
                <div style="background: rgba(0, 0, 0, 0.4); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                    <h4 style="color: #00ff88; font-size: 24px; margin-bottom: 15px; text-align: center;">✨ NUEVO:
                        Regeneración Pasiva</h4>
                    <p style="color: var(--light); margin-bottom: 15px; text-align: center; font-size: 15px;">El jugador
                        ahora se cura automáticamente cuando no recibe daño</p>

                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                        <div
                            style="background: rgba(0, 255, 136, 0.15); border: 1px solid #00ff88; border-radius: 8px; padding: 15px; text-align: center;">
                            <p style="color: #00ff88; font-size: 32px; font-weight: bold; margin-bottom: 5px;">3s</p>
                            <p style="font-size: 13px; color: rgba(224, 231, 255, 0.9);">Delay sin daño</p>
                        </div>
                        <div
                            style="background: rgba(0, 255, 136, 0.15); border: 1px solid #00ff88; border-radius: 8px; padding: 15px; text-align: center;">
                            <p style="color: #00ff88; font-size: 32px; font-weight: bold; margin-bottom: 5px;">2 HP/s
                            </p>
                            <p style="font-size: 13px; color: rgba(224, 231, 255, 0.9);">Tasa de regeneración</p>
                        </div>
                        <div
                            style="background: rgba(0, 255, 136, 0.15); border: 1px solid #00ff88; border-radius: 8px; padding: 15px; text-align: center;">
                            <p style="color: #00ff88; font-size: 32px; font-weight: bold; margin-bottom: 5px;">∞</p>
                            <p style="font-size: 13px; color: rgba(224, 231, 255, 0.9);">Hasta HP máximo</p>
                        </div>
                    </div>
                </div>

                <!-- Speed Bug Fix -->
                <div style="background: rgba(0, 0, 0, 0.4); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                    <h4 style="color: #ffbe0b; font-size: 24px; margin-bottom: 15px; text-align: center;">?? FIX: Bug de
                        Velocidad Permanente</h4>
                    <p style="color: var(--light); margin-bottom: 15px; text-align: center; font-size: 15px;">Corregido
                        el bug donde la velocidad del jugador se reducía permanentemente</p>

                    <div
                        style="background: rgba(255, 190, 11, 0.1); border: 1px solid #ffbe0b; border-radius: 8px; padding: 15px;">
                        <p style="margin: 8px 0; font-size: 14px;">? <strong>Problema:</strong> Los efectos de atracción
                            de Wind Master causaban reducción permanente de velocidad</p>
                        <p style="margin: 8px 0; font-size: 14px;">? <strong>Soluciín:</strong> Sistema de velocidad
                            base que restaura la velocidad correctamente</p>
                        <p style="margin: 8px 0; font-size: 14px;">? <strong>Resultado:</strong> Los slows temporales
                            ahora funcionan correctamente sin efectos permanentes</p>
                    </div>
                </div>

                <!-- Scene Cleanup -->
                <div style="background: rgba(0, 0, 0, 0.4); border-radius: 12px; padding: 20px;">
                    <h4 style="color: #9d4edd; font-size: 24px; margin-bottom: 15px; text-align: center;">?? NUEVO:
                        Limpieza Completa de Escena</h4>
                    <p style="color: var(--light); margin-bottom: 15px; text-align: center; font-size: 15px;">Al
                        finalizar un raid, todo se limpia para empezar fresco</p>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div
                            style="background: rgba(157, 78, 221, 0.1); border: 1px solid #9d4edd; border-radius: 8px; padding: 12px;">
                            <p style="margin: 6px 0; font-size: 13px; color: #9d4edd;">?? <strong>Limpieza
                                    Visual</strong></p>
                            <p style="margin: 6px 0; font-size: 12px;">Burbujas tóxicas, proyectiles, efectos</p>
                        </div>
                        <div
                            style="background: rgba(157, 78, 221, 0.1); border: 1px solid #9d4edd; border-radius: 8px; padding: 12px;">
                            <p style="margin: 6px 0; font-size: 13px; color: #9d4edd;">?? <strong>Reset de
                                    Estado</strong></p>
                            <p style="margin: 6px 0; font-size: 12px;">Velocidad, buffs, efectos activos</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Wind Master Balance -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: #39ff14; font-size: 32px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center; text-shadow: 0 0 20px #39ff14;">
                ?? BALANCE: WIND MASTER MOBS</h3>

            <div
                style="background: linear-gradient(135deg, rgba(57, 255, 20, 0.15), rgba(0, 255, 136, 0.15)); border: 3px solid #39ff14; border-radius: 15px; padding: 30px;">
                <p style="color: var(--light); margin-bottom: 20px; font-size: 15px; text-align: center;">Nerfs
                    adicionales a los mobs regulares para mejor experiencia de juego</p>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <!-- Toxic Zephyr -->
                    <div style="background: rgba(0, 0, 0, 0.4); border-radius: 12px; padding: 20px;">
                        <h4 style="color: #39ff14; font-size: 20px; margin-bottom: 15px; text-align: center;">?? Toxic
                            Zephyr</h4>
                        <div style="background: rgba(57, 255, 20, 0.1); border-radius: 8px; padding: 12px;">
                            <p style="margin: 6px 0; font-size: 14px;">Daño: <span style="color: #ff4444;">12 ?
                                    10</span></p>
                            <p style="margin: 6px 0; font-size: 14px;">Atracción: <span style="color: #ff4444;">Reducida
                                    70%</span></p>
                        </div>
                    </div>

                    <!-- Radioactive Cyclone -->
                    <div style="background: rgba(0, 0, 0, 0.4); border-radius: 12px; padding: 20px;">
                        <h4 style="color: #00ff88; font-size: 20px; margin-bottom: 15px; text-align: center;">??
                            Radioactive Cyclone</h4>
                        <div style="background: rgba(0, 255, 136, 0.1); border-radius: 8px; padding: 12px;">
                            <p style="margin: 6px 0; font-size: 14px;">Daño: <span style="color: #ff4444;">15 ?
                                    12</span></p>
                            <p style="margin: 6px 0; font-size: 14px;">Atracción: <span style="color: #ff4444;">Reducida
                                    73%</span></p>
                        </div>
                    </div>
                </div>

                <div
                    style="background: rgba(0, 255, 0, 0.1); border: 1px solid #00ff00; border-radius: 10px; padding: 15px; text-align: center;">
                    <p style="color: #00ff00; font-weight: bold; margin-bottom: 8px;">? Resultado del Balance</p>
                    <p style="font-size: 14px;">Los mobs de Wind Master son desafiantes pero justos. El boss Tempest
                        Lord mantiene su dificultad Épica.</p>
                </div>
            </div>
        </div>

        <!-- Wind Master Buff Recap -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: #39ff14; font-size: 28px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center;">
                ?? WIND MASTER - VIENTO RADIOACTIVO BUFF</h3>
            <div
                style="background: linear-gradient(135deg, rgba(57, 255, 20, 0.15), rgba(0, 255, 136, 0.15)); border: 2px solid #39ff14; border-radius: 15px; padding: 25px;">

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div
                        style="background: rgba(57, 255, 20, 0.15); border: 1px solid #39ff14; border-radius: 8px; padding: 15px;">
                        <h5 style="color: #39ff14; margin-bottom: 10px; text-align: center;">?? Cooldown</h5>
                        <p style="margin: 6px 0; font-size: 14px; text-align: center;"><span
                                style="color: #ff4444;">4.5s</span> ? <span style="color: #00ff88;">4.0s</span></p>
                    </div>

                    <div
                        style="background: rgba(0, 255, 136, 0.2); border: 2px solid #00ff88; border-radius: 8px; padding: 15px;">
                        <h5 style="color: #00ff88; margin-bottom: 10px; text-align: center;">? Buff de Daño</h5>
                        <p style="margin: 4px 0; font-size: 12px;">100% enemigos: +20% daño (4s)</p>
                        <p style="margin: 4px 0; font-size: 12px;">75%+: +15% í 50%+: +10% í 25%+: +5%</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- New Modal System Recap -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: #00d9ff; font-size: 28px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center;">
                ?? MODAL DE INFORMACIÓN REDISEÑADO</h3>
            <div
                style="background: linear-gradient(135deg, rgba(0, 217, 255, 0.15), rgba(157, 78, 221, 0.15)); border: 2px solid #00d9ff; border-radius: 15px; padding: 25px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                    <div
                        style="background: rgba(0, 217, 255, 0.1); border: 1px solid #00d9ff; border-radius: 8px; padding: 12px; text-align: center;">
                        <p style="font-size: 32px; margin-bottom: 8px;">??</p>
                        <p style="font-size: 13px; color: #00d9ff; font-weight: bold;">Mení Lateral</p>
                    </div>
                    <div
                        style="background: rgba(0, 217, 255, 0.1); border: 1px solid #00d9ff; border-radius: 8px; padding: 12px; text-align: center;">
                        <p style="font-size: 32px; margin-bottom: 8px;">??</p>
                        <p style="font-size: 13px; color: #00d9ff; font-weight: bold;">Por Categorías</p>
                    </div>
                    <div
                        style="background: rgba(0, 217, 255, 0.1); border: 1px solid #00d9ff; border-radius: 8px; padding: 12px; text-align: center;">
                        <p style="font-size: 32px; margin-bottom: 8px;">?</p>
                        <p style="font-size: 13px; color: #00d9ff; font-weight: bold;">Navegación Rípida</p>
                    </div>
                </div>
            </div>
        </div>

        <div
            style="background: rgba(0, 217, 255, 0.1); border: 2px solid #00d9ff; border-radius: 15px; padding: 25px; text-align: center; margin-bottom: 50px;">
            <p style="color: #00d9ff; font-size: 24px; font-weight: bold; margin-bottom: 10px;">?? EXPERIENCIA DE JUEGO
                MEJORADA</p>
            <p style="font-size: 15px; color: rgba(224, 231, 255, 0.9);">Sistema de combate más fluido í Balance
                refinado í Bugs críticos corregidos í Calidad de vida mejorada</p>
        </div>

        <!-- Separator -->
        <div
            style="height: 3px; background: linear-gradient(90deg, transparent, #00d9ff, transparent); margin: 50px 0;">
        </div>

        <!-- Version Header -->
        <div
            style="text-align: center; margin-bottom: 40px; padding: 30px; background: linear-gradient(135deg, rgba(57, 255, 20, 0.2), rgba(138, 43, 226, 0.2)); border-radius: 20px; border: 3px solid #39ff14;">
            <h2
                style="font-size: 48px; margin-bottom: 15px; background: linear-gradient(90deg, #39ff14, #00ffaa, #8a2be2); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: 900;">
                ??? v3.0 - WIND MASTER UPDATE ???
            </h2>
            <p style="font-size: 18px; color: rgba(224, 231, 255, 0.9); letter-spacing: 2px;">LA ACTUALIZACIÓN MÁS
                GRANDE HASTA AHORA</p>
            <p style="font-size: 14px; color: rgba(224, 231, 255, 0.7); margin-top: 10px;">Nueva clase S-Tier í Enemigos
                extremos í Rediseños completos í Sistema de información</p>
        </div>

        <!-- New S-Tier Class -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: #ff0080; font-size: 32px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center; text-shadow: 0 0 20px #ff0080;">
                ? NUEVA CLASE S-TIER</h3>

            <!-- Wind Master S-Tier -->
            <div
                style="background: linear-gradient(135deg, rgba(57, 255, 20, 0.15), rgba(0, 255, 170, 0.15)); border: 3px solid #39ff14; border-radius: 15px; padding: 30px; margin-bottom: 25px; box-shadow: 0 0 30px rgba(57, 255, 20, 0.3);">
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 80px; margin-bottom: 10px; filter: drop-shadow(0 0 20px #39ff14);">???</div>
                    <h4 style="color: #39ff14; font-size: 32px; margin-bottom: 10px; text-shadow: 0 0 15px #39ff14;">
                        Wind Master - TIER S</h4>
                    <p style="color: #ff0080; font-weight: 900; font-size: 20px; margin-bottom: 15px;">? REQUIERE 3
                        TICKETS ?</p>
                </div>
                <p style="color: var(--light); margin-bottom: 20px; font-size: 16px; text-align: center;">Maestro
                    supremo del viento que controla el aire tóxico y radioactivo. Sus enemigos son los más peligrosos
                    del juego.</p>
                <div style="background: rgba(0, 0, 0, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 15px;">
                    <p style="margin: 12px 0; font-size: 15px;"><strong style="color: #39ff14;">?? Viento Radioactivo
                            (E):</strong> Lanza viento en 4 direcciones que aplica radioactividad por 7s. La
                        radioactividad se propaga entre enemigos cercanos.</p>
                    <p style="margin: 12px 0; font-size: 15px;"><strong style="color: #00ff88;">?? Burbujas de Aire
                            Tóxico (T):</strong> Despliega 5 burbujas que explotan al contacto, aplicando envenenamiento
                        que reduce defensa y velocidad drísticamente.</p>
                    <p style="margin: 12px 0; font-size: 15px;"><strong style="color: #00ffaa;">?? Atracción del Viento
                            Fuerte (F):</strong> Atrae enemigos por 3s con invulnerabilidad de 6s, luego los lanza en
                        direcciones aleatorias con 65% de confusión.</p>
                </div>
                <div
                    style="background: rgba(255, 0, 128, 0.2); border: 2px solid #ff0080; border-radius: 10px; padding: 15px; text-align: center;">
                    <p style="color: #ff0080; font-weight: bold; margin-bottom: 8px;">?? ADVERTENCIA: CLASE DE
                        DIFICULTAD EXTREMA</p>
                    <p style="font-size: 13px;">Los mobs que dropean tickets de Wind Master son los más difíciles del
                        juego</p>
                </div>
            </div>

            <!-- Shadow Ninja Redesign -->
            <div
                style="background: linear-gradient(135deg, rgba(157, 78, 221, 0.15), rgba(75, 0, 130, 0.15)); border: 2px solid #9d4edd; border-radius: 15px; padding: 25px; margin-bottom: 25px;">
                <h4 style="color: #9d4edd; font-size: 24px; margin-bottom: 15px;">?? Shadow Ninja - REDISEÑADO</h4>
                <p style="color: var(--light); margin-bottom: 15px; font-size: 16px;">Maestro de las sombras
                    completamente rediseñado con letalidad absoluta.</p>
                <div style="margin-left: 20px;">
                    <p style="margin: 10px 0;"><strong style="color: #9d4edd;">?? Marca de Muerte (E):</strong> Marca 3
                        enemigos que reciben 30% más daño por 8s</p>
                    <p style="margin: 10px 0;"><strong style="color: #9d4edd;">?? Paso Fantasma (T):</strong>
                        Teletransporta detrás del enemigo + golpe crítico + invisibilidad 2s</p>
                    <p style="margin: 10px 0;"><strong style="color: #9d4edd;">?? Asesino de Sombras (F):</strong>
                        Ejecuta enemigos <30% HP + daño masivo a otros + invisibilidad 4s</p>
                </div>
            </div>

            <!-- Wild Berserker Redesign -->
            <div
                style="background: linear-gradient(135deg, rgba(157, 78, 221, 0.15), rgba(139, 0, 0, 0.15)); border: 2px solid #9d4edd; border-radius: 15px; padding: 25px; margin-bottom: 25px;">
                <h4 style="color: #9d4edd; font-size: 24px; margin-bottom: 15px;">?? Wild Berserker - REDISEÑADO</h4>
                <p style="color: var(--light); margin-bottom: 15px; font-size: 16px;">Guerrero salvaje que se vuelve más
                    fuerte con cada kill y daño recibido.</p>
                <div style="margin-left: 20px;">
                    <p style="margin: 10px 0;"><strong style="color: #ff4500;">?? Ira Imparable (E):</strong> Daño
                        escalado con HP baja (35-87%) + curación constante + 50% velocidad</p>
                    <p style="margin: 10px 0;"><strong style="color: #ffbe0b;">??? Hacha Giratoria (T):</strong> 4
                        ataques giratorios con radio creciente + knockback + stun</p>
                    <p style="margin: 10px 0;"><strong style="color: #ff0000;">?? Frenesí de Batalla (F):</strong> 70%
                        daño + cura por kill + daño aumenta con cada kill + 20% reducción de daño</p>
                </div>
            </div>
        </div>

        <!-- New Extreme Mobs -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: #ff0080; font-size: 32px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center; text-shadow: 0 0 20px #ff0080;">
                ?? NUEVOS ENEMIGOS EXTREMOS</h3>

            <!-- Toxic Zephyr -->
            <div
                style="background: linear-gradient(135deg, rgba(57, 255, 20, 0.1), rgba(0, 255, 136, 0.1)); border: 2px solid #39ff14; border-radius: 15px; padding: 25px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <div style="font-size: 60px;">??</div>
                    <div style="flex: 1;">
                        <h4 style="color: #39ff14; font-size: 22px; margin-bottom: 8px;">Toxic Zephyr</h4>
                        <p style="font-size: 14px; color: rgba(224, 231, 255, 0.8);">HP: 60 | Speed: 95 | Damage: 15</p>
                    </div>
                </div>
                <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                    <p style="margin: 8px 0; font-size: 14px;"><strong style="color: #39ff14;">? 25% Evasión:</strong>
                        Esquiva ataques y hace dash rápido</p>
                    <p style="margin: 8px 0; font-size: 14px;"><strong style="color: #39ff14;">?? Radiación
                            Constante:</strong> Causa 3 de daño cada 2s si estás cerca</p>
                    <p style="margin: 8px 0; font-size: 14px;"><strong style="color: #39ff14;">?? Toxic Dash:</strong>
                        Dash de 150px dejando burbujas tóxicas</p>
                    <p style="margin: 8px 0; font-size: 14px; color: #ffd700;">?? Drop: 35% Wind Master Ticket</p>
                </div>
            </div>

            <!-- Radioactive Cyclone -->
            <div
                style="background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(57, 255, 20, 0.1)); border: 2px solid #00ff88; border-radius: 15px; padding: 25px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <div style="font-size: 60px;">??</div>
                    <div style="flex: 1;">
                        <h4 style="color: #00ff88; font-size: 22px; margin-bottom: 8px;">Radioactive Cyclone</h4>
                        <p style="font-size: 14px; color: rgba(224, 231, 255, 0.8);">HP: 70 | Speed: 85 | Damage: 18</p>
                    </div>
                </div>
                <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                    <p style="margin: 8px 0; font-size: 14px;"><strong style="color: #00ff88;">?? Pull Effect:</strong>
                        Te jala constantemente hacia íl</p>
                    <p style="margin: 8px 0; font-size: 14px;"><strong style="color: #00ff88;">?? Radiation
                            Pulse:</strong> 3 ondas expansivas + 36 proyectiles + slow 30%</p>
                    <p style="margin: 8px 0; font-size: 14px;"><strong style="color: #00ff88;">?? Infecciín:</strong>
                        Propaga radioactividad a enemigos cercanos</p>
                    <p style="margin: 8px 0; font-size: 14px; color: #ffd700;">?? Drop: 35% Wind Master Ticket</p>
                </div>
            </div>

            <!-- Tempest Lord BOSS -->
            <div
                style="background: linear-gradient(135deg, rgba(0, 255, 170, 0.15), rgba(57, 255, 20, 0.15)); border: 3px solid #00ffaa; border-radius: 15px; padding: 25px; margin-bottom: 20px; box-shadow: 0 0 25px rgba(0, 255, 170, 0.3);">
                <div style="text-align: center; margin-bottom: 15px;">
                    <div
                        style="background: linear-gradient(135deg, #ffd700, #ff8c00); padding: 8px 20px; border-radius: 20px; display: inline-block; margin-bottom: 15px;">
                        <span style="color: #000; font-weight: 900; font-size: 14px;">?? BOSS EXTREMO</span>
                    </div>
                    <div style="font-size: 70px; margin-bottom: 10px;">???</div>
                    <h4 style="color: #00ffaa; font-size: 28px; margin-bottom: 8px;">Tempest Lord</h4>
                    <p style="font-size: 16px; color: rgba(224, 231, 255, 0.9);">HP: 380 | Speed: 60 | Damage: 42</p>
                </div>
                <div style="background: rgba(0, 0, 0, 0.4); border-radius: 10px; padding: 20px;">
                    <p style="margin: 10px 0; font-size: 15px;"><strong style="color: #00ffaa;">??? Wind
                            Barrier:</strong> Refleja 20% del daño recibido</p>
                    <p style="margin: 10px 0; font-size: 15px;"><strong style="color: #00ffaa;">?? Phase Shift:</strong>
                        Teletransporta cada 8 segundos</p>
                    <p style="margin: 10px 0; font-size: 15px;"><strong style="color: #ff0000;">?? Enrage <25%
                                HP:</strong> +50% velocidad, +30% daño, color rojo</p>
                    <p style="margin: 10px 0; font-size: 15px;"><strong style="color: #00ffaa;">?? Summon <50%
                                HP:</strong> Invoca 2 Toxic Zephyrs</p>
                    <p style="margin: 10px 0; font-size: 15px;"><strong style="color: #00ffaa;">??? Tempest
                            Fury:</strong> 4 fases (Pull ? 16 proyectiles ? Summon ? Teleport)</p>
                    <p style="margin: 10px 0; font-size: 15px; color: #ffd700;">?? Drop: 65% Wind Master Ticket</p>
                </div>
            </div>
        </div>

        <!-- New Status Effects -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: var(--accent); font-size: 28px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center;">
                ?? NUEVOS EFECTOS DE ESTADO</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div
                    style="background: linear-gradient(135deg, rgba(57, 255, 20, 0.1), rgba(0, 255, 0, 0.1)); border: 2px solid #39ff14; border-radius: 15px; padding: 20px;">
                    <h4 style="color: #39ff14; margin-bottom: 15px; font-size: 20px;">?? Radioactividad</h4>
                    <p style="margin: 8px 0; font-size: 14px;">í Daño constante: 4 cada 0.5s</p>
                    <p style="margin: 8px 0; font-size: 14px;">í Duración: 7 segundos</p>
                    <p style="margin: 8px 0; font-size: 14px;"><strong style="color: #ff0000;">⚠️ INFECCIÓN:</strong> Se
                        propaga a enemigos cercanos (<80px)< /p>
                            <p style="margin: 8px 0; font-size: 14px;">í Efecto visual: ?? pulsante verde</p>
                </div>
                <div
                    style="background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 200, 100, 0.1)); border: 2px solid #00ff88; border-radius: 15px; padding: 20px;">
                    <h4 style="color: #00ff88; margin-bottom: 15px; font-size: 20px;">?? Envenenamiento</h4>
                    <p style="margin: 8px 0; font-size: 14px;">í Daño constante: 8 cada 0.4s</p>
                    <p style="margin: 8px 0; font-size: 14px;">í Duración: 2 segundos</p>
                    <p style="margin: 8px 0; font-size: 14px;"><strong style="color: #ff0000;">í Reduce defensa:
                            -15%</strong></p>
                    <p style="margin: 8px 0; font-size: 14px;"><strong style="color: #ff0000;">í Reduce velocidad:
                            -60%</strong></p>
                </div>
            </div>
        </div>

        <!-- Class Info Panel -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: var(--accent); font-size: 28px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center;">
                ?? PANEL DE INFORMACIÓN DE CLASES</h3>
            <div
                style="background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(255, 0, 110, 0.1)); border: 2px solid #00d9ff; border-radius: 15px; padding: 25px;">
                <p style="color: var(--light); margin-bottom: 15px; font-size: 16px;">¡Nuevo sistema de vista previa
                    antes de equipar una clase!</p>
                <div style="margin-left: 20px;">
                    <p style="margin: 10px 0;">? <strong>Panel deslizante:</strong> Animación suave desde la derecha</p>
                    <p style="margin: 10px 0;">?? <strong>Información completa:</strong> Descripción, tier, tickets,
                        estado de desbloqueo</p>
                    <p style="margin: 10px 0;">?? <strong>Lista de habilidades:</strong> Cada habilidad con icono,
                        nombre, cooldown y tecla</p>
                    <p style="margin: 10px 0;">? <strong>Ultimate destacado:</strong> Borde dorado y efectos especiales
                    </p>
                    <p style="margin: 10px 0;">?? <strong>Botín de equipar:</strong> Deshabilitado si está bloqueada</p>
                </div>
            </div>
        </div>

        <!-- Mob Info Screen Redesign -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: var(--accent); font-size: 28px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center;">
                ?? PANTALLA DE INFO REDISEÑADA</h3>
            <div
                style="background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), rgba(75, 0, 130, 0.1)); border: 2px solid #8a2be2; border-radius: 15px; padding: 25px;">
                <p style="color: var(--light); margin-bottom: 15px; font-size: 16px;">La pantalla de información de mobs
                    ha sido completamente rediseíada:</p>
                <div style="margin-left: 20px;">
                    <p style="margin: 10px 0;">?? <strong>Organización por clases:</strong> Mobs agrupados por tickets
                        que dropean</p>
                    <p style="margin: 10px 0;">?? <strong>Colores temíticos:</strong> Cada clase tiene su propio esquema
                        de color</p>
                    <p style="margin: 10px 0;">?? <strong>Estadísticas destacadas:</strong> HP, velocidad, daño con
                        fondos de color</p>
                    <p style="margin: 10px 0;">? <strong>Efectos hover:</strong> Las tarjetas se elevan y brillan</p>
                    <p style="margin: 10px 0;">?? <strong>Badges de BOSS:</strong> Indicadores visuales especiales</p>
                    <p style="margin: 10px 0;">?? <strong>Drop rates visibles:</strong> Porcentajes claros para cada
                        enemigo</p>
                </div>
            </div>
        </div>

        <!-- Emergency Nerf -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: #ff9900; font-size: 28px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center;">
                ?? NERF DE EMERGENCIA - WIND MASTER</h3>
            <div
                style="background: linear-gradient(135deg, rgba(255, 153, 0, 0.15), rgba(255, 0, 0, 0.15)); border: 2px solid #ff9900; border-radius: 15px; padding: 25px;">
                <p style="color: var(--light); margin-bottom: 20px; font-size: 16px; text-align: center;">Los enemigos
                    de Wind Master eran demasiado difíciles. Hemos aplicado los siguientes ajustes:</p>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <!-- Toxic Zephyr Nerfs -->
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                        <h4 style="color: #39ff14; margin-bottom: 12px; text-align: center;">?? Toxic Zephyr</h4>
                        <p style="margin: 6px 0; font-size: 13px;">HP: <span style="color: #ff4444;">75 ? 60</span></p>
                        <p style="margin: 6px 0; font-size: 13px;">Velocidad: <span style="color: #ff4444;">110 ?
                                95</span></p>
                        <p style="margin: 6px 0; font-size: 13px;">Daño: <span style="color: #ff4444;">20 ? 15</span>
                        </p>
                        <p style="margin: 6px 0; font-size: 13px;">Cooldown: <span style="color: #ff4444;">2.5s ?
                                3.5s</span></p>
                        <p style="margin: 6px 0; font-size: 13px;">Evasión: <span style="color: #ff4444;">25% ?
                                15%</span></p>
                    </div>

                    <!-- Radioactive Cyclone Nerfs -->
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                        <h4 style="color: #00ff88; margin-bottom: 12px; text-align: center;">?? Radioactive Cyclone</h4>
                        <p style="margin: 6px 0; font-size: 13px;">HP: <span style="color: #ff4444;">85 ? 70</span></p>
                        <p style="margin: 6px 0; font-size: 13px;">Velocidad: <span style="color: #ff4444;">95 ?
                                85</span></p>
                        <p style="margin: 6px 0; font-size: 13px;">Daño: <span style="color: #ff4444;">24 ? 18</span>
                        </p>
                        <p style="margin: 6px 0; font-size: 13px;">Cooldown: <span style="color: #ff4444;">3.5s ?
                                4.5s</span></p>
                    </div>

                    <!-- Tempest Lord Nerfs v2 -->
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                        <h4 style="color: #00ffaa; margin-bottom: 12px; text-align: center;">??? Tempest Lord v2</h4>
                        <p style="margin: 6px 0; font-size: 13px;">HP: <span style="color: #ff4444;">450 ? 380</span>
                        </p>
                        <p style="margin: 6px 0; font-size: 13px;">Velocidad: <span style="color: #ff4444;">65 ?
                                60</span></p>
                        <p style="margin: 6px 0; font-size: 13px;">Daño: <span style="color: #ff4444;">52 ? 42</span>
                        </p>
                        <p style="margin: 6px 0; font-size: 13px;">Cooldown: <span style="color: #ff4444;">3s ?
                                4s</span></p>
                        <p style="margin: 6px 0; font-size: 13px;">Wind Barrier: <span style="color: #ff4444;">30% ?
                                20%</span></p>
                        <p style="margin: 6px 0; font-size: 13px;">Enrage: <span style="color: #ff4444;">30% HP ? 25%
                                HP</span></p>
                    </div>
                </div>

                <div
                    style="background: rgba(0, 255, 0, 0.1); border: 1px solid #00ff00; border-radius: 10px; padding: 15px; text-align: center;">
                    <p style="color: #00ff00; font-weight: bold; margin-bottom: 8px;">? Resultado</p>
                    <p style="font-size: 14px;">Wind Master sigue siendo desafiante pero ahora es más justo y balanceado
                    </p>
                </div>
            </div>
        </div>

        <!-- Balance Patch v3.1 -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: #ff0000; font-size: 28px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center;">
                ?? PARCHE DE BALANCE v3.1</h3>
            <div
                style="background: linear-gradient(135deg, rgba(255, 0, 0, 0.15), rgba(255, 69, 0, 0.15)); border: 2px solid #ff0000; border-radius: 15px; padding: 25px;">

                <!-- Tempest Lord Nerf v3 -->
                <div style="background: rgba(0, 0, 0, 0.4); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                    <h4 style="color: #00ffaa; font-size: 22px; margin-bottom: 15px; text-align: center;">??? Tempest
                        Lord - NERF SEVERO v3</h4>
                    <p style="color: var(--light); margin-bottom: 15px; text-align: center; font-size: 14px;">El boss
                        seguía siendo demasiado difícil. Aplicamos un nerf más agresivo:</p>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div style="background: rgba(255, 0, 0, 0.2); border-radius: 8px; padding: 12px;">
                            <p style="margin: 6px 0; font-size: 13px;">HP: <span style="color: #ff4444;">380 ?
                                    280</span> (-100)</p>
                            <p style="margin: 6px 0; font-size: 13px;">Velocidad: <span style="color: #ff4444;">60 ?
                                    50</span> (-10)</p>
                            <p style="margin: 6px 0; font-size: 13px;">Daño: <span style="color: #ff4444;">42 ?
                                    30</span> (-12)</p>
                        </div>
                        <div style="background: rgba(255, 0, 0, 0.2); border-radius: 8px; padding: 12px;">
                            <p style="margin: 6px 0; font-size: 13px;">Cooldown: <span style="color: #ff4444;">4s ?
                                    6s</span> (+2s)</p>
                            <p style="margin: 6px 0; font-size: 13px;">Rango: <span style="color: #ff4444;">500 ?
                                    480</span> (-20)</p>
                            <p style="margin: 6px 0; font-size: 13px;">Wind Barrier: <span style="color: #ff4444;">20% ?
                                    12%</span></p>
                            <p style="margin: 6px 0; font-size: 13px;">Enrage: <span style="color: #ff4444;">25% ?
                                    15%</span></p>
                        </div>
                    </div>
                </div>

                <!-- Dragonhunter Fix -->
                <div style="background: rgba(0, 0, 0, 0.4); border-radius: 12px; padding: 20px;">
                    <h4 style="color: #ff4500; font-size: 22px; margin-bottom: 15px; text-align: center;">??
                        Dragonhunter - CORRECCIÓN CRÍTICA</h4>
                    <p style="color: var(--light); margin-bottom: 15px; text-align: center; font-size: 14px;">La
                        habilidad "Triple Flecha Flamígera" tenía un bug crítico que ha sido corregido:</p>
                    <div
                        style="background: rgba(255, 0, 0, 0.2); border-radius: 8px; padding: 15px; margin-bottom: 12px;">
                        <p style="color: #ff4444; font-weight: bold; margin-bottom: 8px;">? ANTES (Bug):</p>
                        <p style="margin: 6px 0; font-size: 13px;">í El daño de burn se aplicaba cuando el enemigo usaba
                            su habilidad especial</p>
                        <p style="margin: 6px 0; font-size: 13px;">í Hacía un ligero daño al jugador en lugar del
                            enemigo</p>
                        <p style="margin: 6px 0; font-size: 13px;">í No funcionaba como se esperaba</p>
                    </div>
                    <div style="background: rgba(0, 255, 0, 0.2); border-radius: 8px; padding: 15px;">
                        <p style="color: #00ff00; font-weight: bold; margin-bottom: 8px;">? AHORA (Corregido):</p>
                        <p style="margin: 6px 0; font-size: 13px;">í El enemigo recibe <strong
                                style="color: #ff4500;">35 de daño</strong> cada vez que intenta atacar al jugador</p>
                        <p style="margin: 6px 0; font-size: 13px;">í El daño se aplica <strong>ANTES</strong> de que el
                            enemigo pueda atacar</p>
                        <p style="margin: 6px 0; font-size: 13px;">í Funciona durante los próximos <strong>3 intentos de
                                ataque</strong> del enemigo</p>
                        <p style="margin: 6px 0; font-size: 13px;">í Ya no daña al jugador por error</p>
                    </div>
                </div>

                <div
                    style="background: rgba(0, 255, 255, 0.1); border: 1px solid #00ffff; border-radius: 10px; padding: 15px; text-align: center; margin-top: 20px;">
                    <p style="color: #00ffff; font-weight: bold; margin-bottom: 8px;">?? Resultado del Parche</p>
                    <p style="font-size: 14px;">Tempest Lord ahora es más accesible y Dragonhunter funciona
                        correctamente como se diseíí</p>
                </div>
            </div>
        </div>

        <!-- v3.0 Stats -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: var(--accent); font-size: 28px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center;">
                ?? ESTADÍSTICAS v3.0</h3>
            <div
                style="background: rgba(255, 190, 11, 0.1); border: 2px solid var(--accent); border-radius: 15px; padding: 25px;">
                <div
                    style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; text-align: center;">
                    <div>
                        <p style="font-size: 40px; color: #39ff14;">1</p>
                        <p style="font-size: 13px;">Nueva Clase S-Tier</p>
                    </div>
                    <div>
                        <p style="font-size: 40px; color: #ff0080;">3</p>
                        <p style="font-size: 13px;">Enemigos Extremos</p>
                    </div>
                    <div>
                        <p style="font-size: 40px; color: #9d4edd;">2</p>
                        <p style="font-size: 13px;">Clases Rediseíadas</p>
                    </div>
                    <div>
                        <p style="font-size: 40px; color: #00ff88;">2</p>
                        <p style="font-size: 13px;">Nuevos Efectos</p>
                    </div>
                    <div>
                        <p style="font-size: 40px; color: #00d9ff;">17</p>
                        <p style="font-size: 13px;">Mobs Totales</p>
                    </div>
                    <div>
                        <p style="font-size: 40px; color: #ffd700;">8</p>
                        <p style="font-size: 13px;">Posibilidades</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Balance Patch v3.2.1 -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: #00d9ff; font-size: 28px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center;">
                ?? BALANCE PATCH v3.2.1</h3>
            <div
                style="background: linear-gradient(135deg, rgba(0, 217, 255, 0.15), rgba(57, 255, 20, 0.15)); border: 2px solid #00d9ff; border-radius: 15px; padding: 25px;">

                <p style="color: var(--light); margin-bottom: 20px; font-size: 15px; text-align: center;">Ajustes
                    finales basados en feedback de jugadores completando misiones de maestría</p>

                <!-- Wind Master Final Adjustments -->
                <div style="background: rgba(0, 0, 0, 0.4); border-radius: 12px; padding: 20px;">
                    <h4 style="color: #39ff14; font-size: 20px; margin-bottom: 15px; text-align: center;">?? Wind Master
                        - Ajustes Finales v5</h4>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <!-- Mobs mantienen nerf v4 -->
                        <div
                            style="background: rgba(57, 255, 20, 0.15); border: 1px solid #39ff14; border-radius: 8px; padding: 15px;">
                            <h5 style="color: #39ff14; margin-bottom: 10px; text-align: center;">???? Mobs Regulares
                            </h5>
                            <p style="margin: 6px 0; font-size: 13px; text-align: center; color: #00ff88;">? Sin cambios
                                - Nerf v4 mantiene buen balance</p>
                            <div
                                style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(57, 255, 20, 0.3);">
                                <p style="margin: 4px 0; font-size: 12px;">í Toxic Zephyr: HP 50, Velocidad 85, Daño 12
                                </p>
                                <p style="margin: 4px 0; font-size: 12px;">í Radioactive Cyclone: HP 60, Velocidad 75,
                                    Daño 15</p>
                            </div>
                        </div>

                        <!-- Boss recibe ligero buff -->
                        <div
                            style="background: rgba(0, 255, 170, 0.2); border: 2px solid #00ffaa; border-radius: 8px; padding: 15px;">
                            <h5 style="color: #00ffaa; margin-bottom: 10px; text-align: center;">??? Tempest Lord - BUFF
                                v5</h5>
                            <p style="margin: 6px 0; font-size: 13px; text-align: center; color: #ffd700;">? Ligero buff
                                para mantener desafío Épico</p>
                            <div
                                style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(0, 255, 170, 0.3);">
                                <p style="margin: 4px 0; font-size: 12px;">HP: <span style="color: #00ff88;">250 ?
                                        270</span></p>
                                <p style="margin: 4px 0; font-size: 12px;">Velocidad: <span style="color: #00ff88;">45 ?
                                        48</span></p>
                                <p style="margin: 4px 0; font-size: 12px;">Daño: <span style="color: #00ff88;">25 ?
                                        28</span></p>
                            </div>
                        </div>
                    </div>

                    <div
                        style="background: rgba(0, 217, 255, 0.1); border: 1px solid #00d9ff; border-radius: 8px; padding: 12px; text-align: center;">
                        <p style="color: #00d9ff; font-weight: bold; margin-bottom: 6px;">?? Filosofía del Balance</p>
                        <p style="font-size: 13px;">Los mobs regulares están perfectos para farmear. El boss debe ser un
                            desafío memorable.</p>
                    </div>
                </div>

                <div
                    style="background: rgba(0, 255, 0, 0.1); border: 1px solid #00ff00; border-radius: 10px; padding: 15px; text-align: center; margin-top: 20px;">
                    <p style="color: #00ff00; font-weight: bold; margin-bottom: 8px;">? Resultado del Patch</p>
                    <p style="font-size: 14px;">Misiones de maestría accesibles pero el boss final sigue siendo Épico y
                        desafiante</p>
                </div>
            </div>
        </div>

        <!-- Wind Master Buff v3.2.2 -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: #39ff14; font-size: 28px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center;">
                ?? WIND MASTER BUFF v3.2.2</h3>
            <div
                style="background: linear-gradient(135deg, rgba(57, 255, 20, 0.15), rgba(0, 255, 136, 0.15)); border: 2px solid #39ff14; border-radius: 15px; padding: 25px;">

                <p style="color: var(--light); margin-bottom: 20px; font-size: 15px; text-align: center;">Mejoras
                    significativas a la habilidad Viento Radioactivo para recompensar la precisión</p>

                <!-- Radioactive Wind Buff -->
                <div style="background: rgba(0, 0, 0, 0.4); border-radius: 12px; padding: 20px;">
                    <h4 style="color: #39ff14; font-size: 22px; margin-bottom: 15px; text-align: center;">?? Viento
                        Radioactivo - BUFF MAYOR</h4>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <!-- Cooldown Reduction -->
                        <div
                            style="background: rgba(57, 255, 20, 0.15); border: 1px solid #39ff14; border-radius: 8px; padding: 15px;">
                            <h5 style="color: #39ff14; margin-bottom: 10px; text-align: center;">?? Cooldown Reducido
                            </h5>
                            <p style="margin: 6px 0; font-size: 14px; text-align: center;">
                                <span style="color: #ff4444;">4.5s</span> ? <span style="color: #00ff88;">4.0s</span>
                            </p>
                            <p
                                style="margin-top: 10px; font-size: 12px; color: rgba(224, 231, 255, 0.8); text-align: center;">
                                Más spam, más diversión</p>
                        </div>

                        <!-- New Damage Buff System -->
                        <div
                            style="background: rgba(0, 255, 136, 0.2); border: 2px solid #00ff88; border-radius: 8px; padding: 15px;">
                            <h5 style="color: #00ff88; margin-bottom: 10px; text-align: center;">? NUEVO: Buff de Daño
                            </h5>
                            <p style="margin: 6px 0; font-size: 13px; text-align: center; color: #ffd700;">Recompensa
                                por precisión</p>
                            <div
                                style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(0, 255, 136, 0.3);">
                                <p style="margin: 4px 0; font-size: 12px;">í 100% enemigos: <span
                                        style="color: #00ff88;">+20% daño</span></p>
                                <p style="margin: 4px 0; font-size: 12px;">í 75%+ enemigos: <span
                                        style="color: #00ff88;">+15% daño</span></p>
                                <p style="margin: 4px 0; font-size: 12px;">í 50%+ enemigos: <span
                                        style="color: #00ff88;">+10% daño</span></p>
                                <p style="margin: 4px 0; font-size: 12px;">í 25%+ enemigos: <span
                                        style="color: #00ff88;">+5% daño</span></p>
                            </div>
                        </div>
                    </div>

                    <div
                        style="background: rgba(57, 255, 20, 0.1); border: 1px solid #39ff14; border-radius: 8px; padding: 15px; text-align: center;">
                        <p style="color: #39ff14; font-weight: bold; margin-bottom: 8px;">?? Cómo Funciona</p>
                        <p style="font-size: 13px; line-height: 1.6;">
                            Viento Radioactivo ahora otorga un buff de daño temporal (4s) basado en cuántos enemigos
                            infectas.
                            ¡Posiciónate estratégicamente para maximizar el impacto y obtener el buff completo de +20%!
                        </p>
                    </div>
                </div>

                <!-- New Modal System -->
                <div style="background: rgba(0, 0, 0, 0.4); border-radius: 12px; padding: 20px; margin-top: 20px;">
                    <h4 style="color: #00d9ff; font-size: 20px; margin-bottom: 15px; text-align: center;">?? NUEVO:
                        Modal de Información Mejorado</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div
                            style="background: rgba(0, 217, 255, 0.1); border: 1px solid #00d9ff; border-radius: 8px; padding: 12px;">
                            <p style="margin: 6px 0; font-size: 13px; color: #00d9ff;">?? <strong>Mení Lateral</strong>
                            </p>
                            <p style="margin: 6px 0; font-size: 12px;">Navegación por categorías de clases</p>
                        </div>
                        <div
                            style="background: rgba(0, 217, 255, 0.1); border: 1px solid #00d9ff; border-radius: 8px; padding: 12px;">
                            <p style="margin: 6px 0; font-size: 13px; color: #00d9ff;">?? <strong>Organización</strong>
                            </p>
                            <p style="margin: 6px 0; font-size: 12px;">Mobs y jefes separados por clase</p>
                        </div>
                    </div>
                </div>

                <div
                    style="background: rgba(0, 255, 0, 0.1); border: 1px solid #00ff00; border-radius: 10px; padding: 15px; text-align: center; margin-top: 20px;">
                    <p style="color: #00ff00; font-weight: bold; margin-bottom: 8px;">? Resultado del Buff</p>
                    <p style="font-size: 14px;">Wind Master ahora recompensa el juego estratégico y la precisión con
                        poder devastador</p>
                </div>
            </div>
        </div>

        <!-- MASTERY SYSTEM COMPLETE -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: #ff00ff; font-size: 36px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center; text-shadow: 0 0 25px #ff00ff;">
                🏆 SISTEMA DE MAESTRÍAS COMPLETO</h3>

            <div
                style="background: linear-gradient(135deg, rgba(255, 0, 255, 0.2), rgba(138, 43, 226, 0.2)); border: 3px solid #ff00ff; border-radius: 15px; padding: 30px; margin-bottom: 25px; box-shadow: 0 0 30px rgba(255, 0, 255, 0.4);">
                <div style="text-align: center; margin-bottom: 25px;">
                    <h4 style="color: #ff00ff; font-size: 28px; margin-bottom: 15px;">?? CLASES MAESTRAS DESBLOQUEABLES
                    </h4>
                    <p style="color: var(--light); font-size: 16px; margin-bottom: 20px;">Completa misiones épicas para
                        desbloquear versiones supremas de tus clases favoritas</p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <div
                        style="background: rgba(255, 0, 255, 0.15); border: 2px solid #ff00ff; border-radius: 12px; padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 10px;">??</div>
                        <h5 style="color: #ff4500; font-size: 18px; margin-bottom: 8px;">Dragonhunter Master</h5>
                        <p style="font-size: 13px; color: rgba(224, 231, 255, 0.8);">Maestro supremo del fuego</p>
                    </div>
                    <div
                        style="background: rgba(138, 43, 226, 0.15); border: 2px solid #8a2be2; border-radius: 12px; padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 10px;">??</div>
                        <h5 style="color: #9d4edd; font-size: 18px; margin-bottom: 8px;">Shadow Ninja Master</h5>
                        <p style="font-size: 13px; color: rgba(224, 231, 255, 0.8);">Asesino de las sombras</p>
                    </div>
                    <div
                        style="background: rgba(139, 0, 0, 0.15); border: 2px solid #8b0000; border-radius: 12px; padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 10px;">??</div>
                        <h5 style="color: #ff0000; font-size: 18px; margin-bottom: 8px;">Wild Berserker Master</h5>
                        <p style="font-size: 13px; color: rgba(224, 231, 255, 0.8);">Furia incontrolable</p>
                    </div>
                </div>

                <div style="background: rgba(0, 0, 0, 0.4); border-radius: 12px; padding: 20px;">
                    <h5 style="color: #ffd700; font-size: 20px; margin-bottom: 15px; text-align: center;">?? SISTEMA DE
                        MISIONES</h5>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div
                            style="background: rgba(255, 215, 0, 0.1); border: 1px solid #ffd700; border-radius: 8px; padding: 12px;">
                            <p style="margin: 6px 0; font-size: 13px;">? <strong>Progreso Rastreable:</strong> Sigue tu
                                avance en tiempo real</p>
                        </div>
                        <div
                            style="background: rgba(255, 215, 0, 0.1); border: 1px solid #ffd700; border-radius: 8px; padding: 12px;">
                            <p style="margin: 6px 0; font-size: 13px;">?? <strong>Misiones Variadas:</strong> Kills,
                                waves, daño, supervivencia</p>
                        </div>
                        <div
                            style="background: rgba(255, 215, 0, 0.1); border: 1px solid #ffd700; border-radius: 8px; padding: 12px;">
                            <p style="margin: 6px 0; font-size: 13px;">🎁 <strong>Recompensas Épicas:</strong> Clases
                                maestras con habilidades mejoradas</p>
                        </div>
                        <div
                            style="background: rgba(255, 215, 0, 0.1); border: 1px solid #ffd700; border-radius: 8px; padding: 12px;">
                            <p style="margin: 6px 0; font-size: 13px;">?? <strong>Desbloqueo Permanente:</strong> Una
                                vez completado, siempre disponible</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- GAME STATISTICS -->
        <div style="margin-bottom: 40px;">
            <h3
                style="color: #ffd700; font-size: 32px; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; text-align: center;">
                ?? Wild Destiny - ESTADÍSTICAS COMPLETAS</h3>
            <div
                style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 140, 0, 0.15)); border: 3px solid #ffd700; border-radius: 15px; padding: 30px;">
                <div
                    style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 20px; text-align: center; margin-bottom: 25px;">
                    <div style="background: rgba(0, 0, 0, 0.4); border-radius: 10px; padding: 20px;">
                        <p style="font-size: 48px; color: #00d9ff; margin-bottom: 8px;">3</p>
                        <p style="font-size: 14px; color: rgba(224, 231, 255, 0.9);">Personajes ínicos</p>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.4); border-radius: 10px; padding: 20px;">
                        <p style="font-size: 48px; color: #ff00ff; margin-bottom: 8px;">6</p>
                        <p style="font-size: 14px; color: rgba(224, 231, 255, 0.9);">Clases Jugables</p>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.4); border-radius: 10px; padding: 20px;">
                        <p style="font-size: 48px; color: #ffd700; margin-bottom: 8px;">3</p>
                        <p style="font-size: 14px; color: rgba(224, 231, 255, 0.9);">Clases Maestras</p>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.4); border-radius: 10px; padding: 20px;">
                        <p style="font-size: 48px; color: #ff0080; margin-bottom: 8px;">17</p>
                        <p style="font-size: 14px; color: rgba(224, 231, 255, 0.9);">Enemigos Totales</p>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.4); border-radius: 10px; padding: 20px;">
                        <p style="font-size: 48px; color: #39ff14; margin-bottom: 8px;">54</p>
                        <p style="font-size: 14px; color: rgba(224, 231, 255, 0.9);">Habilidades ínicas</p>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.4); border-radius: 10px; padding: 20px;">
                        <p style="font-size: 48px; color: #ffbe0b; margin-bottom: 8px;">8</p>
                        <p style="font-size: 14px; color: rgba(224, 231, 255, 0.9);">Combinaciones</p>
                    </div>
                </div>

                <div style="background: rgba(0, 0, 0, 0.4); border-radius: 12px; padding: 20px;">
                    <h5 style="color: #ffd700; font-size: 20px; margin-bottom: 15px; text-align: center;">??
                        CARACTERÍSTICAS PRINCIPALES</h5>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        <p style="margin: 6px 0; font-size: 14px;">? Sistema de combate fluido y dinímico</p>
                        <p style="margin: 6px 0; font-size: 14px;">?? Raids personalizables con cualquier combinación
                        </p>
                        <p style="margin: 6px 0; font-size: 14px;">?? Regeneración pasiva del jugador</p>
                        <p style="margin: 6px 0; font-size: 14px;">?? Efectos de estado avanzados (burn, poison,
                            radioactive)</p>
                        <p style="margin: 6px 0; font-size: 14px;">🏆 Sistema de maestrías con misiones épicas</p>
                        <p style="margin: 6px 0; font-size: 14px;">?? Interfaz moderna con animaciones suaves</p>
                        <p style="margin: 6px 0; font-size: 14px;">?? Panel de información completo de clases y mobs</p>
                        <p style="margin: 6px 0; font-size: 14px;">?? Balance perfecto entre desafío y diversión</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Final Message -->
        <div
            style="text-align: center; margin-top: 50px; padding: 40px; background: linear-gradient(135deg, rgba(255, 215, 0, 0.25), rgba(255, 0, 255, 0.25), rgba(0, 217, 255, 0.25)); border-radius: 20px; border: 3px solid #ffd700; box-shadow: 0 0 40px rgba(255, 215, 0, 0.5);">
            <p style="font-size: 48px; margin-bottom: 15px;">?????</p>
            <p
                style="font-size: 32px; font-weight: bold; background: linear-gradient(90deg, #ffd700, #ff00ff, #00d9ff); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 15px; text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);">
                ¡Wild Destiny!</p>
            <p style="font-size: 18px; color: var(--light); margin-bottom: 10px;">La experiencia definitiva de combate
                está aquí</p>
            <p style="font-size: 15px; color: rgba(224, 231, 255, 0.9); margin-top: 20px;">⚔️ 3 Personajes • 6 Clases •
                3 Maestrías • 17 Enemigos • 54 Habilidades ⚔️</p>
            <p style="font-size: 14px; color: rgba(224, 231, 255, 0.8); margin-top: 15px;">Todas las clases son
                creaciones originales í Sin infracción de derechos de autor</p>
            <p style="font-size: 13px; color: rgba(224, 231, 255, 0.7); margin-top: 10px;">v20.11.2025 - Complete
                Edition í El juego definitivo</p>
        </div>

    </div>
    </div>
    </div>
    </div>

    <!-- Custom Raid Modal -->
    <div id="custom-raid-modal" class="modal hidden">
        <div class="modal-content" style="max-width: 1000px;">
            <div class="modal-header">
                <h2>?? CUSTOM RAID</h2>
                <button class="close-button" id="close-custom-raid">í</button>
            </div>
            <div class="modal-body" style="padding: 30px;">

                <div
                    style="background: rgba(255, 190, 11, 0.1); border: 2px solid var(--accent); border-radius: 10px; padding: 20px; margin-bottom: 25px;">
                    <p style="font-size: 16px; color: var(--accent); font-weight: bold; margin-bottom: 10px;">??
                        ADVERTENCIA</p>
                    <p style="font-size: 14px; color: var(--light);">Las raids personalizadas tienen un <strong
                            style="color: #ff006e;">-5% de probabilidad</strong> de drop de tickets.</p>
                    <p style="font-size: 13px; color: rgba(224, 231, 255, 0.7); margin-top: 8px;">Mobs regulares: 35% ?
                        30% | Jefes: 65% ? 60%</p>
                </div>

                <h3
                    style="color: var(--primary); font-size: 20px; margin-bottom: 15px; font-family: 'Orbitron', sans-serif;">
                    Selecciona Mobs Regulares</h3>
                <div id="custom-mobs-grid"
                    style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px;">
                    <!-- Mobs will be populated here -->
                </div>

                <h3
                    style="color: var(--secondary); font-size: 20px; margin-bottom: 15px; font-family: 'Orbitron', sans-serif;">
                    Selecciona Jefes</h3>
                <div id="custom-bosses-grid"
                    style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px;">
                    <!-- Bosses will be populated here -->
                </div>

                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button id="start-custom-raid-btn" class="header-btn"
                        style="padding: 15px 40px; font-size: 16px; background: linear-gradient(135deg, #8a2be2, #4b0082); border-color: #8a2be2;">
                        ?? Iniciar Raid Personalizada
                    </button>
                    <button id="cancel-custom-raid-btn" class="header-btn" style="padding: 15px 40px; font-size: 16px;">
                        ? Cancelar
                    </button>
                </div>

            </div>
        </div>
    </div>

    <!-- Loadout Modal - REDESIGNED STRUCTURE -->
    <div id="loadout-modal" class="modal hidden">
        <div class="modal-content"
            style="width: 95%; max-width: 1600px; height: 90vh; max-height: 90vh; display: flex; flex-direction: column; padding: 0; overflow: hidden; background: linear-gradient(135deg, rgba(5, 8, 20, 0.98), rgba(10, 14, 39, 0.98)); border: 2px solid var(--primary); box-shadow: 0 0 50px rgba(0, 217, 255, 0.2);">

            <!-- Top Navigation Bar -->
            <div
                style="padding: 0; display: flex; align-items: stretch; border-bottom: 2px solid rgba(0, 217, 255, 0.3); background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(10px); z-index: 10;">

                <!-- Logo area -->
                <div
                    style="padding: 0 30px; display: flex; align-items: center; border-right: 2px solid rgba(0, 217, 255, 0.2); background: rgba(0, 0, 0, 0.5);">
                    <div style="font-size: 24px; margin-right: 15px;">⚔️</div>
                    <h2
                        style="font-family: 'Orbitron', sans-serif; font-size: 20px; font-weight: 800; color: #00d9ff; text-transform: uppercase; letter-spacing: 2px; margin: 0; text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);">
                        LOADOUT
                    </h2>
                </div>

                <!-- Tabs Area -->
                <div style="display: flex; gap: 0; overflow-x: auto; padding: 0; flex: 1; justify-content: flex-start;">
                    <div class="loadout-nav-item active" data-tab="equipped"
                        style="padding: 0 30px; display: flex; align-items: center; gap: 12px; cursor: pointer; transition: all 0.3s; border-right: 1px solid rgba(0, 217, 255, 0.1); position: relative; height: 80px;">
                        <div id="loadout-nav-icon-equipped" class="nav-icon-container"
                            style="filter: drop-shadow(0 0 5px rgba(0, 217, 255, 0.8));">
                            <!-- Icon injected via JS -->
                        </div>
                        <div
                            style="font-size: 14px; font-weight: 700; color: #00d9ff; text-transform: uppercase; letter-spacing: 1px;">
                            EQUIPADO</div>
                        <div class="tab-indicator"
                            style="position: absolute; bottom: 0; left: 0; width: 100%; height: 4px; background: #00d9ff; box-shadow: 0 0 15px #00d9ff;">
                        </div>
                    </div>

                    <div class="loadout-nav-item" data-tab="characters"
                        style="padding: 0 30px; display: flex; align-items: center; gap: 12px; cursor: pointer; transition: all 0.3s; border-right: 1px solid rgba(0, 217, 255, 0.1); opacity: 0.6; height: 80px;">
                        <div id="loadout-nav-icon-characters" class="nav-icon-container">
                            <!-- Icon injected via JS -->
                        </div>
                        <div
                            style="font-size: 14px; font-weight: 700; color: white; text-transform: uppercase; letter-spacing: 1px;">
                            PERSONAJES</div>
                        <div class="tab-indicator"
                            style="position: absolute; bottom: 0; left: 0; width: 100%; height: 4px; background: #00d9ff; opacity: 0;">
                        </div>
                    </div>

                    <div class="loadout-nav-item" data-tab="classes"
                        style="padding: 0 30px; display: flex; align-items: center; gap: 12px; cursor: pointer; transition: all 0.3s; border-right: 1px solid rgba(0, 217, 255, 0.1); opacity: 0.6; height: 80px;">
                        <div id="loadout-nav-icon-classes" class="nav-icon-container">
                            <!-- Icon injected via JS -->
                        </div>
                        <div
                            style="font-size: 14px; font-weight: 700; color: white; text-transform: uppercase; letter-spacing: 1px;">
                            CLASES</div>
                        <div class="tab-indicator"
                            style="position: absolute; bottom: 0; left: 0; width: 100%; height: 4px; background: #00d9ff; opacity: 0;">
                        </div>
                    </div>

                    <div class="loadout-nav-item" data-tab="fruits"
                        style="padding: 0 30px; display: flex; align-items: center; gap: 12px; cursor: pointer; transition: all 0.3s; border-right: 1px solid rgba(0, 217, 255, 0.1); opacity: 0.6; height: 80px;">
                        <div id="loadout-nav-icon-fruits" class="nav-icon-container">
                            <!-- Icon injected via JS -->
                        </div>
                        <div
                            style="font-size: 14px; font-weight: 700; color: white; text-transform: uppercase; letter-spacing: 1px;">
                            FRUTAS</div>
                        <div class="tab-indicator"
                            style="position: absolute; bottom: 0; left: 0; width: 100%; height: 4px; background: #00d9ff; opacity: 0;">
                        </div>
                    </div>

                    <div class="loadout-nav-item" data-tab="masteries"
                        style="padding: 0 30px; display: flex; align-items: center; gap: 12px; cursor: pointer; transition: all 0.3s; border-right: 1px solid rgba(0, 217, 255, 0.1); opacity: 0.6; height: 80px;">
                        <div id="loadout-nav-icon-masteries" class="nav-icon-container">
                            <!-- Icon injected via JS -->
                        </div>
                        <div
                            style="font-size: 14px; font-weight: 700; color: white; text-transform: uppercase; letter-spacing: 1px;">
                            MAESTR&Iacute;AS</div>
                        <div class="tab-indicator"
                            style="position: absolute; bottom: 0; left: 0; width: 100%; height: 4px; background: #00d9ff; opacity: 0;">
                        </div>
                    </div>
                </div>

                <!-- Close Button Container -->
                <div style="padding: 0 30px; display: flex; align-items: center;">
                    <button id="close-loadout"
                        style="width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; background: rgba(255, 0, 110, 0.2); border: 2px solid #ff006e; border-radius: 50%; color: #ff006e; font-weight: 900; cursor: pointer; font-size: 20px; transition: all 0.3s; box-shadow: 0 0 15px rgba(255, 0, 110, 0.3);">
                        &times;
                    </button>
                </div>
            </div>

            <!-- Main Content Area -->
            <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative;">
                <!-- Decorative Background Element -->
                <div
                    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; opacity: 0.05; background-image: radial-gradient(circle at 50% 50%, var(--primary) 1px, transparent 1px); background-size: 30px 30px;">
                </div>

                <!-- Content Header (Dynamic) -->
                <div
                    style="padding: 20px 40px; display: flex; justify-content: space-between; align-items: flex-end; border-bottom: 1px solid rgba(255, 255, 255, 0.05); z-index: 1;">
                    <div>
                        <h3 id="loadout-content-title"
                            style="font-family: 'Orbitron', sans-serif; font-size: 32px; font-weight: 900; color: white; margin-bottom: 5px; text-shadow: 0 0 20px rgba(0, 217, 255, 0.5);">
                            EQUIPADO</h3>
                        <p id="loadout-content-subtitle"
                            style="font-size: 14px; color: rgba(224, 231, 255, 0.6); letter-spacing: 1px;">
                            Gestiona tu equipamiento actual y habilidades
                        </p>
                    </div>
                    <!-- Optional Stats/currency display could go here -->
                </div>

                <!-- Scrollable Content -->
                <div class="modal-body" id="loadout-content"
                    style="flex: 1; overflow-y: auto; padding: 30px 40px; position: relative; z-index: 1;">
                    <!-- Content will be dynamically loaded here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Screen -->
    <!-- Loading Screen (Redesigned) -->
    <div id="loading-screen">
        <div class="loader-content-new">
            <div class="loader-title-new">Wild Destiny</div>
            <div class="loader-subtitle-new">Core Edition</div>
        </div>

        <div class="loading-bar-container">
            <div class="loading-bar">
                <div class="loading-progress"></div>
            </div>
            <div class="loading-percentage">0%</div>
            <div class="loading-status">Preparando entorno...</div>
        </div>
    </div>

    <script>
        // ===== PARTICLES BACKGROUND =====
        const particleCanvas = document.getElementById('particles-bg');
        const particleCtx = particleCanvas.getContext('2d');
        particleCanvas.width = window.innerWidth;
        particleCanvas.height = window.innerHeight;

        const particles = [];
        for (let i = 0; i < 100; i++) {
            particles.push({
                x: Math.random() * particleCanvas.width,
                y: Math.random() * particleCanvas.height,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                size: Math.random() * 2 + 1
            });
        }

        function animateParticles() {
            particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            particleCtx.fillStyle = 'rgba(0, 217, 255, 0.5)';

            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;

                if (p.x < 0 || p.x > particleCanvas.width) p.vx *= -1;
                if (p.y < 0 || p.y > particleCanvas.height) p.vy *= -1;

                particleCtx.beginPath();
                particleCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                particleCtx.fill();
            });

            requestAnimationFrame(animateParticles);
        }
        animateParticles();

        // ===== ASSET LOADER =====
        const AssetLoader = {
            images: new Map(),
            totalAssets: 0,
            loadedAssets: 0,

            loadImage(path) {
                return new Promise((resolve) => {
                    if (this.images.has(path)) {
                        resolve(this.images.get(path));
                        return;
                    }

                    const img = new Image();
                    img.onload = () => {
                        this.images.set(path, img);
                        this.loadedAssets++;
                        this.updateLoadingProgress();
                        resolve(img);
                    };
                    img.onerror = () => {
                        // Try with .jpeg if .jpg failed
                        if (path.endsWith('.jpg')) {
                            const jpegPath = path.replace(/\.jpg$/i, '.jpeg');
                            const jpegImg = new Image();
                            jpegImg.onload = () => {
                                this.images.set(path, jpegImg); // Cache with original path
                                this.images.set(jpegPath, jpegImg); // Also cache with .jpeg path
                                this.loadedAssets++;
                                this.updateLoadingProgress();
                                resolve(jpegImg);
                            };
                            jpegImg.onerror = () => {
                                const placeholder = this.createPlaceholder(path);
                                this.images.set(path, placeholder);
                                this.loadedAssets++;
                                this.updateLoadingProgress();
                                resolve(placeholder);
                            };
                            jpegImg.src = jpegPath;
                        } else {
                            const placeholder = this.createPlaceholder(path);
                            this.images.set(path, placeholder);
                            this.loadedAssets++;
                            this.updateLoadingProgress();
                            resolve(placeholder);
                        }
                    };
                    img.src = path;
                });
            },

            async preloadAssets(paths) {
                this.totalAssets = paths.length;
                this.loadedAssets = 0;
                await Promise.all(paths.map(path => this.loadImage(path)));
            },

            getImage(path) {
                return this.images.get(path) || null;
            },

            updateLoadingProgress() {
                if (this.totalAssets === 0) return;
                const progress = (this.loadedAssets / this.totalAssets) * 100;
                const progressBar = document.querySelector('.loading-progress');
                if (progressBar) progressBar.style.width = `${progress}%`;
            },

            createPlaceholder(path) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                const name = path.split('/').pop().split('.')[0];

                const gradient = ctx.createLinearGradient(0, 0, 64, 64);
                gradient.addColorStop(0, '#00d9ff');
                gradient.addColorStop(1, '#ff006e');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 64, 64);

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(2, 2, 60, 60);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('MISSING', 32, 28);
                ctx.fillText(name.substring(0, 8), 32, 40);

                return canvas;
            }
        };

        // ===== ABILITY SFX MANAGER (Procedural / No external assets) =====
        const SfxManager = {
            enabled: true,
            audioCtx: null,
            masterGain: null,
            lastAbilityPlayAt: {},
            abilityRepeatBlockMs: 120,

            ensureContext() {
                if (!this.enabled) return null;
                if (!this.audioCtx) {
                    const Ctx = window.AudioContext || window.webkitAudioContext;
                    if (!Ctx) return null;
                    this.audioCtx = new Ctx();
                    this.masterGain = this.audioCtx.createGain();
                    this.masterGain.gain.value = 0.11;
                    this.masterGain.connect(this.audioCtx.destination);
                }
                if (this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume().catch(() => { });
                }
                return this.audioCtx;
            },

            unlock() {
                this.ensureContext();
            },

            playTone(freq, duration, type, volume, when, detune = 0) {
                const ctx = this.ensureContext();
                if (!ctx || !this.masterGain) return;

                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = type || 'sine';
                osc.frequency.value = Math.max(40, freq || 220);
                osc.detune.value = detune;

                const start = Math.max(ctx.currentTime + 0.002, when || (ctx.currentTime + 0.002));
                const end = start + Math.max(0.03, duration || 0.08);
                const peak = Math.max(0.01, Math.min(0.25, volume || 0.06));

                gain.gain.setValueAtTime(0.0001, start);
                gain.gain.linearRampToValueAtTime(peak, start + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.0001, end);

                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(start);
                osc.stop(end + 0.02);
            },

            playPreset(preset) {
                const ctx = this.ensureContext();
                if (!ctx || !preset || !preset.steps) return;
                const base = ctx.currentTime + 0.005;
                preset.steps.forEach(step => {
                    this.playTone(
                        step.f,
                        step.d,
                        step.t || preset.type || 'sine',
                        step.v || preset.volume || 0.06,
                        base + (step.at || 0),
                        step.detune || 0
                    );
                });
            },

            playAbility(abilityId) {
                if (!abilityId) return;
                const id = String(abilityId).toLowerCase();
                const now = performance.now ? performance.now() : Date.now();
                const lastPlay = this.lastAbilityPlayAt[id] || 0;
                if (now - lastPlay < this.abilityRepeatBlockMs) return;
                this.lastAbilityPlayAt[id] = now;
                const preset = this.abilityPresets[id]
                    || (id.includes('anubis') ? this.abilityPresets.__anubis
                        : id.includes('guardian') || id.includes('taurha') ? this.abilityPresets.__taurha
                            : id.includes('berserker') ? this.abilityPresets.__berserker
                                : this.abilityPresets.__default);
                this.playPreset(preset);
            },

            abilityPresets: {
                __default: { type: 'triangle', volume: 0.05, steps: [{ f: 360, d: 0.08, at: 0 }, { f: 440, d: 0.06, at: 0.05 }] },
                __berserker: { type: 'sawtooth', volume: 0.07, steps: [{ f: 120, d: 0.1, at: 0 }, { f: 90, d: 0.12, at: 0.04 }, { f: 180, d: 0.08, at: 0.12 }] },
                __anubis: { type: 'triangle', volume: 0.06, steps: [{ f: 420, d: 0.08, at: 0 }, { f: 560, d: 0.09, at: 0.06 }, { f: 320, d: 0.1, at: 0.14 }] },
                __taurha: { type: 'square', volume: 0.065, steps: [{ f: 140, d: 0.1, at: 0 }, { f: 110, d: 0.1, at: 0.08 }, { f: 180, d: 0.12, at: 0.16 }] },

                berserker_rage: { type: 'sawtooth', volume: 0.085, steps: [{ f: 150, d: 0.1, at: 0 }, { f: 180, d: 0.1, at: 0.06 }, { f: 230, d: 0.12, at: 0.12 }] },
                berserker_whirlwind: { type: 'square', volume: 0.07, steps: [{ f: 210, d: 0.08, at: 0 }, { f: 240, d: 0.08, at: 0.04 }, { f: 280, d: 0.08, at: 0.08 }, { f: 320, d: 0.08, at: 0.12 }] },
                berserker_axes: { type: 'square', volume: 0.085, steps: [{ f: 95, d: 0.14, at: 0 }, { f: 80, d: 0.16, at: 0.07 }, { f: 130, d: 0.12, at: 0.18 }] },
                berserker_bloodlust: { type: 'triangle', volume: 0.07, steps: [{ f: 260, d: 0.08, at: 0 }, { f: 220, d: 0.08, at: 0.04 }, { f: 180, d: 0.1, at: 0.1 }] },
                berserker_transform: { type: 'sawtooth', volume: 0.08, steps: [{ f: 130, d: 0.14, at: 0 }, { f: 170, d: 0.12, at: 0.08 }, { f: 240, d: 0.15, at: 0.16 }] },
                berserker_ultimate: { type: 'square', volume: 0.09, steps: [{ f: 88, d: 0.18, at: 0 }, { f: 110, d: 0.16, at: 0.1 }, { f: 146, d: 0.16, at: 0.2 }, { f: 196, d: 0.22, at: 0.3 }] },

                anubis_judgment: { type: 'triangle', volume: 0.07, steps: [{ f: 460, d: 0.08, at: 0 }, { f: 620, d: 0.08, at: 0.05 }, { f: 520, d: 0.1, at: 0.12 }] },
                anubis_sandstorm: { type: 'triangle', volume: 0.065, steps: [{ f: 300, d: 0.08, at: 0 }, { f: 380, d: 0.1, at: 0.06 }, { f: 260, d: 0.1, at: 0.14 }] },
                anubis_jackal: { type: 'sawtooth', volume: 0.06, steps: [{ f: 520, d: 0.06, at: 0 }, { f: 640, d: 0.06, at: 0.05 }, { f: 720, d: 0.07, at: 0.1 }] },
                anubis_ankh: { type: 'sine', volume: 0.06, steps: [{ f: 440, d: 0.1, at: 0 }, { f: 550, d: 0.12, at: 0.07 }, { f: 660, d: 0.14, at: 0.15 }] },
                anubis_plague: { type: 'square', volume: 0.065, steps: [{ f: 220, d: 0.1, at: 0 }, { f: 250, d: 0.1, at: 0.07 }, { f: 200, d: 0.12, at: 0.15 }] },
                anubis_underworld: { type: 'triangle', volume: 0.08, steps: [{ f: 180, d: 0.12, at: 0 }, { f: 260, d: 0.12, at: 0.08 }, { f: 340, d: 0.16, at: 0.18 }] },

                guardian_glyph: { type: 'square', volume: 0.065, steps: [{ f: 170, d: 0.08, at: 0 }, { f: 210, d: 0.08, at: 0.06 }, { f: 260, d: 0.1, at: 0.12 }] },
                guardian_hurl: { type: 'square', volume: 0.07, steps: [{ f: 145, d: 0.12, at: 0 }, { f: 120, d: 0.1, at: 0.08 }, { f: 180, d: 0.1, at: 0.16 }] },
                guardian_tablets: { type: 'triangle', volume: 0.06, steps: [{ f: 260, d: 0.08, at: 0 }, { f: 220, d: 0.08, at: 0.06 }, { f: 180, d: 0.1, at: 0.12 }] },
                guardian_burrow: { type: 'sine', volume: 0.06, steps: [{ f: 120, d: 0.12, at: 0 }, { f: 160, d: 0.1, at: 0.09 }] },
                guardian_construct: { type: 'square', volume: 0.075, steps: [{ f: 110, d: 0.14, at: 0 }, { f: 160, d: 0.12, at: 0.12 }] },
                guardian_worldbreaker: { type: 'square', volume: 0.085, steps: [{ f: 85, d: 0.16, at: 0 }, { f: 120, d: 0.15, at: 0.12 }, { f: 170, d: 0.18, at: 0.25 }] }
            }
        };

        window.addEventListener('pointerdown', () => SfxManager.unlock(), { once: true });
        window.addEventListener('keydown', () => SfxManager.unlock(), { once: true });

        // Helper function to normalize ability names for image paths
        function normalizeImageName(name) {
            return name
                .toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove diacritics (tildes, accents, etc.)
                .replace(/[^a-z0-9]/g, ''); // Remove all non-alphanumeric characters (spaces, :, -, etc.)
        }

        // Helper function to get image path with fallback for .jpg/.jpeg
        function getImagePath(basePath) {
            // Si ya tiene extensión, devolverla tal cual
            if (basePath && (basePath.endsWith('.jpg') || basePath.endsWith('.jpeg') || basePath.endsWith('.png'))) {
                return basePath;
            }
            // Si no tiene extensión, intentar con .jpg primero (más común)
            return basePath + '.jpg';
        }

        // Helper function to create image element with fallback
        function createImageWithFallback(basePath, alt, onErrorCallback) {
            const img = new Image();
            let attempts = 0;
            const extensions = ['.jpg', '.jpeg', '.png'];

            function tryLoad(index) {
                if (index >= extensions.length) {
                    if (onErrorCallback) onErrorCallback();
                    return;
                }

                const pathWithoutExt = basePath.replace(/\.(jpg|jpeg|png)$/i, '');
                img.src = pathWithoutExt + extensions[index];

                img.onerror = () => {
                    tryLoad(index + 1);
                };
            }

            img.alt = alt;
            tryLoad(0);
            return img;
        }

        // ===== ICON RENDERER SYSTEM - 2D Graphics drawn with code =====
        const IconRenderer = {
            // Cache for rendered icons
            cache: {},

            // Create a canvas icon and return as data URL
            createIcon(iconId, size = 48) {
                const cacheKey = `${iconId}_${size}`;
                if (this.cache[cacheKey]) return this.cache[cacheKey];

                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');

                const renderer = this.resolveIcon(iconId);
                if (renderer) {
                    renderer(ctx, size);
                } else {
                    this.drawDefault(ctx, size, iconId);
                }

                const dataUrl = canvas.toDataURL();
                this.cache[cacheKey] = dataUrl;
                return dataUrl;
            },

            // Render icon to existing canvas context
            renderTo(ctx, iconId, x, y, size = 48) {
                ctx.save();
                ctx.translate(x, y);
                const renderer = this.resolveIcon(iconId);
                if (renderer) {
                    renderer(ctx, size);
                } else {
                    this.drawDefault(ctx, size, iconId);
                }
                ctx.restore();
            },

            // Resolve icon renderer by ID or keywords
            resolveIcon(iconId) {
                if (this.icons[iconId]) return this.icons[iconId];

                const id = iconId.toLowerCase();

                // === ANUBIS TOMB MOBS & BOSSES ===
                if (id === 'anubis_jackal' || id.includes('jackal')) {
                    return (ctx, s) => {
                        const c = s / 2;
                        // Head silhouette
                        ctx.fillStyle = '#FFD700'; // Gold
                        ctx.beginPath();
                        ctx.moveTo(c, c - s * 0.3); // Top ear center
                        ctx.lineTo(c + s * 0.15, c - s * 0.4); // Right ear tip
                        ctx.lineTo(c + s * 0.1, c - s * 0.15); // Right ear base
                        ctx.lineTo(c + s * 0.2, c + s * 0.1); // Snout right
                        ctx.lineTo(c, c + s * 0.25); // Nose
                        ctx.lineTo(c - s * 0.2, c + s * 0.1); // Snout left
                        ctx.lineTo(c - s * 0.1, c - s * 0.15); // Left ear base
                        ctx.lineTo(c - s * 0.15, c - s * 0.4); // Left ear tip
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = '#DAA520';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        // Collar
                        ctx.fillStyle = '#4169E1'; // Royal Blue
                        ctx.beginPath();
                        ctx.ellipse(c, c + s * 0.25, s * 0.15, s * 0.08, 0, 0, Math.PI * 2);
                        ctx.fill();
                    };
                }
                if (id === 'anubis_mummy' || (id.includes('mummy') && id.includes('anubis'))) {
                    return (ctx, s) => {
                        const c = s / 2;
                        ctx.fillStyle = '#F5DEB3'; // Wheat/Bone
                        ctx.beginPath();
                        ctx.arc(c, c, s * 0.35, 0, Math.PI * 2);
                        ctx.fill();
                        // Bandages
                        ctx.strokeStyle = '#D2B48C'; // Tan
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.3, c - s * 0.1);
                        ctx.lineTo(c + s * 0.3, c + s * 0.1);
                        ctx.moveTo(c - s * 0.3, c + s * 0.1);
                        ctx.lineTo(c + s * 0.3, c - s * 0.1);
                        ctx.moveTo(c - s * 0.2, c - s * 0.25);
                        ctx.lineTo(c + s * 0.2, c - s * 0.25);
                        ctx.stroke();
                        // Glowing eyes
                        ctx.fillStyle = '#39FF14'; // Neon Green
                        ctx.beginPath();
                        ctx.arc(c - s * 0.1, c - s * 0.05, s * 0.04, 0, Math.PI * 2);
                        ctx.arc(c + s * 0.1, c - s * 0.05, s * 0.04, 0, Math.PI * 2);
                        ctx.fill();
                    };
                }
                if (id === 'anubis_sphinx' || (id.includes('sphinx') && id.includes('anubis'))) {
                    return (ctx, s) => {
                        const c = s / 2;
                        // Body
                        ctx.fillStyle = '#CD853F'; // Peru
                        ctx.beginPath();
                        ctx.ellipse(c, c + s * 0.1, s * 0.3, s * 0.2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Head
                        ctx.beginPath();
                        ctx.arc(c - s * 0.15, c - s * 0.15, s * 0.15, 0, Math.PI * 2);
                        ctx.fill();
                        // Nemes (Headdress)
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.25, c - s * 0.25);
                        ctx.lineTo(c - s * 0.05, c - s * 0.25);
                        ctx.lineTo(c - s * 0.05, c + s * 0.05);
                        ctx.lineTo(c - s * 0.25, c + s * 0.05);
                        ctx.fill();
                        ctx.strokeStyle = '#0000CD'; // Medium Blue lines
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(c - s * 0.25, c - s * 0.2 + i * 10);
                            ctx.lineTo(c - s * 0.05, c - s * 0.2 + i * 10);
                            ctx.stroke();
                        }
                    };
                }
                if (id === 'anubis_pharaoh' || (id.includes('pharaoh') && id.includes('anubis'))) {
                    return (ctx, s) => {
                        const c = s / 2;
                        // Sarcophagus shape
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.2, c - s * 0.35);
                        ctx.lineTo(c + s * 0.2, c - s * 0.35);
                        ctx.lineTo(c + s * 0.25, c - s * 0.1);
                        ctx.lineTo(c + s * 0.2, c + s * 0.35);
                        ctx.lineTo(c - s * 0.2, c + s * 0.35);
                        ctx.lineTo(c - s * 0.25, c - s * 0.1);
                        ctx.closePath();
                        ctx.fill();
                        // Nemes Stripes
                        ctx.strokeStyle = '#00008B'; // Dark Blue
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.2, c - s * 0.3);
                        ctx.lineTo(c + s * 0.2, c - s * 0.3);
                        ctx.moveTo(c - s * 0.23, c - s * 0.2);
                        ctx.lineTo(c + s * 0.23, c - s * 0.2);
                        ctx.stroke();
                        // Crook and Flail (Crossed)
                        ctx.strokeStyle = '#DAA520';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.15, c + s * 0.1);
                        ctx.lineTo(c + s * 0.15, c - s * 0.1);
                        ctx.moveTo(c + s * 0.15, c + s * 0.1);
                        ctx.lineTo(c - s * 0.15, c - s * 0.1);
                        ctx.stroke();
                    };
                }
                if (id === 'anubis_colossus' || (id.includes('colossus') && id.includes('anubis'))) {
                    return (ctx, s) => {
                        const c = s / 2;
                        // Stone texture base
                        ctx.fillStyle = '#8B8B83'; // Heavy Stone
                        ctx.fillRect(c - s * 0.25, c - s * 0.35, s * 0.5, s * 0.7);
                        // Cracks
                        ctx.strokeStyle = '#2F4F4F';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.1, c - s * 0.2);
                        ctx.lineTo(c + s * 0.1, c);
                        ctx.lineTo(c, c + s * 0.2);
                        ctx.stroke();
                        // Glowing core
                        ctx.fillStyle = '#00FFFF'; // Cyan energy
                        ctx.shadowColor = '#00FFFF';
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.arc(c, c - s * 0.15, s * 0.08, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    };
                }
                if (id === 'anubis_avatar' || (id.includes('avatar') && id.includes('anubis'))) {
                    return (ctx, s) => {
                        const c = s / 2;
                        // Ankh shape
                        ctx.strokeStyle = '#00CED1'; // Dark Turquoise
                        ctx.lineWidth = s * 0.1;
                        ctx.shadowColor = '#00CED1';
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        // Loop
                        ctx.ellipse(c, c - s * 0.15, s * 0.15, s * 0.2, 0, 0, Math.PI * 2);
                        ctx.stroke();
                        // Crossbar
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.25, c + s * 0.05);
                        ctx.lineTo(c + s * 0.25, c + s * 0.05);
                        ctx.stroke();
                        // Stem
                        ctx.beginPath();
                        ctx.moveTo(c, c + s * 0.05);
                        ctx.lineTo(c, c + s * 0.4);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    };
                }

                // === GUARDIAN ANCESTRAL HARDCODED FIX ===
                // This ensures icons ALWAYS render even if injection/cache fails
                if (id === 'guardian_glyph' || (id.includes('glyph') && id.includes('guardian'))) {
                    return (ctx, s) => {
                        const c = s / 2;
                        ctx.strokeStyle = '#FFD700';
                        ctx.lineWidth = s * 0.06;
                        ctx.shadowColor = '#DAA520';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        const r = s * 0.35;
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI * 2 / 6) * i;
                            const x = c + Math.cos(angle) * r;
                            const y = c + Math.sin(angle) * r;
                            const x2 = c + Math.cos(angle + Math.PI * 2 / 3) * r;
                            const y2 = c + Math.sin(angle + Math.PI * 2 / 3) * r;
                            ctx.moveTo(x, y);
                            ctx.lineTo(x2, y2);
                        }
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(c, c, r * 1.2, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    };
                }
                if (id === 'guardian_hurl' || (id.includes('hurl') && id.includes('guardian'))) {
                    return (ctx, s) => {
                        const c = s / 2;
                        ctx.save();
                        ctx.translate(c, c);
                        ctx.rotate(Math.PI / 4);
                        ctx.fillStyle = '#8B4513';
                        ctx.shadowColor = '#000';
                        ctx.shadowBlur = 5;
                        ctx.beginPath();
                        ctx.moveTo(-s * 0.15, -s * 0.2);
                        ctx.lineTo(s * 0.15, -s * 0.15);
                        ctx.lineTo(s * 0.2, s * 0.2);
                        ctx.lineTo(-s * 0.2, s * 0.15);
                        ctx.closePath();
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.strokeStyle = '#DAA520';
                        ctx.lineWidth = s * 0.04;
                        ctx.stroke();
                        ctx.fillStyle = 'rgba(255,255,255,0.2)';
                        ctx.beginPath();
                        ctx.moveTo(-s * 0.2, s * 0.15);
                        ctx.lineTo(-s * 0.4, s * 0.4);
                        ctx.lineTo(-s * 0.1, s * 0.25);
                        ctx.fill();
                        ctx.restore();
                    };
                }
                if (id === 'guardian_tablets' || (id.includes('tablets') && id.includes('guardian'))) {
                    return (ctx, s) => {
                        const c = s / 2;
                        ctx.shadowColor = '#F4A460';
                        ctx.shadowBlur = 8;
                        for (let i = 0; i < 3; i++) {
                            ctx.save();
                            ctx.translate(c, c);
                            ctx.rotate((Math.PI * 2 / 3) * i - Math.PI / 6);
                            ctx.translate(0, -s * 0.25);
                            ctx.fillStyle = '#F4A460';
                            ctx.fillRect(-s * 0.08, -s * 0.12, s * 0.16, s * 0.24);
                            ctx.fillStyle = '#8B0000';
                            ctx.font = 'bold ' + (s * 0.15) + 'px serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('?', 0, 0);
                            ctx.restore();
                        }
                        ctx.strokeStyle = 'rgba(244, 164, 96, 0.5)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(c, c, s * 0.35, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    };
                }
                if (id === 'guardian_burrow' || (id.includes('burrow') && id.includes('guardian'))) {
                    return (ctx, s) => {
                        const c = s / 2;
                        ctx.fillStyle = '#8B4513';
                        ctx.beginPath();
                        ctx.arc(c, c + s * 0.1, s * 0.3, Math.PI, 0);
                        ctx.fill();
                        ctx.fillStyle = '#DAA520';
                        for (let i = 0; i < 5; i++) {
                            ctx.beginPath();
                            ctx.arc(c + (Math.random() - 0.5) * s * 0.5, c - s * 0.1 - Math.random() * s * 0.2, s * 0.02, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    };
                }
                if (id === 'guardian_construct' || (id.includes('construct') && id.includes('guardian'))) {
                    return (ctx, s) => {
                        const c = s / 2;
                        ctx.fillStyle = '#556B2F';
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.2, c - s * 0.1);
                        ctx.lineTo(c + s * 0.2, c - s * 0.1);
                        ctx.lineTo(c + s * 0.15, c + s * 0.2);
                        ctx.lineTo(c, c + s * 0.3);
                        ctx.lineTo(c - s * 0.15, c + s * 0.2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.shadowColor = '#00FF00';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#00FF00';
                        ctx.fillRect(c - s * 0.1, c, s * 0.06, s * 0.06);
                        ctx.fillRect(c + s * 0.04, c, s * 0.06, s * 0.06);
                        ctx.shadowBlur = 0;
                    };
                }
                if (id === 'guardian_worldbreaker' || (id.includes('worldbreaker') && id.includes('guardian'))) {
                    return (ctx, s) => {
                        const c = s / 2;
                        ctx.fillStyle = '#2a1a10';
                        ctx.fillRect(0, 0, s, s);
                        ctx.shadowColor = '#FF0000';
                        ctx.shadowBlur = 10;
                        ctx.strokeStyle = '#FF4500';
                        ctx.lineWidth = s * 0.05;
                        ctx.beginPath();
                        ctx.moveTo(s * 0.2, s * 0.2);
                        ctx.lineTo(c, c);
                        ctx.lineTo(s * 0.8, s * 0.3);
                        ctx.moveTo(c, c);
                        ctx.lineTo(s * 0.4, s * 0.8);
                        ctx.moveTo(c, c);
                        ctx.lineTo(s * 0.75, s * 0.75);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    };
                }

                // 1. Mob Fallbacks (High Priority)
                if (id.startsWith('mob_')) {
                    if (id.includes('dragon') || id.includes('drake') || id.includes('wyvern')) return this.icons['mob_dragon'] || this.icons['class_dragonhunter'];
                    if (id.includes('skeleton') || id.includes('necro') || id.includes('undead')) return this.icons['mob_skeleton'];
                    if (id.includes('tornado') || id.includes('wind') || id.includes('zephyr') || id.includes('cyclone') || id.includes('tempest')) return this.icons['class_wind_master'];
                    if (id.includes('titan') || id.includes('golem') || id.includes('giant') || id.includes('colossus') || id.includes('mountain')) return this.icons['mob_stone_golem'] || this.icons['char_titan'];
                    if (id.includes('ninja') || id.includes('shadow') || id.includes('assassin') || id.includes('phantom')) return this.icons['mob_shadow_assassin'] || this.icons['class_ninja'];
                    if (id.includes('roman') || id.includes('soldier') || id.includes('guard') || id.includes('caesar') || id.includes('legion') || id.includes('centurion')) return this.icons['class_roman_legionary'];
                    if (id.includes('spartan') || id.includes('hoplite') || id.includes('leonidas') || id.includes('warrior') || id.includes('athenian')) return this.icons['class_spartan_hoplite'];
                    if (id.includes('mech') || id.includes('drone') || id.includes('robot') || id.includes('cyber')) return this.icons['class_gunslinger'];
                    if (id.includes('samurai') || id.includes('ronin') || id.includes('shogun')) return this.icons['class_samurai'];
                    if (id.includes('elemental') || id.includes('wisp') || id.includes('sorcerer') || id.includes('mage') || id.includes('mystic')) return this.icons['mob_arcane_wisp'] || this.icons['class_elementalist'];
                    if (id.includes('wolf')) return this.icons['mob_wolf'];
                    if (id.includes('spider')) return this.icons['mob_spider'];
                    if (id.includes('slime')) return this.icons['mob_slime'];
                    if (id.includes('reaver') || id.includes('blood') || id.includes('axe_thrower')) return this.icons['class_berserker'];
                    if (id.includes('taurha') || id.includes('ancient')) return this.icons['ancient-guardian'] || this.icons['mob_stone_golem'];
                    if (id.includes('anubis') || id.includes('jackal') || id.includes('pharaoh')) return this.icons['class_anubis'];
                }

                // 2. Ability Fallbacks - EXPANDED
                // Melee / Sharp
                if (id.includes('sword') || id.includes('blade') || id.includes('slash') || id.includes('claw') || id.includes('cut') || id.includes('gladius') || id.includes('strike') || id.includes('pierce') || id.includes('spear') || id.includes('axe')) return this.icons['ability_sword'];

                // Defense / Protection
                if (id.includes('shield') || id.includes('guard') || id.includes('wall') || id.includes('protect') || id.includes('defense') || id.includes('testudo') || id.includes('phalanx') || id.includes('pillar') || id.includes('barrier') || id.includes('fortress') || id.includes('armor')) return this.icons['ability_shield'];

                // Fire / Heat
                if (id.includes('fire') || id.includes('flame') || id.includes('burn') || id.includes('inferno') || id.includes('dragon') || id.includes('lava') || id.includes('ember') || id.includes('phoenix') || id.includes('breath') || id.includes('explosion') || id.includes('bomb') || id.includes('blast') || id.includes('magma') || id.includes('pyro')) return this.icons['ability_fire'];

                // Ice / Cold
                if (id.includes('ice') || id.includes('frost') || id.includes('cold') || id.includes('freeze') || id.includes('blizzard') || id.includes('glacier') || id.includes('snow') || id.includes('chill')) return this.icons['ability_ice'];

                // Ranged / Projectiles
                if (id.includes('arrow') || id.includes('bow') || id.includes('rang') || id.includes('shoot') || id.includes('pilum') || id.includes('dory') || id.includes('javavelin') || id.includes('missile') || id.includes('projectile') || id.includes('gun') || id.includes('shot') || id.includes('sniper')) return this.icons['ability_arrow'];

                // Lightning / Speed / Energy
                if (id.includes('light') || id.includes('flash') || id.includes('beam') || id.includes('laser') || id.includes('storm') || id.includes('thunder') || id.includes('shock') || id.includes('titan_smash') || id.includes('quake') || id.includes('roar') || id.includes('dash') || id.includes('charge') || id.includes('sprint') || id.includes('pulse') || id.includes('surge') || id.includes('bolt') || id.includes('rapid')) return this.icons['ability_lightning'];

                // Healing / Nature / Life
                if (id.includes('heal') || id.includes('cure') || id.includes('life') || id.includes('regen') || id.includes('nature') || id.includes('revive') || id.includes('growth') || id.includes('bloom') || id.includes('spirit') || id.includes('soul') || id.includes('ankh')) return this.icons['ability_heal'];

                // Magic / Mystic / Dark (Map to closest existing or class icons)
                if (id.includes('magic') || id.includes('mystic') || id.includes('orb') || id.includes('spell') || id.includes('arcane') || id.includes('teleport') || id.includes('void') || id.includes('dark') || id.includes('shadow') || id.includes('night') || id.includes('curse') || id.includes('plague') || id.includes('poison') || id.includes('toxic')) return this.icons['class_mystic'] || this.icons['ability_fire']; // Fallback to mystic class or fire (as generic magic)

                // Earth / Rock / Sand
                if (id.includes('earth') || id.includes('rock') || id.includes('stone') || id.includes('sand') || id.includes('dust') || id.includes('golem')) return this.icons['mob_stone_golem'] || this.icons['ability_shield'];

                // Wind / Air
                if (id.includes('wind') || id.includes('air') || id.includes('breeze') || id.includes('blow') || id.includes('gust') || id.includes('tornado') || id.includes('cyclone')) return this.icons['class_wind_master'] || this.icons['ability_lightning'];

                // 3. Class Prefix Fallbacks (Safety Net)
                if (id.startsWith('dragon')) return this.icons['class_dragonhunter'];
                if (id.startsWith('roman') || id.startsWith('imperator')) return this.icons['class_roman_legionary'];
                if (id.startsWith('spartan') || id.startsWith('immortal')) return this.icons['class_spartan_hoplite'];
                if (id.startsWith('guardian') || id.startsWith('ancient')) return this.icons['ancient-guardian'] || this.icons['mob_stone_golem']; // Ancient Guardian doesn't have class_ prefix in ID potentially
                if (id.startsWith('anubis')) return this.icons['class_anubis'];
                if (id.startsWith('gun') || id.startsWith('cyber')) return this.icons['class_gunslinger'];
                if (id.startsWith('elem')) return this.icons['class_elementalist'];
                if (id.startsWith('mystic')) return this.icons['class_mystic'];
                if (id.startsWith('berserker') || id.startsWith('wild')) return this.icons['class_berserker'];
                if (id.startsWith('ninja') || id.startsWith('shadow') || id.startsWith('abyssal')) return this.icons['class_ninja'];
                if (id.startsWith('wind') || id.startsWith('storm')) return this.icons['class_wind_master'];
                if (id.startsWith('samurai') || id.startsWith('ronin')) return this.icons['class_samurai'];
                if (id.startsWith('titan') || id.startsWith('gorath')) return this.icons['char_titan'];

                // Specific Character mappings
                if (id.includes('rex')) return this.icons['char_rex'];
                if (id.includes('nova')) return this.icons['char_nova'];

                return null;
            },

            // Procedural Icon Generator - Creates unique emblems for unknown abilities
            drawDefault(ctx, s, iconId = '') {
                const id = iconId.toLowerCase();

                // Generate hash from iconId for consistent randomization
                let hash = 0;
                for (let i = 0; i < id.length; i++) {
                    hash = id.charCodeAt(i) + ((hash << 5) - hash);
                }

                // Color palette based on keywords
                let palette = { primary: '#6b7280', secondary: '#374151', accent: '#9ca3af' }; // Default gray
                if (id.includes('fire') || id.includes('flame') || id.includes('burn') || id.includes('inferno')) {
                    palette = { primary: '#ff4400', secondary: '#ff8800', accent: '#ffcc00' };
                } else if (id.includes('ice') || id.includes('frost') || id.includes('cold') || id.includes('freeze') || id.includes('water')) {
                    palette = { primary: '#00d9ff', secondary: '#0077ff', accent: '#aaddff' };
                } else if (id.includes('wind') || id.includes('air') || id.includes('storm') || id.includes('gust')) {
                    palette = { primary: '#88ff88', secondary: '#00cc00', accent: '#ccffcc' };
                } else if (id.includes('poison') || id.includes('toxic') || id.includes('acid') || id.includes('venom')) {
                    palette = { primary: '#77ff00', secondary: '#33aa00', accent: '#aaff77' };
                } else if (id.includes('blood') || id.includes('rage') || id.includes('berserk') || id.includes('fury')) {
                    palette = { primary: '#cc0000', secondary: '#880000', accent: '#ff4444' };
                } else if (id.includes('shadow') || id.includes('dark') || id.includes('void') || id.includes('night')) {
                    palette = { primary: '#440066', secondary: '#220033', accent: '#8800cc' };
                } else if (id.includes('light') || id.includes('holy') || id.includes('divine') || id.includes('gold')) {
                    palette = { primary: '#ffd700', secondary: '#ff9900', accent: '#ffff88' };
                } else if (id.includes('earth') || id.includes('rock') || id.includes('stone') || id.includes('sand')) {
                    palette = { primary: '#8b5a2b', secondary: '#5c3d2e', accent: '#c4a76c' };
                } else if (id.includes('electric') || id.includes('thunder') || id.includes('lightning') || id.includes('shock')) {
                    palette = { primary: '#ffff00', secondary: '#ffcc00', accent: '#ffffaa' };
                } else if (id.includes('heal') || id.includes('life') || id.includes('nature') || id.includes('regen')) {
                    palette = { primary: '#00ff88', secondary: '#00aa55', accent: '#88ffaa' };
                }

                // Shape selection based on hash
                const shapes = ['circle', 'diamond', 'hexagon', 'star', 'shield'];
                const shapeIndex = Math.abs(hash) % shapes.length;
                const shape = shapes[shapeIndex];

                // Background glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = palette.primary;

                // Draw base shape
                ctx.fillStyle = palette.secondary;
                ctx.beginPath();
                const cx = s / 2, cy = s / 2, r = s * 0.42;

                if (shape === 'circle') {
                    ctx.arc(cx, cy, r, 0, Math.PI * 2);
                } else if (shape === 'diamond') {
                    ctx.moveTo(cx, cy - r); ctx.lineTo(cx + r, cy); ctx.lineTo(cx, cy + r); ctx.lineTo(cx - r, cy);
                } else if (shape === 'hexagon') {
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 60 - 90) * Math.PI / 180;
                        const px = cx + r * Math.cos(angle), py = cy + r * Math.sin(angle);
                        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                    }
                } else if (shape === 'star') {
                    for (let i = 0; i < 5; i++) {
                        const outerAngle = (i * 72 - 90) * Math.PI / 180;
                        const innerAngle = ((i * 72) + 36 - 90) * Math.PI / 180;
                        ctx.lineTo(cx + r * Math.cos(outerAngle), cy + r * Math.sin(outerAngle));
                        ctx.lineTo(cx + r * 0.4 * Math.cos(innerAngle), cy + r * 0.4 * Math.sin(innerAngle));
                    }
                } else { // shield
                    ctx.moveTo(cx - r * 0.8, cy - r * 0.9);
                    ctx.lineTo(cx + r * 0.8, cy - r * 0.9);
                    ctx.lineTo(cx + r * 0.8, cy);
                    ctx.quadraticCurveTo(cx + r * 0.8, cy + r, cx, cy + r);
                    ctx.quadraticCurveTo(cx - r * 0.8, cy + r, cx - r * 0.8, cy);
                }
                ctx.closePath();
                ctx.fill();

                // Inner accent
                ctx.shadowBlur = 0;
                ctx.fillStyle = palette.primary;
                ctx.beginPath();
                ctx.arc(cx, cy, r * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // Rune/symbol based on hash bits
                ctx.strokeStyle = palette.accent;
                ctx.lineWidth = 2;
                ctx.beginPath();
                if (Math.abs(hash) & 1) { ctx.moveTo(cx - r * 0.3, cy - r * 0.3); ctx.lineTo(cx + r * 0.3, cy + r * 0.3); }
                if (Math.abs(hash) & 2) { ctx.moveTo(cx + r * 0.3, cy - r * 0.3); ctx.lineTo(cx - r * 0.3, cy + r * 0.3); }
                if (Math.abs(hash) & 4) { ctx.arc(cx, cy, r * 0.2, 0, Math.PI * 2); }
                if (Math.abs(hash) & 8) { ctx.moveTo(cx, cy - r * 0.25); ctx.lineTo(cx, cy + r * 0.25); }
                ctx.stroke();

                // Gloss highlight
                ctx.fillStyle = 'rgba(255,255,255,0.25)';
                ctx.beginPath();
                ctx.ellipse(cx - r * 0.15, cy - r * 0.2, r * 0.2, r * 0.15, -0.3, 0, Math.PI * 2);
                ctx.fill();
            },

            // Helper functions
            helpers: {
                gradient(ctx, x, y, r, c1, c2) {
                    const g = ctx.createRadialGradient(x, y, 0, x, y, r);
                    g.addColorStop(0, c1);
                    g.addColorStop(1, c2);
                    return g;
                },
                glow(ctx, color, blur) {
                    ctx.shadowColor = color;
                    ctx.shadowBlur = blur;
                },
                clearGlow(ctx) {
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }
            },

            // Icon definitions - will be populated by phases
            icons: {
                // === SPECIFIC ABILITY ICONS (BERSERKER) ===
                'berserker_rage': function (ctx, s) {
                    const c = s / 2;
                    const bg = ctx.createRadialGradient(c, c, s * 0.12, c, c, s * 0.5);
                    bg.addColorStop(0, '#5e0f19');
                    bg.addColorStop(1, '#120307');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#ff5f6a', 14);
                    ctx.strokeStyle = '#ff6a74';
                    ctx.lineWidth = Math.max(2, s * 0.046);

                    for (let i = 0; i < 3; i++) {
                        const x = s * (0.3 + i * 0.14);
                        ctx.beginPath();
                        ctx.moveTo(x, s * 0.22);
                        ctx.lineTo(x - s * 0.06, s * 0.78);
                        ctx.stroke();
                    }

                    ctx.fillStyle = '#ffd5d8';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.34);
                    ctx.lineTo(c + s * 0.07, s * 0.5);
                    ctx.lineTo(c, s * 0.66);
                    ctx.lineTo(c - s * 0.07, s * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'berserker_whirlwind': function (ctx, s) {
                    const c = s / 2;
                    const bg = ctx.createRadialGradient(c, c, s * 0.08, c, c, s * 0.48);
                    bg.addColorStop(0, '#37131b');
                    bg.addColorStop(1, '#0f0408');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#ff7380', 10);
                    ctx.strokeStyle = '#ff8792';
                    ctx.lineWidth = Math.max(2, s * 0.042);
                    for (let i = 0; i < 5; i++) {
                        const r = s * (0.13 + i * 0.07);
                        ctx.beginPath();
                        ctx.arc(c, c, r, Math.PI * (0.3 + i * 0.08), Math.PI * (1.92 + i * 0.08));
                        ctx.stroke();
                    }
                    ctx.fillStyle = '#ffd4d8';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'berserker_axes': function (ctx, s) {
                    const c = s / 2;
                    const bg = ctx.createLinearGradient(0, 0, s, s);
                    bg.addColorStop(0, '#200d10');
                    bg.addColorStop(1, '#090406');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    const drawAxe = (rot, bladeColor) => {
                        ctx.save();
                        ctx.translate(c, c);
                        ctx.rotate(rot);
                        ctx.fillStyle = '#5e4029';
                        ctx.fillRect(-s * 0.04, -s * 0.37, s * 0.08, s * 0.74);

                        ctx.fillStyle = bladeColor;
                        ctx.beginPath();
                        ctx.moveTo(0, -s * 0.27);
                        ctx.quadraticCurveTo(s * 0.34, -s * 0.2, s * 0.34, 0);
                        ctx.quadraticCurveTo(s * 0.34, s * 0.2, 0, s * 0.27);
                        ctx.closePath();
                        ctx.fill();

                        ctx.strokeStyle = '#ffe3e6';
                        ctx.lineWidth = Math.max(1.5, s * 0.02);
                        ctx.beginPath();
                        ctx.moveTo(s * 0.16, -s * 0.08);
                        ctx.lineTo(s * 0.3, 0);
                        ctx.lineTo(s * 0.16, s * 0.08);
                        ctx.stroke();
                        ctx.restore();
                    };

                    IconRenderer.helpers.glow(ctx, '#ff7a84', 11);
                    drawAxe(-Math.PI / 4.3, '#b9bec7');
                    drawAxe(Math.PI / 4.3, '#9ea8b4');
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'berserker_bloodlust': function (ctx, s) {
                    const c = s / 2;
                    const bg = ctx.createRadialGradient(c, c, s * 0.12, c, c, s * 0.48);
                    bg.addColorStop(0, '#4f1118');
                    bg.addColorStop(1, '#120409');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255, 121, 132, 0.7)';
                    ctx.lineWidth = Math.max(2, s * 0.03);
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.3, 0, Math.PI * 2);
                    ctx.stroke();

                    IconRenderer.helpers.glow(ctx, '#ff6e79', 14);
                    ctx.fillStyle = '#ff6e79';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.2);
                    ctx.bezierCurveTo(c + s * 0.22, s * 0.37, c + s * 0.2, s * 0.68, c, s * 0.84);
                    ctx.bezierCurveTo(c - s * 0.2, s * 0.68, c - s * 0.22, s * 0.37, c, s * 0.2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'berserker_transform': function (ctx, s) {
                    const c = s / 2;
                    const bg = ctx.createRadialGradient(c, c, s * 0.1, c, c, s * 0.48);
                    bg.addColorStop(0, '#411017');
                    bg.addColorStop(1, '#0b0306');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#ff7e89', 12);
                    ctx.fillStyle = '#f2d7da';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.24);
                    ctx.lineTo(c + s * 0.13, s * 0.35);
                    ctx.lineTo(c + s * 0.15, s * 0.54);
                    ctx.lineTo(c + s * 0.08, s * 0.72);
                    ctx.lineTo(c - s * 0.08, s * 0.72);
                    ctx.lineTo(c - s * 0.15, s * 0.54);
                    ctx.lineTo(c - s * 0.13, s * 0.35);
                    ctx.closePath();
                    ctx.fill();

                    ctx.strokeStyle = '#ff8f99';
                    ctx.lineWidth = Math.max(2, s * 0.03);
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.14, s * 0.32);
                    ctx.lineTo(c - s * 0.24, s * 0.18);
                    ctx.moveTo(c + s * 0.14, s * 0.32);
                    ctx.lineTo(c + s * 0.24, s * 0.18);
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'berserker_ultimate': function (ctx, s) {
                    const c = s / 2;
                    const bg = ctx.createRadialGradient(c, c, s * 0.08, c, c, s * 0.5);
                    bg.addColorStop(0, '#62101d');
                    bg.addColorStop(1, '#080204');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#ff8691', 16);
                    ctx.strokeStyle = '#ff9aa3';
                    ctx.lineWidth = Math.max(2, s * 0.03);
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.16);
                    ctx.lineTo(c + s * 0.2, c);
                    ctx.lineTo(c + s * 0.1, c + s * 0.07);
                    ctx.lineTo(c + s * 0.2, s * 0.84);
                    ctx.lineTo(c, c + s * 0.18);
                    ctx.lineTo(c - s * 0.2, s * 0.84);
                    ctx.lineTo(c - s * 0.1, c + s * 0.07);
                    ctx.lineTo(c - s * 0.2, c);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.fillStyle = '#ffe6e9';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'samurai_dash': function (ctx, s) {
                    const c = s / 2;
                    const bg = ctx.createRadialGradient(c, c, s * 0.12, c, c, s * 0.48);
                    bg.addColorStop(0, '#0d1b33');
                    bg.addColorStop(1, '#050914');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#7dd3fc', 12);
                    ctx.strokeStyle = '#7dd3fc';
                    ctx.lineWidth = Math.max(2, s * 0.04);
                    ctx.beginPath();
                    ctx.moveTo(s * 0.2, s * 0.62);
                    ctx.lineTo(s * 0.78, s * 0.38);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(s * 0.33, s * 0.26);
                    ctx.lineTo(s * 0.67, s * 0.74);
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'samurai_counter': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#0a1224';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#f6c453', 12);
                    ctx.strokeStyle = '#f6c453';
                    ctx.lineWidth = Math.max(2, s * 0.04);
                    ctx.beginPath();
                    ctx.moveTo(s * 0.2, s * 0.66);
                    ctx.lineTo(c, s * 0.22);
                    ctx.lineTo(s * 0.8, s * 0.66);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.fillStyle = '#fef3c7';
                    ctx.beginPath();
                    ctx.arc(c, s * 0.5, s * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'samurai_ninja_power': function (ctx, s) {
                    const c = s / 2;
                    const bg = ctx.createLinearGradient(0, 0, s, s);
                    bg.addColorStop(0, '#111827');
                    bg.addColorStop(1, '#030712');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#93c5fd', 12);
                    ctx.fillStyle = 'rgba(147, 197, 253, 0.22)';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.24, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#93c5fd';
                    ctx.lineWidth = Math.max(2, s * 0.03);
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.32, 0, Math.PI * 2);
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'samurai_surprise_cut': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#0c1220';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#a5f3fc', 11);
                    ctx.strokeStyle = '#a5f3fc';
                    ctx.lineWidth = Math.max(2, s * 0.03);
                    for (let i = 0; i < 3; i++) {
                        const y = s * (0.32 + i * 0.17);
                        ctx.beginPath();
                        ctx.moveTo(s * 0.18, y + s * 0.03);
                        ctx.lineTo(s * 0.5, y - s * 0.03);
                        ctx.lineTo(s * 0.82, y + s * 0.03);
                        ctx.stroke();
                    }
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'samurai_ultimate': function (ctx, s) {
                    const c = s / 2;
                    const bg = ctx.createRadialGradient(c, c, s * 0.08, c, c, s * 0.48);
                    bg.addColorStop(0, '#10203d');
                    bg.addColorStop(1, '#03070f');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#67e8f9', 15);
                    ctx.strokeStyle = '#67e8f9';
                    ctx.lineWidth = Math.max(2, s * 0.03);
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI) / 3;
                        ctx.beginPath();
                        ctx.moveTo(c, c);
                        ctx.lineTo(c + Math.cos(angle) * s * 0.32, c + Math.sin(angle) * s * 0.32);
                        ctx.stroke();
                    }
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.1, 0, Math.PI * 2);
                    ctx.fillStyle = '#cffafe';
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'elem_storm': function (ctx, s) {
                    const c = s / 2;
                    const bg = ctx.createRadialGradient(c, c, s * 0.1, c, c, s * 0.48);
                    bg.addColorStop(0, '#26164a');
                    bg.addColorStop(1, '#080412');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#a78bfa', 14);
                    ctx.strokeStyle = '#a78bfa';
                    ctx.lineWidth = Math.max(2, s * 0.04);
                    ctx.beginPath();
                    ctx.moveTo(s * 0.34, s * 0.2);
                    ctx.lineTo(s * 0.52, s * 0.44);
                    ctx.lineTo(s * 0.42, s * 0.44);
                    ctx.lineTo(s * 0.64, s * 0.8);
                    ctx.lineTo(s * 0.46, s * 0.54);
                    ctx.lineTo(s * 0.56, s * 0.54);
                    ctx.closePath();
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'elem_ice': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#091a2c';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#93c5fd', 12);
                    ctx.fillStyle = '#93c5fd';
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 * i) / 6;
                        ctx.beginPath();
                        ctx.moveTo(c, c);
                        ctx.lineTo(c + Math.cos(angle) * s * 0.28, c + Math.sin(angle) * s * 0.28);
                        ctx.lineWidth = Math.max(2, s * 0.028);
                        ctx.strokeStyle = '#93c5fd';
                        ctx.stroke();
                    }
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'elem_ultimate': function (ctx, s) {
                    const c = s / 2;
                    const bg = ctx.createRadialGradient(c, c, s * 0.08, c, c, s * 0.48);
                    bg.addColorStop(0, '#3b1d76');
                    bg.addColorStop(1, '#090311');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    const colors = ['#f97316', '#60a5fa', '#22c55e', '#a78bfa'];
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI * 2 * i) / 4 + Math.PI / 4;
                        ctx.strokeStyle = colors[i];
                        IconRenderer.helpers.glow(ctx, colors[i], 10);
                        ctx.lineWidth = Math.max(2, s * 0.03);
                        ctx.beginPath();
                        ctx.moveTo(c, c);
                        ctx.lineTo(c + Math.cos(angle) * s * 0.3, c + Math.sin(angle) * s * 0.3);
                        ctx.stroke();
                    }
                    ctx.fillStyle = '#f8fafc';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.07, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                // === CLASS ICONS ===
                'class_dragonhunter': function (ctx, s) {
                    const c = s / 2;
                    // Dragon head silhouette
                    ctx.fillStyle = IconRenderer.helpers.gradient(ctx, c, c, s / 2, '#ff6b35', '#8b0000');
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.bezierCurveTo(s * 0.8, s * 0.2, s * 0.9, s * 0.5, s * 0.85, s * 0.7);
                    ctx.lineTo(s * 0.95, s * 0.6);
                    ctx.lineTo(s * 0.85, s * 0.75);
                    ctx.bezierCurveTo(s * 0.7, s * 0.9, s * 0.3, s * 0.9, s * 0.15, s * 0.75);
                    ctx.lineTo(s * 0.05, s * 0.6);
                    ctx.lineTo(s * 0.15, s * 0.7);
                    ctx.bezierCurveTo(s * 0.1, s * 0.5, s * 0.2, s * 0.2, c, s * 0.1);
                    ctx.fill();
                    // Eye
                    IconRenderer.helpers.glow(ctx, '#ffff00', 8);
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(c + s * 0.1, s * 0.4, s * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'class_ninja': function (ctx, s) {
                    const c = s / 2;
                    // Ninja mask
                    ctx.fillStyle = '#1a1a2e';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#e94560';
                    ctx.beginPath();
                    ctx.ellipse(c - s * 0.12, c - s * 0.05, s * 0.1, s * 0.04, -0.2, 0, Math.PI * 2);
                    ctx.ellipse(c + s * 0.12, c - s * 0.05, s * 0.1, s * 0.04, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    // Headband
                    ctx.strokeStyle = '#e94560';
                    ctx.lineWidth = s * 0.06;
                    ctx.beginPath();
                    ctx.moveTo(s * 0.1, c - s * 0.15);
                    ctx.lineTo(s * 0.9, c - s * 0.15);
                    ctx.stroke();
                    // Tail
                    ctx.beginPath();
                    ctx.moveTo(s * 0.85, c - s * 0.15);
                    ctx.quadraticCurveTo(s * 0.95, c + s * 0.1, s * 0.9, c + s * 0.3);
                    ctx.stroke();
                },

                'class_wind_master': function (ctx, s) {
                    const c = s / 2;
                    // Spiral wind
                    ctx.strokeStyle = '#00d4ff';
                    ctx.lineWidth = s * 0.05;
                    ctx.lineCap = 'round';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        const offset = (i * Math.PI * 2) / 3;
                        for (let a = 0; a < Math.PI * 2; a += 0.1) {
                            const r = s * 0.1 + a * s * 0.06;
                            const x = c + Math.cos(a + offset) * r;
                            const y = c + Math.sin(a + offset) * r;
                            if (a === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    // Center glow
                    IconRenderer.helpers.glow(ctx, '#00d4ff', 10);
                    ctx.fillStyle = '#00d4ff';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'class_berserker': function (ctx, s) {
                    const c = s / 2;
                    ctx.save();

                    const bg = ctx.createRadialGradient(c, c, s * 0.05, c, c, s * 0.5);
                    bg.addColorStop(0, '#5e0f19');
                    bg.addColorStop(1, '#080305');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    const drawAxe = (rot) => {
                        ctx.save();
                        ctx.translate(c, c);
                        ctx.rotate(rot);
                        ctx.fillStyle = '#65442b';
                        ctx.fillRect(-s * 0.032, -s * 0.34, s * 0.064, s * 0.68);
                        ctx.fillStyle = '#bcc5d0';
                        ctx.beginPath();
                        ctx.moveTo(0, -s * 0.23);
                        ctx.quadraticCurveTo(s * 0.24, -s * 0.18, s * 0.24, 0);
                        ctx.quadraticCurveTo(s * 0.24, s * 0.18, 0, s * 0.23);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    };
                    drawAxe(-Math.PI / 4.7);
                    drawAxe(Math.PI / 4.7);

                    IconRenderer.helpers.glow(ctx, '#ff8a95', 12);
                    ctx.fillStyle = '#f4dde0';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.26);
                    ctx.lineTo(c + s * 0.14, s * 0.36);
                    ctx.lineTo(c + s * 0.11, s * 0.6);
                    ctx.lineTo(c, s * 0.74);
                    ctx.lineTo(c - s * 0.11, s * 0.6);
                    ctx.lineTo(c - s * 0.14, s * 0.36);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = '#ff6f7b';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.05, s * 0.5, s * 0.03, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.05, s * 0.5, s * 0.03, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                    ctx.restore();
                },

                'class_mystic': function (ctx, s) {
                    const c = s / 2;
                    ctx.save();

                    const bg = ctx.createRadialGradient(c, c, s * 0.08, c, c, s * 0.5);
                    bg.addColorStop(0, '#2a1452');
                    bg.addColorStop(1, '#090511');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#c084fc', 12);
                    ctx.strokeStyle = '#c084fc';
                    ctx.lineWidth = Math.max(1.5, s * 0.02);
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.ellipse(c, c, s * (0.15 + i * 0.1), s * (0.08 + i * 0.06), (i * Math.PI) / 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    ctx.fillStyle = '#f5e8ff';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.19);
                    ctx.lineTo(c + s * 0.08, c - s * 0.02);
                    ctx.lineTo(c + s * 0.26, c - s * 0.02);
                    ctx.lineTo(c + s * 0.11, c + s * 0.1);
                    ctx.lineTo(c + s * 0.17, s * 0.31);
                    ctx.lineTo(c, c + s * 0.16);
                    ctx.lineTo(c - s * 0.17, s * 0.31);
                    ctx.lineTo(c - s * 0.11, c + s * 0.1);
                    ctx.lineTo(c - s * 0.26, c - s * 0.02);
                    ctx.lineTo(c - s * 0.08, c - s * 0.02);
                    ctx.closePath();
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                    ctx.restore();
                },

                'class_gunslinger': function (ctx, s) {
                    const c = s / 2;
                    ctx.save();

                    const bg = ctx.createRadialGradient(c, c, s * 0.06, c, c, s * 0.5);
                    bg.addColorStop(0, '#112233');
                    bg.addColorStop(1, '#05090f');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#22d3ee', 14);
                    ctx.strokeStyle = 'rgba(34, 211, 238, 0.35)';
                    ctx.lineWidth = Math.max(1.5, s * 0.018);
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.34, 0, Math.PI * 2);
                    ctx.stroke();

                    const drawPistol = (xOffset, rot) => {
                        ctx.save();
                        ctx.translate(c + xOffset, c + s * 0.02);
                        ctx.rotate(rot);
                        ctx.fillStyle = '#1f2937';
                        ctx.beginPath();
                        ctx.roundRect(-s * 0.14, -s * 0.08, s * 0.28, s * 0.12, s * 0.02);
                        ctx.fill();
                        ctx.fillStyle = '#67e8f9';
                        ctx.fillRect(s * 0.04, -s * 0.062, s * 0.07, s * 0.04);
                        ctx.fillStyle = '#0f172a';
                        ctx.fillRect(-s * 0.02, s * 0.01, s * 0.06, s * 0.14);
                        ctx.restore();
                    };

                    drawPistol(-s * 0.11, -0.32);
                    drawPistol(s * 0.11, 0.32);

                    ctx.fillStyle = '#e2f9ff';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.075, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                    ctx.restore();
                },

                'class_elementalist': function (ctx, s) {
                    const c = s / 2;
                    const bg = ctx.createRadialGradient(c, c, s * 0.08, c, c, s * 0.5);
                    bg.addColorStop(0, '#26164a');
                    bg.addColorStop(1, '#07040f');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    const nodes = [
                        { x: s * 0.25, y: s * 0.25, color: '#f97316' },
                        { x: s * 0.75, y: s * 0.25, color: '#60a5fa' },
                        { x: s * 0.25, y: s * 0.75, color: '#22c55e' },
                        { x: s * 0.75, y: s * 0.75, color: '#a78bfa' }
                    ];
                    nodes.forEach(node => {
                        IconRenderer.helpers.glow(ctx, node.color, 8);
                        ctx.fillStyle = node.color;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, s * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255,255,255,0.35)';
                        ctx.lineWidth = Math.max(1.5, s * 0.02);
                        ctx.stroke();
                    });

                    ctx.strokeStyle = 'rgba(255,255,255,0.28)';
                    ctx.lineWidth = Math.max(1.5, s * 0.018);
                    for (let i = 0; i < nodes.length; i++) {
                        for (let j = i + 1; j < nodes.length; j++) {
                            ctx.beginPath();
                            ctx.moveTo(nodes[i].x, nodes[i].y);
                            ctx.lineTo(nodes[j].x, nodes[j].y);
                            ctx.stroke();
                        }
                    }

                    IconRenderer.helpers.glow(ctx, '#f8fafc', 12);
                    ctx.fillStyle = '#f8fafc';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'class_samurai': function (ctx, s) {
                    const c = s / 2;
                    const bg = ctx.createRadialGradient(c, c, s * 0.08, c, c, s * 0.5);
                    bg.addColorStop(0, '#122447');
                    bg.addColorStop(1, '#040812');
                    ctx.fillStyle = bg;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.47, 0, Math.PI * 2);
                    ctx.fill();

                    IconRenderer.helpers.glow(ctx, '#93c5fd', 10);
                    ctx.strokeStyle = '#bfdbfe';
                    ctx.lineWidth = Math.max(2, s * 0.028);

                    const drawKatana = (rot, xOffset) => {
                        ctx.save();
                        ctx.translate(c + xOffset, c);
                        ctx.rotate(rot);
                        ctx.fillStyle = '#dbe7f5';
                        ctx.fillRect(-s * 0.02, -s * 0.34, s * 0.04, s * 0.46);
                        ctx.fillStyle = '#2b3445';
                        ctx.fillRect(-s * 0.03, s * 0.12, s * 0.06, s * 0.2);
                        ctx.fillStyle = '#facc15';
                        ctx.fillRect(-s * 0.06, s * 0.1, s * 0.12, s * 0.03);
                        ctx.restore();
                    };

                    drawKatana(-Math.PI / 5, -s * 0.1);
                    drawKatana(Math.PI / 5, s * 0.1);

                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.13, s * 0.72);
                    ctx.lineTo(c, s * 0.22);
                    ctx.lineTo(c + s * 0.13, s * 0.72);
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                // More classes
                'class_roman_legionary': function (ctx, s) {
                    const c = s / 2;
                    // 1. Background Aura (Roman Pride)
                    const grad = ctx.createRadialGradient(c, c, 0, c, c, s * 0.5);
                    grad.addColorStop(0, 'rgba(139, 0, 0, 0.3)');
                    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, s, s);

                    // 2. Gladius (Crossed under helmet)
                    const drawSword = (angle) => {
                        ctx.save();
                        ctx.translate(c, c + s * 0.1);
                        ctx.rotate(angle);
                        ctx.fillStyle = '#c0c0c0';
                        ctx.fillRect(-s * 0.04, -s * 0.4, s * 0.08, s * 0.5); // Blade
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(-s * 0.1, -s * 0.05, s * 0.2, s * 0.05); // Guard
                        ctx.fillStyle = '#4a2c00';
                        ctx.fillRect(-s * 0.05, 0, s * 0.1, s * 0.2); // Handle
                        ctx.restore();
                    };
                    drawSword(-Math.PI / 4);
                    drawSword(Math.PI / 4);

                    // 3. Roman Helmet (Galea)
                    ctx.save();
                    IconRenderer.helpers.glow(ctx, 'rgba(255, 215, 0, 0.5)', 15);

                    // Crest (Transversal)
                    ctx.fillStyle = '#8b0000';
                    ctx.beginPath();
                    ctx.ellipse(c, s * 0.25, s * 0.35, s * 0.1, 0, Math.PI, 0);
                    ctx.fill();
                    // Crest bristles texture
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 30; i++) {
                        const x = c - s * 0.3 + (i * s * 0.02);
                        ctx.beginPath();
                        ctx.moveTo(x, s * 0.25);
                        ctx.lineTo(x, s * 0.15);
                        ctx.stroke();
                    }

                    // Helmet Shell
                    const helmetGrad = ctx.createLinearGradient(0, s * 0.2, 0, s * 0.7);
                    helmetGrad.addColorStop(0, '#ffd700');
                    helmetGrad.addColorStop(1, '#8b6914');
                    ctx.fillStyle = helmetGrad;
                    ctx.beginPath();
                    ctx.arc(c, c + s * 0.05, s * 0.3, Math.PI, 0);
                    ctx.lineTo(c + s * 0.3, c + s * 0.4);
                    ctx.lineTo(c - s * 0.3, c + s * 0.4);
                    ctx.closePath();
                    ctx.fill();

                    // Cheek guards
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.3, c + s * 0.1);
                    ctx.lineTo(c - s * 0.35, c + s * 0.45);
                    ctx.lineTo(c - s * 0.1, c + s * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(c + s * 0.3, c + s * 0.1);
                    ctx.lineTo(c + s * 0.35, c + s * 0.45);
                    ctx.lineTo(c + s * 0.1, c + s * 0.4);
                    ctx.closePath();
                    ctx.fill();

                    // Eyes (Glowing)
                    IconRenderer.helpers.glow(ctx, '#00d9ff', 8);
                    ctx.fillStyle = 'rgba(0, 217, 255, 0.8)';
                    ctx.fillRect(c - s * 0.2, c + s * 0.1, s * 0.12, s * 0.06);
                    ctx.fillRect(c + s * 0.08, c + s * 0.1, s * 0.12, s * 0.06);

                    ctx.restore();
                },

                'class_spartan_hoplite': function (ctx, s) {
                    const c = s / 2;
                    // 1. Background (Burning Battlefield)
                    const battlefield = ctx.createRadialGradient(c, c, 0, c, c, s * 0.5);
                    battlefield.addColorStop(0, 'rgba(139, 0, 0, 0.4)');
                    battlefield.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = battlefield;
                    ctx.fillRect(0, 0, s, s);

                    // 2. Shield (Aspis)
                    ctx.save();
                    ctx.translate(c, c);
                    ctx.rotate(Math.PI / 10); // Slight tilt

                    // Bronze Body
                    const bronze = ctx.createLinearGradient(-s * 0.4, -s * 0.4, s * 0.4, s * 0.4);
                    bronze.addColorStop(0, '#cd7f32');
                    bronze.addColorStop(0.5, '#ffd700');
                    bronze.addColorStop(1, '#8b4513');
                    ctx.fillStyle = bronze;
                    ctx.beginPath();
                    ctx.arc(0, 0, s * 0.42, 0, Math.PI * 2);
                    ctx.fill();

                    // Battle Scars (Slash marks)
                    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-s * 0.3, -s * 0.2 + i * s * 0.1);
                        ctx.lineTo(s * 0.2, s * 0.1 + i * s * 0.1);
                        ctx.stroke();
                    }

                    // Lambda Symbol (?)
                    ctx.shadowColor = '#8b0000';
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = '#8b0000';
                    ctx.lineWidth = s * 0.1;
                    ctx.lineCap = 'square';
                    ctx.beginPath();
                    ctx.moveTo(-s * 0.2, s * 0.15);
                    ctx.lineTo(0, -s * 0.25);
                    ctx.lineTo(s * 0.2, s * 0.15);
                    ctx.stroke();

                    // 3. Spear (Dory) - Poking from behind
                    ctx.rotate(-Math.PI / 5);
                    ctx.fillStyle = '#eee';
                    ctx.beginPath();
                    ctx.moveTo(s * 0.35, -s * 0.45);
                    ctx.lineTo(s * 0.45, -s * 0.55);
                    ctx.lineTo(s * 0.4, -s * 0.4);
                    ctx.fill();
                    ctx.strokeStyle = '#4a2c00';
                    ctx.lineWidth = s * 0.03;
                    ctx.beginPath();
                    ctx.moveTo(s * 0.2, -s * 0.2);
                    ctx.lineTo(s * 0.4, -s * 0.4);
                    ctx.stroke();

                    ctx.restore();
                },

                'ancient-guardian': function (ctx, s) {
                    const c = s / 2;
                    // Stone golem face
                    ctx.fillStyle = '#6b5b4f';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.lineTo(s * 0.85, s * 0.35);
                    ctx.lineTo(s * 0.9, s * 0.7);
                    ctx.lineTo(c, s * 0.9);
                    ctx.lineTo(s * 0.1, s * 0.7);
                    ctx.lineTo(s * 0.15, s * 0.35);
                    ctx.closePath();
                    ctx.fill();
                    // Glowing runes
                    IconRenderer.helpers.glow(ctx, '#ffd700', 8);
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.15, c - s * 0.05, s * 0.06, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.15, c - s * 0.05, s * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    // Rune lines
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.1, c + s * 0.15);
                    ctx.lineTo(c, c + s * 0.25);
                    ctx.lineTo(c + s * 0.1, c + s * 0.15);
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                // === GUARDIAN ANCESTRAL ABILITIES ===
                'guardian_glyph': function (ctx, s) {
                    const c = s / 2;
                    // Golden Hexagram
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = s * 0.06;
                    IconRenderer.helpers.glow(ctx, '#DAA520', 10);
                    ctx.beginPath();
                    const r = s * 0.35;
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 / 6) * i;
                        const x = c + Math.cos(angle) * r;
                        const y = c + Math.sin(angle) * r;
                        const x2 = c + Math.cos(angle + Math.PI * 2 / 3) * r;
                        const y2 = c + Math.sin(angle + Math.PI * 2 / 3) * r;
                        ctx.moveTo(x, y);
                        ctx.lineTo(x2, y2);
                    }
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(c, c, r * 1.2, 0, Math.PI * 2);
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'guardian_hurl': function (ctx, s) {
                    const c = s / 2;
                    ctx.save();
                    ctx.translate(c, c);
                    ctx.rotate(Math.PI / 4);
                    // Stone projectile
                    ctx.fillStyle = '#8B4513';
                    IconRenderer.helpers.glow(ctx, '#000', 5);
                    ctx.beginPath();
                    ctx.moveTo(-s * 0.15, -s * 0.2);
                    ctx.lineTo(s * 0.15, -s * 0.15);
                    ctx.lineTo(s * 0.2, s * 0.2);
                    ctx.lineTo(-s * 0.2, s * 0.15);
                    ctx.closePath();
                    ctx.fill();
                    // Gold cracks
                    ctx.strokeStyle = '#DAA520';
                    ctx.lineWidth = s * 0.04;
                    ctx.stroke();
                    // Trail
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.beginPath();
                    ctx.moveTo(-s * 0.2, s * 0.15);
                    ctx.lineTo(-s * 0.4, s * 0.4);
                    ctx.lineTo(-s * 0.1, s * 0.25);
                    ctx.fill();
                    ctx.restore();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'guardian_tablets': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#F4A460', 8);
                    for (let i = 0; i < 3; i++) {
                        ctx.save();
                        ctx.translate(c, c);
                        ctx.rotate((Math.PI * 2 / 3) * i - Math.PI / 6);
                        ctx.translate(0, -s * 0.25);
                        // Tablet
                        ctx.fillStyle = '#F4A460';
                        ctx.fillRect(-s * 0.08, -s * 0.12, s * 0.16, s * 0.24);
                        // Rune
                        ctx.fillStyle = '#8B0000';
                        ctx.font = 'bold ' + (s * 0.15) + 'px serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('?', 0, 0);
                        ctx.restore();
                    }
                    // Center aura
                    ctx.strokeStyle = 'rgba(244, 164, 96, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'guardian_burrow': function (ctx, s) {
                    const c = s / 2;
                    // Mound
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.arc(c, c + s * 0.1, s * 0.3, Math.PI, 0);
                    ctx.fill();
                    // Particles
                    ctx.fillStyle = '#DAA520';
                    for (let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        ctx.arc(c + (Math.random() - 0.5) * s * 0.5, c - s * 0.1 - Math.random() * s * 0.2, s * 0.02, 0, Math.PI * 2);
                        ctx.fill();
                    }
                },
                'guardian_construct': function (ctx, s) {
                    const c = s / 2;
                    // Mech Head/Helmet
                    ctx.fillStyle = '#556B2F'; // Mossy Green
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.2, c - s * 0.1);
                    ctx.lineTo(c + s * 0.2, c - s * 0.1);
                    ctx.lineTo(c + s * 0.15, c + s * 0.2);
                    ctx.lineTo(c, c + s * 0.3);
                    ctx.lineTo(c - s * 0.15, c + s * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    // Eyes
                    IconRenderer.helpers.glow(ctx, '#00FF00', 10);
                    ctx.fillStyle = '#00FF00';
                    ctx.fillRect(c - s * 0.1, c, s * 0.06, s * 0.06);
                    ctx.fillRect(c + s * 0.04, c, s * 0.06, s * 0.06);
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'guardian_worldbreaker': function (ctx, s) {
                    const c = s / 2;
                    // Cracked Earth Background
                    ctx.fillStyle = '#2a1a10';
                    ctx.fillRect(0, 0, s, s);
                    // Magma cracks
                    IconRenderer.helpers.glow(ctx, '#FF0000', 10);
                    ctx.strokeStyle = '#FF4500';
                    ctx.lineWidth = s * 0.05;
                    ctx.beginPath();
                    ctx.moveTo(s * 0.2, s * 0.2);
                    ctx.lineTo(c, c);
                    ctx.lineTo(s * 0.8, s * 0.3);
                    ctx.moveTo(c, c);
                    ctx.lineTo(s * 0.4, s * 0.8);
                    ctx.moveTo(c, c);
                    ctx.lineTo(s * 0.75, s * 0.75);
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'class_anubis': function (ctx, s) {
                    const c = s / 2;
                    // Jackal head
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.lineTo(c + s * 0.3, s * 0.3);
                    ctx.lineTo(c + s * 0.25, s * 0.85);
                    ctx.lineTo(c - s * 0.25, s * 0.85);
                    ctx.lineTo(c - s * 0.3, s * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    // Ears
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.2, s * 0.3);
                    ctx.lineTo(c - s * 0.35, s * 0.05);
                    ctx.lineTo(c - s * 0.1, s * 0.25);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(c + s * 0.2, s * 0.3);
                    ctx.lineTo(c + s * 0.35, s * 0.05);
                    ctx.lineTo(c + s * 0.1, s * 0.25);
                    ctx.fill();
                    // Golden eyes
                    IconRenderer.helpers.glow(ctx, '#ffd700', 6);
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.ellipse(c - s * 0.1, s * 0.45, s * 0.06, s * 0.04, 0, 0, Math.PI * 2);
                    ctx.ellipse(c + s * 0.1, s * 0.45, s * 0.06, s * 0.04, 0, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                // === CHARACTER ICONS ===
                'char_rex': function (ctx, s) {
                    const c = s / 2;
                    // T-Rex head
                    ctx.fillStyle = '#2d5016';
                    ctx.beginPath();
                    ctx.moveTo(s * 0.2, c);
                    ctx.quadraticCurveTo(s * 0.1, s * 0.3, s * 0.3, s * 0.2);
                    ctx.lineTo(s * 0.85, s * 0.35);
                    ctx.lineTo(s * 0.9, c);
                    ctx.lineTo(s * 0.85, s * 0.65);
                    ctx.lineTo(s * 0.3, s * 0.75);
                    ctx.quadraticCurveTo(s * 0.1, s * 0.65, s * 0.2, c);
                    ctx.fill();
                    // Teeth
                    ctx.fillStyle = '#fff';
                    for (let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        ctx.moveTo(s * 0.5 + i * s * 0.08, s * 0.48);
                        ctx.lineTo(s * 0.52 + i * s * 0.08, s * 0.58);
                        ctx.lineTo(s * 0.48 + i * s * 0.08, s * 0.58);
                        ctx.fill();
                    }
                    // Eye
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.arc(s * 0.35, s * 0.4, s * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                },

                'char_nova': function (ctx, s) {
                    const c = s / 2;
                    // Star burst
                    IconRenderer.helpers.glow(ctx, '#a855f7', 12);
                    ctx.fillStyle = '#a855f7';
                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.translate(c, c);
                        ctx.rotate(i * Math.PI / 4);
                        ctx.beginPath();
                        ctx.moveTo(0, -s * 0.1);
                        ctx.lineTo(s * 0.05, -s * 0.2);
                        ctx.lineTo(0, -s * 0.4);
                        ctx.lineTo(-s * 0.05, -s * 0.2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    // Center
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'char_blade': function (ctx, s) {
                    const c = s / 2;
                    // Crossed swords
                    ctx.strokeStyle = '#c0c0c0';
                    ctx.lineWidth = s * 0.08;
                    ctx.lineCap = 'round';
                    // Sword 1
                    ctx.beginPath();
                    ctx.moveTo(s * 0.15, s * 0.15);
                    ctx.lineTo(s * 0.85, s * 0.85);
                    ctx.stroke();
                    // Sword 2
                    ctx.beginPath();
                    ctx.moveTo(s * 0.85, s * 0.15);
                    ctx.lineTo(s * 0.15, s * 0.85);
                    ctx.stroke();
                    // Handles
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(s * 0.1, s * 0.1, s * 0.12, s * 0.12);
                    ctx.fillRect(s * 0.78, s * 0.1, s * 0.12, s * 0.12);
                    // Glow effect
                    IconRenderer.helpers.glow(ctx, '#00bfff', 6);
                    ctx.fillStyle = '#00bfff';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'char_phoenix': function (ctx, s) {
                    const c = s / 2;
                    // Phoenix bird
                    IconRenderer.helpers.glow(ctx, '#ff6600', 10);
                    ctx.fillStyle = IconRenderer.helpers.gradient(ctx, c, c, s / 2, '#ffcc00', '#ff3300');
                    // Body
                    ctx.beginPath();
                    ctx.ellipse(c, c + s * 0.1, s * 0.2, s * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Wings
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.15, c);
                    ctx.quadraticCurveTo(s * 0.05, s * 0.2, s * 0.1, s * 0.4);
                    ctx.quadraticCurveTo(s * 0.2, c, c - s * 0.15, c + s * 0.1);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(c + s * 0.15, c);
                    ctx.quadraticCurveTo(s * 0.95, s * 0.2, s * 0.9, s * 0.4);
                    ctx.quadraticCurveTo(s * 0.8, c, c + s * 0.15, c + s * 0.1);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.arc(c, s * 0.3, s * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    // Tail flames
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.moveTo(c, c + s * 0.3);
                    ctx.lineTo(c - s * 0.1, s * 0.95);
                    ctx.lineTo(c, c + s * 0.35);
                    ctx.lineTo(c + s * 0.1, s * 0.95);
                    ctx.closePath();
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'char_titan': function (ctx, s) {
                    const c = s / 2;
                    // Stone giant
                    ctx.fillStyle = '#5a4a3a';
                    // Body
                    ctx.beginPath();
                    ctx.roundRect(c - s * 0.25, s * 0.3, s * 0.5, s * 0.6, 8);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.roundRect(c - s * 0.15, s * 0.1, s * 0.3, s * 0.25, 6);
                    ctx.fill();
                    // Glowing eyes
                    IconRenderer.helpers.glow(ctx, '#00ff00', 6);
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.08, s * 0.2, s * 0.04, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.08, s * 0.2, s * 0.04, 0, Math.PI * 2);
                    ctx.fill();
                    // Cracks with glow
                    ctx.strokeStyle = '#ffa500';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.1, s * 0.45);
                    ctx.lineTo(c, s * 0.55);
                    ctx.lineTo(c + s * 0.15, s * 0.5);
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                // === FRUIT ICONS ===
                'fruit_inferno': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#ff4400', 12);
                    // Flame fruit
                    ctx.fillStyle = IconRenderer.helpers.gradient(ctx, c, s * 0.7, s * 0.4, '#ffcc00', '#ff0000');
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.quadraticCurveTo(s * 0.8, s * 0.3, s * 0.75, s * 0.6);
                    ctx.quadraticCurveTo(s * 0.7, s * 0.85, c, s * 0.9);
                    ctx.quadraticCurveTo(s * 0.3, s * 0.85, s * 0.25, s * 0.6);
                    ctx.quadraticCurveTo(s * 0.2, s * 0.3, c, s * 0.1);
                    ctx.fill();
                    // Inner flame
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.35);
                    ctx.quadraticCurveTo(s * 0.6, s * 0.5, s * 0.55, s * 0.65);
                    ctx.quadraticCurveTo(c, s * 0.75, s * 0.45, s * 0.65);
                    ctx.quadraticCurveTo(s * 0.4, s * 0.5, c, s * 0.35);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'fruit_glacier': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#00ccff', 10);
                    // Ice crystal
                    ctx.fillStyle = '#a0e0ff';
                    // Main hexagon
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = i * Math.PI / 3 - Math.PI / 2;
                        const x = c + Math.cos(angle) * s * 0.35;
                        const y = c + Math.sin(angle) * s * 0.35;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    // Inner crystal
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = i * Math.PI / 3 - Math.PI / 2;
                        const x = c + Math.cos(angle) * s * 0.15;
                        const y = c + Math.sin(angle) * s * 0.15;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'fruit_storm': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#ffff00', 10);
                    // Lightning bolt
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.moveTo(c + s * 0.1, s * 0.1);
                    ctx.lineTo(c - s * 0.15, c);
                    ctx.lineTo(c + s * 0.05, c);
                    ctx.lineTo(c - s * 0.1, s * 0.9);
                    ctx.lineTo(c + s * 0.15, c + s * 0.1);
                    ctx.lineTo(c - s * 0.05, c + s * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'fruit_void': function (ctx, s) {
                    const c = s / 2;
                    // Black hole
                    const gradient = ctx.createRadialGradient(c, c, 0, c, c, s * 0.45);
                    gradient.addColorStop(0, '#000000');
                    gradient.addColorStop(0.5, '#1a0033');
                    gradient.addColorStop(1, '#4400aa');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // Event horizon glow
                    IconRenderer.helpers.glow(ctx, '#8800ff', 8);
                    ctx.strokeStyle = '#aa00ff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    // Swirl
                    ctx.strokeStyle = '#6600cc';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let a = 0; a < Math.PI * 4; a += 0.1) {
                        const r = s * 0.05 + a * s * 0.02;
                        const x = c + Math.cos(a) * r;
                        const y = c + Math.sin(a) * r;
                        if (a === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'fruit_radiance': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#ffff88', 15);
                    // Sun rays
                    ctx.fillStyle = '#ffdd44';
                    for (let i = 0; i < 12; i++) {
                        ctx.save();
                        ctx.translate(c, c);
                        ctx.rotate(i * Math.PI / 6);
                        ctx.beginPath();
                        ctx.moveTo(-s * 0.03, -s * 0.15);
                        ctx.lineTo(0, -s * 0.4);
                        ctx.lineTo(s * 0.03, -s * 0.15);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    // Center
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.18, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'fruit_nature': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#00ff00', 8);
                    // Leaf shape
                    ctx.fillStyle = '#22aa22';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.quadraticCurveTo(s * 0.9, s * 0.3, s * 0.85, c);
                    ctx.quadraticCurveTo(s * 0.9, s * 0.75, c, s * 0.9);
                    ctx.quadraticCurveTo(s * 0.1, s * 0.75, s * 0.15, c);
                    ctx.quadraticCurveTo(s * 0.1, s * 0.3, c, s * 0.1);
                    ctx.fill();
                    // Veins
                    ctx.strokeStyle = '#44dd44';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.2);
                    ctx.lineTo(c, s * 0.8);
                    ctx.moveTo(c, s * 0.4);
                    ctx.lineTo(s * 0.7, s * 0.35);
                    ctx.moveTo(c, s * 0.55);
                    ctx.lineTo(s * 0.3, s * 0.5);
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                // === MASTER CLASS ICONS ===
                'master_storm_of_tornados': function (ctx, s) {
                    const c = s / 2;
                    // 1. Dark Swirling Vortex Background
                    const vortexGrad = ctx.createRadialGradient(c, c, 0, c, c, s * 0.5);
                    vortexGrad.addColorStop(0, '#001a1a');
                    vortexGrad.addColorStop(0.7, '#004d4d');
                    vortexGrad.addColorStop(1, '#000000');
                    ctx.fillStyle = vortexGrad;
                    ctx.fillRect(0, 0, s, s);

                    // Swirl lines
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 8; i++) {
                        ctx.beginPath();
                        ctx.arc(c, c, s * 0.1 * i, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // 2. High-Tech Tornados (Three of them)
                    const drawTornado = (ox, oy, scale, alpha) => {
                        ctx.save();
                        ctx.translate(c + ox, c + oy);
                        ctx.globalAlpha = alpha;
                        ctx.strokeStyle = '#00ffff';
                        IconRenderer.helpers.glow(ctx, '#00ffff', 10 * scale);

                        ctx.beginPath();
                        for (let y = -s * 0.3 * scale; y < s * 0.3 * scale; y += 4) {
                            const w = (y + s * 0.3 * scale) * 0.5;
                            const x = Math.sin(y * 0.2 + Date.now() * 0.005) * w * 0.5;
                            ctx.lineWidth = (y + s * 0.3 * scale) * 0.1 * scale;
                            if (y === -s * 0.3 * scale) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        ctx.restore();
                    };

                    drawTornado(-s * 0.2, s * 0.1, 0.7, 0.6);
                    drawTornado(s * 0.2, s * 0.1, 0.7, 0.6);
                    drawTornado(0, -s * 0.05, 1.2, 1);

                    // 3. Central Energy Core
                    IconRenderer.helpers.glow(ctx, '#ffffff', 20);
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.08, 0, Math.PI * 2);
                    ctx.fill();

                    // 4. Debris/Particles
                    ctx.fillStyle = '#00ffff';
                    for (let i = 0; i < 15; i++) {
                        const r = s * 0.3 * Math.random() + s * 0.1;
                        const a = Math.random() * Math.PI * 2;
                        ctx.beginPath();
                        ctx.arc(c + Math.cos(a) * r, c + Math.sin(a) * r, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'master_cybernetic_warlord': function (ctx, s) {
                    const c = s / 2;
                    // Mech helmet
                    ctx.fillStyle = '#2d3436';
                    ctx.beginPath();
                    ctx.roundRect(s * 0.15, s * 0.15, s * 0.7, s * 0.6, 8);
                    ctx.fill();
                    // Visor
                    IconRenderer.helpers.glow(ctx, '#00ffff', 10);
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.roundRect(s * 0.2, s * 0.3, s * 0.6, s * 0.15, 4);
                    ctx.fill();
                    // Tech lines
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(s * 0.25, s * 0.55);
                    ctx.lineTo(s * 0.4, s * 0.6);
                    ctx.lineTo(s * 0.6, s * 0.6);
                    ctx.lineTo(s * 0.75, s * 0.55);
                    ctx.stroke();
                    // Antenna
                    ctx.beginPath();
                    ctx.moveTo(s * 0.7, s * 0.15);
                    ctx.lineTo(s * 0.8, s * 0.05);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(s * 0.8, s * 0.05, 3, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'master_abyssal_shadowlord': function (ctx, s) {
                    const c = s / 2;
                    // Dark aura background
                    const gradient = ctx.createRadialGradient(c, c, 0, c, c, s * 0.5);
                    gradient.addColorStop(0, '#1a0033');
                    gradient.addColorStop(1, '#000000');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.45, 0, Math.PI * 2);
                    ctx.fill();
                    // Skull
                    ctx.fillStyle = '#2a2a4a';
                    ctx.beginPath();
                    ctx.arc(c, c - s * 0.05, s * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.15, c + s * 0.15);
                    ctx.lineTo(c, c + s * 0.35);
                    ctx.lineTo(c + s * 0.15, c + s * 0.15);
                    ctx.fill();
                    // Glowing eyes
                    IconRenderer.helpers.glow(ctx, '#ff0066', 8);
                    ctx.fillStyle = '#ff0066';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.1, c - s * 0.08, s * 0.06, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.1, c - s * 0.08, s * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'master_imperator_aeternus': function (ctx, s) {
                    const c = s / 2;
                    // 1. Royal Purple Background
                    const royalGrad = ctx.createRadialGradient(c, c, 0, c, c, s * 0.5);
                    royalGrad.addColorStop(0, '#2a0044');
                    royalGrad.addColorStop(0.8, '#1a0033');
                    royalGrad.addColorStop(1, '#050010');
                    ctx.fillStyle = royalGrad;
                    ctx.fillRect(0, 0, s, s);

                    // 2. Solar Rays
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.15)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 12; i++) {
                        ctx.beginPath();
                        ctx.moveTo(c, c);
                        const angle = (i * Math.PI * 2) / 12;
                        ctx.lineTo(c + Math.cos(angle) * s, c + Math.sin(angle) * s);
                        ctx.stroke();
                    }

                    // 3. Golden Laurel Crown (High Precision)
                    IconRenderer.helpers.glow(ctx, '#ffd700', 12);
                    ctx.fillStyle = '#ffd700';

                    const drawLeafBranch = (direction) => {
                        for (let i = 0; i < 7; i++) {
                            ctx.save();
                            const angle = (i * 0.2 + 0.5) * direction;
                            ctx.translate(c + direction * s * 0.1, s * 0.3 + i * s * 0.08);
                            ctx.rotate(angle);
                            ctx.beginPath();
                            ctx.ellipse(0, 0, s * 0.1, s * 0.04, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    };
                    drawLeafBranch(-1); // Left
                    drawLeafBranch(1);  // Right

                    // 4. Imperial Eagle (Aquila)
                    ctx.save();
                    ctx.fillStyle = '#8b0000'; // Imperial Red
                    IconRenderer.helpers.glow(ctx, '#ff0000', 10);
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.35); // Head
                    ctx.lineTo(c - s * 0.1, s * 0.4); // Neck
                    ctx.bezierCurveTo(c - s * 0.35, s * 0.3, c - s * 0.4, s * 0.6, c - s * 0.1, s * 0.65); // Left Wing
                    ctx.lineTo(c, s * 0.85); // Tail
                    ctx.lineTo(c + s * 0.1, s * 0.65); // Right Wing
                    ctx.bezierCurveTo(c + s * 0.4, s * 0.6, c + s * 0.35, s * 0.3, c + s * 0.1, s * 0.4); // Right Wing Upper
                    ctx.closePath();
                    ctx.fill();

                    // Eagle Details (Gold accent)
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(c, s * 0.42, 2, 0, Math.PI * 2); // Core
                    ctx.fill();
                    ctx.restore();

                    // 5. Roman Numeral "XII" (Ethereal)
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.font = `bold ${s * 0.15}px 'Orbitron'`;
                    ctx.textAlign = 'center';
                    ctx.fillText('XII', c, s * 0.95);

                    IconRenderer.helpers.clearGlow(ctx);
                },

                'master_immortal_spartan': function (ctx, s) {
                    const c = s / 2;
                    // Spartan helmet with fire
                    ctx.fillStyle = '#8b0000';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.35, Math.PI * 0.2, Math.PI * 0.8, true);
                    ctx.lineTo(c + s * 0.25, s * 0.8);
                    ctx.lineTo(c - s * 0.25, s * 0.8);
                    ctx.closePath();
                    ctx.fill();
                    // Crest flames
                    IconRenderer.helpers.glow(ctx, '#ff4400', 8);
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.08, s * 0.15);
                    ctx.quadraticCurveTo(c - s * 0.15, s * 0.05, c, s * 0.02);
                    ctx.quadraticCurveTo(c + s * 0.15, s * 0.05, c + s * 0.08, s * 0.15);
                    ctx.lineTo(c + s * 0.05, s * 0.4);
                    ctx.lineTo(c - s * 0.05, s * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    // Eye slits
                    ctx.fillStyle = '#ffcc00';
                    ctx.fillRect(c - s * 0.2, c + s * 0.05, s * 0.12, s * 0.04);
                    ctx.fillRect(c + s * 0.08, c + s * 0.05, s * 0.12, s * 0.04);
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'master_gorath_mountain_god': function (ctx, s) {
                    const c = s / 2;
                    // Mountain shape
                    ctx.fillStyle = '#4a4a4a';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.lineTo(s * 0.9, s * 0.85);
                    ctx.lineTo(s * 0.1, s * 0.85);
                    ctx.closePath();
                    ctx.fill();
                    // Lava cracks
                    IconRenderer.helpers.glow(ctx, '#ff4400', 6);
                    ctx.strokeStyle = '#ff6600';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.3);
                    ctx.lineTo(c - s * 0.1, s * 0.5);
                    ctx.lineTo(c + s * 0.05, s * 0.6);
                    ctx.lineTo(c - s * 0.15, s * 0.8);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(c + s * 0.1, s * 0.4);
                    ctx.lineTo(c + s * 0.2, s * 0.65);
                    ctx.stroke();
                    // Glowing summit
                    ctx.fillStyle = '#ff8800';
                    ctx.beginPath();
                    ctx.arc(c, s * 0.15, s * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                // === COMMON ABILITY ICONS ===
                'ability_fire': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#ff4400', 8);
                    ctx.fillStyle = IconRenderer.helpers.gradient(ctx, c, s * 0.8, s * 0.4, '#ffcc00', '#ff0000');
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.quadraticCurveTo(s * 0.75, s * 0.25, s * 0.7, s * 0.5);
                    ctx.quadraticCurveTo(s * 0.65, s * 0.8, c, s * 0.9);
                    ctx.quadraticCurveTo(s * 0.35, s * 0.8, s * 0.3, s * 0.5);
                    ctx.quadraticCurveTo(s * 0.25, s * 0.25, c, s * 0.1);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'ability_ice': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#00ccff', 8);
                    ctx.fillStyle = '#aaeeff';
                    // Snowflake
                    for (let i = 0; i < 6; i++) {
                        ctx.save();
                        ctx.translate(c, c);
                        ctx.rotate(i * Math.PI / 3);
                        ctx.fillRect(-s * 0.03, -s * 0.4, s * 0.06, s * 0.8);
                        ctx.restore();
                    }
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'ability_lightning': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#ffff00', 10);
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.moveTo(c + s * 0.15, s * 0.05);
                    ctx.lineTo(c - s * 0.1, s * 0.45);
                    ctx.lineTo(c + s * 0.08, s * 0.45);
                    ctx.lineTo(c - s * 0.15, s * 0.95);
                    ctx.lineTo(c + s * 0.1, s * 0.55);
                    ctx.lineTo(c - s * 0.08, s * 0.55);
                    ctx.closePath();
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'ability_shield': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = IconRenderer.helpers.gradient(ctx, c, c, s * 0.4, '#4488ff', '#2244aa');
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.lineTo(s * 0.85, s * 0.25);
                    ctx.lineTo(s * 0.8, s * 0.6);
                    ctx.quadraticCurveTo(c, s * 0.95, s * 0.2, s * 0.6);
                    ctx.lineTo(s * 0.15, s * 0.25);
                    ctx.closePath();
                    ctx.fill();
                    // Highlight
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.2);
                    ctx.lineTo(s * 0.7, s * 0.3);
                    ctx.lineTo(s * 0.65, s * 0.5);
                    ctx.lineTo(c, s * 0.4);
                    ctx.closePath();
                    ctx.fill();
                },

                'ability_sword': function (ctx, s) {
                    const c = s / 2;
                    // Blade
                    ctx.fillStyle = '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.05);
                    ctx.lineTo(c + s * 0.1, s * 0.6);
                    ctx.lineTo(c, s * 0.55);
                    ctx.lineTo(c - s * 0.1, s * 0.6);
                    ctx.closePath();
                    ctx.fill();
                    // Guard
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(c - s * 0.2, s * 0.58, s * 0.4, s * 0.08);
                    // Handle
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(c - s * 0.05, s * 0.65, s * 0.1, s * 0.25);
                    // Pommel
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(c, s * 0.92, s * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                },

                'ability_arrow': function (ctx, s) {
                    const c = s / 2;
                    // Arrow shaft
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(c - s * 0.03, s * 0.25, s * 0.06, s * 0.65);
                    // Arrow head
                    ctx.fillStyle = '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.05);
                    ctx.lineTo(c + s * 0.1, s * 0.25);
                    ctx.lineTo(c, s * 0.2);
                    ctx.lineTo(c - s * 0.1, s * 0.25);
                    ctx.closePath();
                    ctx.fill();
                    // Feathers
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.03, s * 0.75);
                    ctx.lineTo(c - s * 0.12, s * 0.9);
                    ctx.lineTo(c - s * 0.03, s * 0.85);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(c + s * 0.03, s * 0.75);
                    ctx.lineTo(c + s * 0.12, s * 0.9);
                    ctx.lineTo(c + s * 0.03, s * 0.85);
                    ctx.fill();
                },

                'ability_heal': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#00ff88', 10);
                    ctx.fillStyle = '#00ff88';
                    // Cross
                    ctx.fillRect(c - s * 0.1, s * 0.2, s * 0.2, s * 0.6);
                    ctx.fillRect(s * 0.2, c - s * 0.1, s * 0.6, s * 0.2);
                    // Sparkles
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(s * 0.25, s * 0.25, s * 0.04, 0, Math.PI * 2);
                    ctx.arc(s * 0.75, s * 0.3, s * 0.03, 0, Math.PI * 2);
                    ctx.arc(s * 0.7, s * 0.75, s * 0.035, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                // === MOB ICONS ===
                'mob_slime': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#44dd44';
                    ctx.beginPath();
                    ctx.ellipse(c, c + s * 0.15, s * 0.35, s * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.1, c + s * 0.05, s * 0.05, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.1, c + s * 0.05, s * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                    // Shine
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.beginPath();
                    ctx.ellipse(c - s * 0.15, c - s * 0.05, s * 0.08, s * 0.05, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                },

                'mob_skeleton': function (ctx, s) {
                    const c = s / 2;
                    // Skull
                    ctx.fillStyle = '#f0f0e0';
                    ctx.beginPath();
                    ctx.arc(c, s * 0.35, s * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    // Jaw
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.15, s * 0.5);
                    ctx.lineTo(c, s * 0.7);
                    ctx.lineTo(c + s * 0.15, s * 0.5);
                    ctx.fill();
                    // Eye sockets
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.1, s * 0.32, s * 0.07, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.1, s * 0.32, s * 0.07, 0, Math.PI * 2);
                    ctx.fill();
                    // Nose
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.4);
                    ctx.lineTo(c - s * 0.03, s * 0.48);
                    ctx.lineTo(c + s * 0.03, s * 0.48);
                    ctx.fill();
                },

                'mob_goblin': function (ctx, s) {
                    const c = s / 2;
                    // Green head
                    ctx.fillStyle = '#4a8c3b';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    // Ears
                    ctx.beginPath();
                    ctx.ellipse(c - s * 0.35, c - s * 0.1, s * 0.15, s * 0.08, -0.5, 0, Math.PI * 2);
                    ctx.ellipse(c + s * 0.35, c - s * 0.1, s * 0.15, s * 0.08, 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.12, c - s * 0.05, s * 0.08, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.12, c - s * 0.05, s * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.12, c - s * 0.05, s * 0.04, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.12, c - s * 0.05, s * 0.04, 0, Math.PI * 2);
                    ctx.fill();
                },

                'mob_demon': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#ff0000', 8);
                    // Head
                    ctx.fillStyle = '#8b0000';
                    ctx.beginPath();
                    ctx.arc(c, c + s * 0.1, s * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Horns
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.2, c - s * 0.15);
                    ctx.lineTo(c - s * 0.35, s * 0.05);
                    ctx.lineTo(c - s * 0.1, c - s * 0.1);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(c + s * 0.2, c - s * 0.15);
                    ctx.lineTo(c + s * 0.35, s * 0.05);
                    ctx.lineTo(c + s * 0.1, c - s * 0.1);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.1, c + s * 0.05, s * 0.06, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.1, c + s * 0.05, s * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'mob_dragon': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#ff6600', 10);
                    ctx.fillStyle = '#cc4400';
                    // Head
                    ctx.beginPath();
                    ctx.moveTo(s * 0.2, c);
                    ctx.quadraticCurveTo(s * 0.1, s * 0.3, s * 0.3, s * 0.25);
                    ctx.lineTo(s * 0.8, s * 0.3);
                    ctx.lineTo(s * 0.85, c);
                    ctx.lineTo(s * 0.8, s * 0.7);
                    ctx.lineTo(s * 0.3, s * 0.75);
                    ctx.quadraticCurveTo(s * 0.1, s * 0.7, s * 0.2, c);
                    ctx.fill();
                    // Horns
                    ctx.beginPath();
                    ctx.moveTo(s * 0.35, s * 0.25);
                    ctx.lineTo(s * 0.25, s * 0.05);
                    ctx.lineTo(s * 0.4, s * 0.2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(s * 0.55, s * 0.25);
                    ctx.lineTo(s * 0.55, s * 0.05);
                    ctx.lineTo(s * 0.6, s * 0.2);
                    ctx.fill();
                    // Eye
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.ellipse(s * 0.4, c - s * 0.05, s * 0.08, s * 0.05, 0, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'mob_wolf': function (ctx, s) {
                    const c = s / 2;
                    // Head
                    ctx.fillStyle = '#555555';
                    ctx.beginPath();
                    ctx.ellipse(c, c, s * 0.3, s * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Ears
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.2, c - s * 0.15);
                    ctx.lineTo(c - s * 0.3, s * 0.1);
                    ctx.lineTo(c - s * 0.1, c - s * 0.1);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(c + s * 0.2, c - s * 0.15);
                    ctx.lineTo(c + s * 0.3, s * 0.1);
                    ctx.lineTo(c + s * 0.1, c - s * 0.1);
                    ctx.fill();
                    // Snout
                    ctx.beginPath();
                    ctx.ellipse(c, c + s * 0.2, s * 0.15, s * 0.12, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.12, c - s * 0.05, s * 0.05, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.12, c - s * 0.05, s * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                    // Nose
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(c, c + s * 0.2, s * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                },

                'mob_ghost': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#aaaaff', 12);
                    ctx.fillStyle = 'rgba(200, 200, 255, 0.7)';
                    ctx.beginPath();
                    ctx.arc(c, s * 0.35, s * 0.3, Math.PI, 0, false);
                    ctx.lineTo(c + s * 0.3, s * 0.75);
                    ctx.quadraticCurveTo(c + s * 0.2, s * 0.65, c + s * 0.1, s * 0.8);
                    ctx.quadraticCurveTo(c, s * 0.7, c - s * 0.1, s * 0.8);
                    ctx.quadraticCurveTo(c - s * 0.2, s * 0.65, c - s * 0.3, s * 0.75);
                    ctx.closePath();
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(c - s * 0.1, s * 0.35, s * 0.06, s * 0.08, 0, 0, Math.PI * 2);
                    ctx.ellipse(c + s * 0.1, s * 0.35, s * 0.06, s * 0.08, 0, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'mob_spider': function (ctx, s) {
                    const c = s / 2;
                    // Body
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.ellipse(c, c + s * 0.1, s * 0.2, s * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.arc(c, c - s * 0.2, s * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    // Legs
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 4; i++) {
                        const y = c + i * s * 0.08 - s * 0.1;
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.15, y);
                        ctx.quadraticCurveTo(c - s * 0.3, y - s * 0.1, c - s * 0.4, y + s * 0.05);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(c + s * 0.15, y);
                        ctx.quadraticCurveTo(c + s * 0.3, y - s * 0.1, c + s * 0.4, y + s * 0.05);
                        ctx.stroke();
                    }
                    // Eyes
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.05, c - s * 0.22, s * 0.03, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.05, c - s * 0.22, s * 0.03, 0, Math.PI * 2);
                    ctx.fill();
                },

                // === DUNGEON: ANCIENT RUINS ===
                'mob_stone_golem': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#7a7a7a';
                    // Blocky head
                    ctx.beginPath();
                    ctx.moveTo(s * 0.2, s * 0.2);
                    ctx.lineTo(s * 0.8, s * 0.15);
                    ctx.lineTo(s * 0.9, s * 0.8);
                    ctx.lineTo(s * 0.1, s * 0.75);
                    ctx.closePath();
                    ctx.fill();
                    // Cracks
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(s * 0.3, s * 0.3);
                    ctx.lineTo(s * 0.5, s * 0.5);
                    ctx.lineTo(s * 0.4, s * 0.7);
                    ctx.stroke();
                    // Glowing eyes (Orange)
                    IconRenderer.helpers.glow(ctx, '#ff6600', 8);
                    ctx.fillStyle = '#ff6600';
                    ctx.fillRect(s * 0.3, s * 0.35, s * 0.1, s * 0.1);
                    ctx.fillRect(s * 0.6, s * 0.35, s * 0.1, s * 0.1);
                },

                'mob_ancient_sentinel': function (ctx, s) {
                    const c = s / 2;
                    // Eye of the sentinel
                    ctx.fillStyle = '#4a4a4a';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.lineTo(s * 0.9, c);
                    ctx.lineTo(c, s * 0.9);
                    ctx.lineTo(s * 0.1, c);
                    ctx.closePath();
                    ctx.fill();
                    // Robotic iris
                    ctx.strokeStyle = '#00d9ff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.15, 0, Math.PI * 2);
                    ctx.stroke();
                    IconRenderer.helpers.glow(ctx, '#00d9ff', 12);
                    ctx.fillStyle = '#00d9ff';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                },

                'mob_taurha_giant': function (ctx, s) {
                    const c = s / 2;
                    // Main stone body (sand-rock + dark bricks)
                    const body = ctx.createLinearGradient(0, 0, s, s);
                    body.addColorStop(0, '#b69a72');
                    body.addColorStop(0.55, '#8f7352');
                    body.addColorStop(1, '#4a3627');
                    ctx.fillStyle = body;
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.32, s * 0.16);
                    ctx.lineTo(c + s * 0.32, s * 0.16);
                    ctx.lineTo(c + s * 0.4, s * 0.62);
                    ctx.lineTo(c, s * 0.92);
                    ctx.lineTo(c - s * 0.4, s * 0.62);
                    ctx.closePath();
                    ctx.fill();

                    // Dark brick seams
                    ctx.strokeStyle = '#3a281c';
                    ctx.lineWidth = Math.max(2, s * 0.03);
                    for (let i = 0; i < 4; i++) {
                        const y = s * (0.28 + i * 0.14);
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.3, y);
                        ctx.lineTo(c + s * 0.3, y);
                        ctx.stroke();
                    }

                    // Crown with blue glyphs
                    ctx.fillStyle = '#2a1f16';
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.26, s * 0.14);
                    ctx.lineTo(c - s * 0.18, s * 0.02);
                    ctx.lineTo(c - s * 0.08, s * 0.12);
                    ctx.lineTo(c, s * 0.01);
                    ctx.lineTo(c + s * 0.08, s * 0.12);
                    ctx.lineTo(c + s * 0.18, s * 0.02);
                    ctx.lineTo(c + s * 0.26, s * 0.14);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#33d9ff';
                    for (let i = 0; i < 5; i++) {
                        const gx = c - s * 0.16 + i * s * 0.08;
                        const gy = s * 0.1;
                        ctx.fillRect(gx, gy, s * 0.03, s * 0.03);
                    }

                    // White glowing eyes
                    IconRenderer.helpers.glow(ctx, '#ffffff', 12);
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.12, s * 0.44, s * 0.055, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.12, s * 0.44, s * 0.055, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);

                    // Bright blue glyph lines on torso
                    ctx.strokeStyle = '#2fe8ff';
                    ctx.lineWidth = Math.max(2, s * 0.025);
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.1, s * 0.56);
                    ctx.lineTo(c - s * 0.02, s * 0.5);
                    ctx.lineTo(c + s * 0.06, s * 0.58);
                    ctx.moveTo(c - s * 0.13, s * 0.68);
                    ctx.lineTo(c + s * 0.13, s * 0.68);
                    ctx.stroke();

                    // Giant pillar weapon
                    ctx.save();
                    ctx.translate(c + s * 0.28, c + s * 0.06);
                    ctx.rotate(-0.22);
                    ctx.fillStyle = '#5d4631';
                    ctx.fillRect(-s * 0.045, -s * 0.28, s * 0.09, s * 0.56);
                    ctx.fillStyle = '#8f7352';
                    ctx.fillRect(-s * 0.06, -s * 0.31, s * 0.12, s * 0.07);
                    ctx.fillRect(-s * 0.06, s * 0.24, s * 0.12, s * 0.07);
                    ctx.strokeStyle = '#2fe8ff';
                    ctx.lineWidth = Math.max(1.5, s * 0.02);
                    ctx.beginPath();
                    ctx.moveTo(-s * 0.025, -s * 0.2);
                    ctx.lineTo(s * 0.025, -s * 0.16);
                    ctx.moveTo(-s * 0.025, s * 0.14);
                    ctx.lineTo(s * 0.025, s * 0.18);
                    ctx.stroke();
                    ctx.restore();
                },

                // === DUNGEON: DRAGON'S CAVE ===
                'mob_fire_drake': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#8b0000';
                    ctx.beginPath();
                    ctx.moveTo(s * 0.1, c);
                    ctx.lineTo(s * 0.4, s * 0.2);
                    ctx.lineTo(s * 0.9, s * 0.4);
                    ctx.lineTo(s * 0.4, s * 0.8);
                    ctx.closePath();
                    ctx.fill();
                    // Flaming mane
                    IconRenderer.helpers.glow(ctx, '#ff6600', 10);
                    ctx.fillStyle = '#ff4400';
                    ctx.beginPath();
                    ctx.moveTo(s * 0.2, s * 0.3);
                    ctx.lineTo(s * 0.3, s * 0.1);
                    ctx.lineTo(s * 0.4, s * 0.25);
                    ctx.fill();
                },

                'mob_arcane_wisp': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#a855f7', 15);
                    ctx.fillStyle = 'rgba(168, 85, 247, 0.6)';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Inner core
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    // Orbiting rings
                    ctx.strokeStyle = '#e9d5ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(c, c, s * 0.4, s * 0.15, Math.PI / 4, 0, Math.PI * 2);
                    ctx.stroke();
                },

                'mob_shadow_assassin': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#1a1a1a';
                    // Cloaked figue
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.lineTo(s * 0.8, s * 0.9);
                    ctx.lineTo(s * 0.2, s * 0.9);
                    ctx.closePath();
                    ctx.fill();
                    // Glowing purple eyes
                    IconRenderer.helpers.glow(ctx, '#d946ef', 8);
                    ctx.fillStyle = '#d946ef';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.08, s * 0.4, 3, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.08, s * 0.4, 3, 0, Math.PI * 2);
                    ctx.fill();
                    // Blade
                    ctx.strokeStyle = '#4b5563';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(s * 0.7, s * 0.6);
                    ctx.lineTo(s * 0.9, s * 0.3);
                    ctx.stroke();
                },

                'mob_ancient_dragon': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#1e3a8a';
                    // Massive head
                    ctx.beginPath();
                    ctx.moveTo(s * 0.1, s * 0.4);
                    ctx.lineTo(s * 0.3, s * 0.1);
                    ctx.lineTo(s * 0.9, s * 0.3);
                    ctx.lineTo(s * 0.8, s * 0.7);
                    ctx.lineTo(s * 0.2, s * 0.8);
                    ctx.closePath();
                    ctx.fill();
                    // Ice scales
                    ctx.strokeStyle = '#60a5fa';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(s * 0.4, s * 0.3);
                    ctx.lineTo(s * 0.6, s * 0.5);
                    ctx.stroke();
                    // Crystal eyes
                    IconRenderer.helpers.glow(ctx, '#fff', 10);
                    ctx.fillStyle = '#fff';
                },

                'mob_aether_dragon': function (ctx, s) {
                    const c = s / 2;
                    // Celestial/Ethereal Dragon
                    const grad = ctx.createRadialGradient(c, c, 0, c, c, s * 0.5);
                    grad.addColorStop(0, '#fff');
                    grad.addColorStop(0.5, '#00d9ff');
                    grad.addColorStop(1, '#7c3aed');
                    ctx.fillStyle = grad;
                    IconRenderer.helpers.glow(ctx, '#00d9ff', 20);

                    // Head shape
                    ctx.beginPath();
                    ctx.moveTo(s * 0.1, c);
                    ctx.bezierCurveTo(s * 0.2, s * 0.1, s * 0.8, s * 0.1, s * 0.9, c);
                    ctx.bezierCurveTo(s * 0.8, s * 0.9, s * 0.2, s * 0.9, s * 0.1, c);
                    ctx.fill();

                    // Energy horns
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(s * 0.3, s * 0.3);
                    ctx.lineTo(s * 0.15, s * 0.05);
                    ctx.stroke();
                },

                'mob_water_elemental': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = 'rgba(0, 150, 255, 0.7)';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.2);
                    ctx.bezierCurveTo(s * 0.8, s * 0.3, s * 0.9, s * 0.6, c, s * 0.9);
                    ctx.bezierCurveTo(s * 0.1, s * 0.6, s * 0.2, s * 0.3, c, s * 0.2);
                    ctx.fill();
                    // Bubbles
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.1, c, s * 0.05, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.1, c + s * 0.1, s * 0.03, 0, Math.PI * 2);
                    ctx.fill();
                },

                'mob_prism_wisp': function (ctx, s) {
                    const c = s / 2;
                    ctx.save();
                    IconRenderer.helpers.glow(ctx, '#a78bfa', 14);
                    const ring = ctx.createRadialGradient(c, c, s * 0.05, c, c, s * 0.34);
                    ring.addColorStop(0, 'rgba(255,255,255,0.96)');
                    ring.addColorStop(0.5, 'rgba(167,139,250,0.85)');
                    ring.addColorStop(1, 'rgba(30,41,59,0.08)');
                    ctx.fillStyle = ring;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.32, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#f0abfc';
                    ctx.lineWidth = Math.max(1.5, s * 0.02);
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.2);
                    ctx.lineTo(c + s * 0.16, c);
                    ctx.lineTo(c, s * 0.8);
                    ctx.lineTo(c - s * 0.16, c);
                    ctx.closePath();
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                    ctx.restore();
                },

                'mob_frostbound_sentinel': function (ctx, s) {
                    const c = s / 2;
                    ctx.save();
                    const bodyGrad = ctx.createLinearGradient(s * 0.2, s * 0.16, s * 0.8, s * 0.84);
                    bodyGrad.addColorStop(0, '#dbeafe');
                    bodyGrad.addColorStop(1, '#3b82f6');
                    ctx.fillStyle = bodyGrad;
                    ctx.beginPath();
                    ctx.roundRect(s * 0.22, s * 0.18, s * 0.56, s * 0.64, s * 0.08);
                    ctx.fill();
                    IconRenderer.helpers.glow(ctx, '#93c5fd', 10);
                    ctx.fillStyle = '#0ea5e9';
                    ctx.fillRect(s * 0.33, s * 0.34, s * 0.34, s * 0.08);
                    ctx.fillRect(s * 0.33, s * 0.52, s * 0.34, s * 0.08);
                    IconRenderer.helpers.clearGlow(ctx);
                    ctx.restore();
                },

                'mob_magma_golem': function (ctx, s) {
                    const c = s / 2;
                    ctx.save();
                    ctx.fillStyle = '#3f2415';
                    ctx.beginPath();
                    ctx.roundRect(s * 0.18, s * 0.2, s * 0.64, s * 0.62, s * 0.1);
                    ctx.fill();
                    IconRenderer.helpers.glow(ctx, '#fb923c', 12);
                    ctx.strokeStyle = '#f97316';
                    ctx.lineWidth = Math.max(2, s * 0.03);
                    ctx.beginPath();
                    ctx.moveTo(s * 0.28, s * 0.3);
                    ctx.lineTo(s * 0.46, s * 0.46);
                    ctx.lineTo(s * 0.35, s * 0.68);
                    ctx.moveTo(s * 0.7, s * 0.3);
                    ctx.lineTo(s * 0.58, s * 0.5);
                    ctx.lineTo(s * 0.7, s * 0.72);
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                    ctx.restore();
                },

                'mob_ronin_warrior': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#1a1a1a';
                    // Samurai helmet (Kabuto)
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.35, Math.PI, 0);
                    ctx.lineTo(c + s * 0.35, c + s * 0.2);
                    ctx.lineTo(c - s * 0.35, c + s * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    // Crimson eyes
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(c - s * 0.15, c - s * 0.05, s * 0.1, 4);
                    ctx.fillRect(c + s * 0.05, c - s * 0.05, s * 0.1, 4);
                },

                'mob_combat_drone': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#2d3436';
                    // Hexagonal body
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const a = i * Math.PI / 3;
                        ctx.lineTo(c + Math.cos(a) * s * 0.35, c + Math.sin(a) * s * 0.35);
                    }
                    ctx.closePath();
                    ctx.fill();
                    // Blue reactor core
                    IconRenderer.helpers.glow(ctx, '#00d9ff', 10);
                    ctx.fillStyle = '#00d9ff';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                },

                'mob_toxic_zephyr': function (ctx, s) {
                    const c = s / 2;
                    ctx.strokeStyle = '#32cd32';
                    ctx.lineWidth = 3;
                    // Wind swirl
                    ctx.beginPath();
                    for (let a = 0; a < Math.PI * 4; a += 0.2) {
                        const r = (a / (Math.PI * 4)) * s * 0.4;
                        ctx.lineTo(c + Math.cos(a) * r, c + Math.sin(a) * r);
                    }
                    ctx.stroke();
                    // Toxic particles
                    ctx.fillStyle = '#7fff00';
                    for (let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        ctx.arc(c + Math.random() * s * 0.4 - s * 0.2, c + Math.random() * s * 0.4 - s * 0.2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                },

                'mob_radioactive_cyclone': function (ctx, s) {
                    const c = s / 2;
                    ctx.strokeStyle = '#adff2f';
                    ctx.lineWidth = 4;
                    // Double vortex
                    for (let i = 0; i < 2; i++) {
                        ctx.save();
                        ctx.translate(c, c);
                        ctx.rotate(i * Math.PI);
                        ctx.beginPath();
                        for (let a = 0; a < Math.PI * 2; a += 0.1) {
                            const r = (a / (Math.PI * 2)) * s * 0.45;
                            ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                        }
                        ctx.stroke();
                        ctx.restore();
                    }
                },

                'mob_blood_reaver': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#8b0000';
                    // Menacing hood
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.bezierCurveTo(c + s * 0.3, s * 0.2, c + s * 0.35, s * 0.9, c, s * 0.85);
                    ctx.bezierCurveTo(c - s * 0.35, s * 0.9, c - s * 0.3, s * 0.2, c, s * 0.1);
                    ctx.fill();
                    // Red slit eyes
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.15, s * 0.4); ctx.lineTo(c - s * 0.05, s * 0.42); ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(c + s * 0.05, s * 0.42); ctx.lineTo(c + s * 0.15, s * 0.4); ctx.stroke();
                },

                'mob_axe_thrower': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#4a3728';
                    // Axe shape
                    ctx.fillRect(c - s * 0.05, s * 0.2, s * 0.1, s * 0.6);
                    ctx.fillStyle = '#888';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.2);
                    ctx.lineTo(c + s * 0.3, s * 0.1);
                    ctx.lineTo(c + s * 0.3, s * 0.4);
                    ctx.lineTo(c, s * 0.3);
                    ctx.closePath();
                    ctx.fill();
                },

                'mob_smoke_phantom': function (ctx, s) {
                    const c = s / 2;
                    const grad = ctx.createRadialGradient(c, c, 0, c, c, s * 0.4);
                    grad.addColorStop(0, 'rgba(100, 100, 100, 0.8)');
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                },

                'mob_tornado_apprentice': function (ctx, s) {
                    const c = s / 2;
                    ctx.strokeStyle = '#87ceeb';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let y = s * 0.2; y < s * 0.8; y += 4) {
                        const w = (y - s * 0.2) * 0.5;
                        ctx.ellipse(c, y, w, w * 0.3, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                },

                'mob_necromancer': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#4b0082';
                    // Tattered robes
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.lineTo(s * 0.8, s * 0.9);
                    ctx.lineTo(s * 0.2, s * 0.9);
                    ctx.closePath();
                    ctx.fill();
                    // Green soul in hand
                    IconRenderer.helpers.glow(ctx, '#00ff00', 10);
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(s * 0.7, s * 0.6, s * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                },

                'mob_tornado_master': function (ctx, s) {
                    // Similar to tornado apprentice but larger/more detail
                    const c = s / 2;
                    ctx.strokeStyle = '#00bfff';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    for (let y = s * 0.1; y < s * 0.9; y += 5) {
                        const w = (y - s * 0.1) * 0.6;
                        ctx.ellipse(c, y, w, w * 0.4, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                },

                'mob_king_of_skeletons': function (ctx, s) {
                    const c = s / 2;
                    // Skull with crown
                    ctx.fillStyle = '#f0f0e0';
                    ctx.beginPath();
                    ctx.arc(c, s * 0.4, s * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.2, s * 0.25);
                    ctx.lineTo(c - s * 0.2, s * 0.1);
                    ctx.lineTo(c - s * 0.05, s * 0.2);
                    ctx.lineTo(c, s * 0.05);
                    ctx.lineTo(c + s * 0.05, s * 0.2);
                    ctx.lineTo(c + s * 0.2, s * 0.1);
                    ctx.lineTo(c + s * 0.2, s * 0.25);
                    ctx.closePath();
                    ctx.fill();
                },

                'mob_storm_titan': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#4682b4';
                    ctx.beginPath();
                    ctx.roundRect(c - s * 0.3, s * 0.2, s * 0.6, s * 0.7, 10);
                    ctx.fill();
                    IconRenderer.helpers.glow(ctx, '#fff', 15);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.2, s * 0.4); ctx.lineTo(c + s * 0.2, s * 0.4); ctx.stroke();
                },

                'mob_storm_archon': function (ctx, s) {
                    const c = s / 2;
                    ctx.save();
                    const plate = ctx.createLinearGradient(s * 0.2, s * 0.16, s * 0.8, s * 0.84);
                    plate.addColorStop(0, '#0ea5e9');
                    plate.addColorStop(1, '#1d4ed8');
                    ctx.fillStyle = plate;
                    ctx.beginPath();
                    ctx.roundRect(s * 0.2, s * 0.16, s * 0.6, s * 0.68, s * 0.1);
                    ctx.fill();
                    IconRenderer.helpers.glow(ctx, '#facc15', 12);
                    ctx.strokeStyle = '#facc15';
                    ctx.lineWidth = Math.max(2, s * 0.03);
                    ctx.beginPath();
                    ctx.moveTo(c + s * 0.05, s * 0.2);
                    ctx.lineTo(c - s * 0.04, c);
                    ctx.lineTo(c + s * 0.02, c);
                    ctx.lineTo(c - s * 0.07, s * 0.8);
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                    ctx.restore();
                },

                'mob_crystal_hydra': function (ctx, s) {
                    const c = s / 2;
                    ctx.save();
                    const core = ctx.createRadialGradient(c, c, s * 0.06, c, c, s * 0.46);
                    core.addColorStop(0, '#f5f3ff');
                    core.addColorStop(0.45, '#c084fc');
                    core.addColorStop(1, '#312e81');
                    ctx.fillStyle = core;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.glow(ctx, '#ddd6fe', 12);
                    ctx.fillStyle = '#ede9fe';
                    const heads = [
                        { x: c - s * 0.18, y: c - s * 0.12 },
                        { x: c, y: c - s * 0.2 },
                        { x: c + s * 0.18, y: c - s * 0.12 }
                    ];
                    heads.forEach((h) => {
                        ctx.beginPath();
                        ctx.moveTo(h.x, h.y - s * 0.1);
                        ctx.lineTo(h.x + s * 0.08, h.y + s * 0.04);
                        ctx.lineTo(h.x - s * 0.08, h.y + s * 0.04);
                        ctx.closePath();
                        ctx.fill();
                    });
                    IconRenderer.helpers.clearGlow(ctx);
                    ctx.restore();
                },

                // GENERIC ABILITY ICONS
                'ability_sword': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1); // Tip
                    ctx.lineTo(c + s * 0.1, s * 0.7);
                    ctx.lineTo(c, s * 0.8);
                    ctx.lineTo(c - s * 0.1, s * 0.7);
                    ctx.fill();
                    ctx.fillStyle = '#8B4513'; // Hilt
                    ctx.fillRect(c - s * 0.15, s * 0.7, s * 0.3, s * 0.05); // Guard
                    ctx.fillRect(c - s * 0.05, s * 0.75, s * 0.1, s * 0.2); // Handle
                },
                'ability_shield': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#4682B4';
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.3, s * 0.2);
                    ctx.lineTo(c + s * 0.3, s * 0.2);
                    ctx.lineTo(c + s * 0.3, s * 0.6);
                    ctx.quadraticCurveTo(c, s * 0.9, c - s * 0.3, s * 0.6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#FFD700'; // Gold rim
                    ctx.lineWidth = 3;
                    ctx.stroke();
                },
                'ability_fire': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#FF4500';
                    IconRenderer.helpers.glow(ctx, '#FFD700', 10);
                    ctx.beginPath();
                    ctx.arc(c, s * 0.6, s * 0.25, 0, Math.PI, false);
                    ctx.quadraticCurveTo(c + s * 0.35, s * 0.4, c, s * 0.1);
                    ctx.quadraticCurveTo(c - s * 0.35, s * 0.4, c - s * 0.25, s * 0.6);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'ability_ice': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#00BFFF';
                    IconRenderer.helpers.glow(ctx, '#E0FFFF', 10);
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const a = i * Math.PI / 3;
                        ctx.moveTo(c, c);
                        ctx.lineTo(c + Math.cos(a) * s * 0.35, c + Math.sin(a) * s * 0.35);
                    }
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'ability_arrow': function (ctx, s) {
                    const c = s / 2;
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(s * 0.2, c + s * 0.2);
                    ctx.lineTo(s * 0.8, c - s * 0.2);
                    ctx.stroke();
                    // Arrowhead
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(s * 0.8, c - s * 0.2);
                    ctx.lineTo(s * 0.7, c - s * 0.1);
                    ctx.lineTo(s * 0.6, c - s * 0.2);
                    ctx.fill();
                },
                'ability_lightning': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#FFD700';
                    IconRenderer.helpers.glow(ctx, '#FFFFE0', 10);
                    ctx.beginPath();
                    ctx.moveTo(c + s * 0.1, s * 0.1);
                    ctx.lineTo(c - s * 0.1, s * 0.5);
                    ctx.lineTo(c + s * 0.1, s * 0.5);
                    ctx.lineTo(c - s * 0.1, s * 0.9);
                    ctx.lineTo(c + s * 0.2, s * 0.4);
                    ctx.lineTo(c, s * 0.4);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'ability_heal': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#32CD32';
                    IconRenderer.helpers.glow(ctx, '#98FB98', 10);
                    // Cross
                    ctx.fillRect(c - s * 0.1, s * 0.2, s * 0.2, s * 0.6);
                    ctx.fillRect(s * 0.2, c - s * 0.1, s * 0.6, s * 0.2);
                    IconRenderer.helpers.clearGlow(ctx);
                },

                // Ability types added
                'ability_dark': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#9d4edd', 10);
                    ctx.fillStyle = '#2d004d';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#9d4edd';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    // Eye
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.ellipse(c, c, s * 0.2, s * 0.1, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'ability_light': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#ffd700', 12);
                    ctx.fillStyle = '#fff9c4';
                    // Sun rays
                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.translate(c, c);
                        ctx.rotate(i * Math.PI / 4);
                        ctx.beginPath();
                        ctx.moveTo(0, -s * 0.4);
                        ctx.lineTo(s * 0.05, -s * 0.2);
                        ctx.lineTo(-s * 0.05, -s * 0.2);
                        ctx.fill();
                        ctx.restore();
                    }
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'ability_wind': function (ctx, s) {
                    const c = s / 2;
                    ctx.strokeStyle = '#39ff14';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    for (let i = 0; i < 3; i++) {
                        const r = s * (0.1 + i * 0.15);
                        ctx.arc(c, c, r, i * 0.5, i * 0.5 + Math.PI, false);
                    }
                    ctx.stroke();
                },

                'ability_poison': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#39ff14', 10);
                    ctx.fillStyle = '#1a5e00';
                    // Bubble/Drop
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.quadraticCurveTo(s * 0.8, s * 0.6, c, s * 0.9);
                    ctx.quadraticCurveTo(s * 0.2, s * 0.6, c, s * 0.1);
                    ctx.fill();
                    // Bubbles
                    ctx.fillStyle = 'rgba(255,255,255,0.4)';
                    ctx.beginPath();
                    ctx.arc(c - s * 0.1, s * 0.5, s * 0.05, 0, Math.PI * 2);
                    ctx.arc(c + s * 0.1, s * 0.7, s * 0.03, 0, Math.PI * 2);
                    ctx.fill();
                    IconRenderer.helpers.clearGlow(ctx);
                },

                'ability_earth': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#8b4513';
                    // Jagged rock
                    ctx.beginPath();
                    ctx.moveTo(c, s * 0.1);
                    ctx.lineTo(s * 0.8, s * 0.3);
                    ctx.lineTo(s * 0.9, s * 0.7);
                    ctx.lineTo(c, s * 0.95);
                    ctx.lineTo(s * 0.1, s * 0.7);
                    ctx.lineTo(s * 0.2, s * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    // Cracks
                    ctx.strokeStyle = '#5d2906';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(s * 0.4, s * 0.3); ctx.lineTo(s * 0.6, s * 0.6);
                    ctx.stroke();
                },

                // Specific Mobs from Raid selection
                'mob_tornado_apprentice': function (ctx, s) {
                    const c = s / 2;
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.ellipse(c, c, s * 0.1 + i * s * 0.1, s * 0.05 + i * s * 0.02, i * 0.8, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                },
                'mob_tornado_master': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#00ff88', 15);
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 5;
                    for (let i = 0; i < 6; i++) {
                        ctx.beginPath();
                        ctx.ellipse(c, c, s * 0.1 + i * s * 0.12, s * 0.05 + i * s * 0.03, -i * 0.4, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'mob_shogun_lord': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#8b0000';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    // Helmet horns
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(c - s * 0.2, c - s * 0.2); ctx.lineTo(c - s * 0.3, s * 0.1); ctx.lineTo(c - s * 0.1, c - s * 0.25); ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(c + s * 0.2, c - s * 0.2); ctx.lineTo(c + s * 0.3, s * 0.1); ctx.lineTo(c + s * 0.1, c - s * 0.25); ctx.fill();
                },
                'mob_mech_titan': function (ctx, s) {
                    const c = s / 2;
                    ctx.fillStyle = '#555';
                    ctx.fillRect(c - s * 0.3, c - s * 0.3, s * 0.6, s * 0.6);
                    ctx.fillStyle = '#00ffff';
                    IconRenderer.helpers.glow(ctx, '#00ffff', 10);
                    ctx.fillRect(c - s * 0.15, c - s * 0.15, s * 0.3, s * 0.1);
                    IconRenderer.helpers.clearGlow(ctx);
                },
                'mob_tempest_lord': function (ctx, s) {
                    const c = s / 2;
                    IconRenderer.helpers.glow(ctx, '#39ff14', 20);
                    ctx.fillStyle = '#1a5e00';
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#39ff14';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.arc(c, c, s * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        };

        // === ICON INTEGRATION HELPER ===
        // Creates an img element with the rendered icon
        IconRenderer.createImgElement = function (iconId, size = 48, className = 'icon-2d') {
            const img = document.createElement('img');
            img.src = this.createIcon(iconId, size);
            img.className = className;
            img.alt = iconId;
            img.style.width = size + 'px';
            img.style.height = size + 'px';
            return img;
        };

        // Gets icon for any game entity (class, character, fruit, ability)
        IconRenderer.getIconFor = function (entity) {
            if (!entity) return null;

            // Try direct ID match first
            if (this.icons[entity.id]) {
                return entity.id;
            }

            // Try type-based matching
            if (entity.type === 'character' && this.icons['char_' + entity.id.replace('char_', '')]) {
                return entity.id;
            }
            if (entity.type === 'class' && this.icons[entity.id]) {
                return entity.id;
            }
            if (entity.type === 'fruit' && this.icons[entity.id]) {
                return entity.id;
            }

            // Fallback to ability type icons
            if (entity.effectId) {
                const eid = entity.effectId.toLowerCase();
                if (eid.includes('fire') || eid.includes('flame') || eid.includes('inferno') || eid.includes('ember') || eid.includes('pyra')) return 'ability_fire';
                if (eid.includes('ice') || eid.includes('freeze') || eid.includes('glacier') || eid.includes('frost')) return 'ability_ice';
                if (eid.includes('lightning') || eid.includes('storm') || eid.includes('thunder') || eid.includes('bolt') || eid.includes('volt') || eid.includes('tempest')) return 'ability_lightning';
                if (eid.includes('shield') || eid.includes('armor') || eid.includes('testudo') || eid.includes('barrier') || eid.includes('protection') || eid.includes('wall')) return 'ability_shield';
                if (eid.includes('sword') || eid.includes('blade') || eid.includes('slash') || eid.includes('cut') || eid.includes('gladius') || eid.includes('iaido') || eid.includes('strike') || eid.includes('claw')) return 'ability_sword';
                if (eid.includes('arrow') || eid.includes('bow') || eid.includes('pilum') || eid.includes('bolt') || eid.includes('dory') || eid.includes('spear')) return 'ability_arrow';
                if (eid.includes('heal') || eid.includes('regen') || eid.includes('aura') || eid.includes('santuario') || eid.includes('rebirth')) return 'ability_heal';
                if (eid.includes('shadow') || eid.includes('dark') || eid.includes('void') || eid.includes('abyss') || eid.includes('smoke') || eid.includes('phantom')) return 'ability_dark';
                if (eid.includes('star') || eid.includes('cosmic') || eid.includes('radiance') || eid.includes('light') || eid.includes('divine') || eid.includes('sun')) return 'ability_light';
                if (eid.includes('wind') || eid.includes('cyclone') || eid.includes('tornado') || eid.includes('zephyr')) return 'ability_wind';
                if (eid.includes('poison') || eid.includes('toxic') || eid.includes('radioactive') || eid.includes('acid') || eid.includes('plague')) return 'ability_poison';
                if (eid.includes('quake') || eid.includes('smash') || eid.includes('earth') || eid.includes('stone') || eid.includes('rock') || eid.includes('fissure')) return 'ability_earth';
            }

            return null; // Will use default icon
        };

        // Generates HTML string for displaying a 2D icon
        IconRenderer.getIconHTML = function (entityOrId, size = 48, className = 'icon-2d') {
            let iconId;

            if (typeof entityOrId === 'string') {
                iconId = entityOrId;
            } else if (entityOrId && typeof entityOrId === 'object') {
                iconId = this.getIconFor(entityOrId) || entityOrId.id;
            }

            // Use any resolvable icon (direct table OR dynamic resolver).
            if (iconId) {
                const dataUrl = this.createIcon(iconId, size);
                return `<img src="${dataUrl}" class="${className}" alt="${iconId}" style="width: ${size}px; height: ${size}px; image-rendering: crisp-edges;">`;
            }

            // Return default canvas icon
            const dataUrl = this.createIcon('default', size);
            return `<img src="${dataUrl}" class="${className}" alt="icon" style="width: ${size}px; height: ${size}px;">`;
        };

        // Replaces emoji icons with 2D canvas icons in the DOM
        IconRenderer.upgradeIconsInElement = function (container) {
            if (!container) return;

            // Find elements with role-card-icon class
            container.querySelectorAll('.role-card-icon').forEach(el => {
                const roleId = el.closest('[data-role-id]')?.dataset.roleId;
                if (roleId && this.icons[roleId]) {
                    el.innerHTML = this.getIconHTML(roleId, 40);
                }
            });

            // Find elements with mob-card-icon class
            container.querySelectorAll('.mob-card-icon').forEach(el => {
                const mobId = el.closest('[data-mob-id]')?.dataset.mobId;
                if (mobId && this.icons[mobId]) {
                    el.innerHTML = this.getIconHTML(mobId, 48);
                }
            });
        };

        // Auto-generate ability 2D icons for class/master-class skills missing explicit renderers
        const Ability2DModelFactory = {
            hashFor(iconId) {
                const id = String(iconId || '').toLowerCase();
                let hash = 2166136261;
                for (let i = 0; i < id.length; i++) {
                    hash ^= id.charCodeAt(i);
                    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
                }
                return hash >>> 0;
            },

            themeFor(iconId) {
                const id = String(iconId || '').toLowerCase();
                const palette = {
                    fire: { bgA: '#2b0f08', bgB: '#5b1c0a', ring: '#ff7a2f', glow: '#ff4b1f' },
                    shield: { bgA: '#0d1a2d', bgB: '#17385a', ring: '#62b9ff', glow: '#2a8fff' },
                    blade: { bgA: '#17151a', bgB: '#3a2a31', ring: '#f2c8da', glow: '#ef8db4' },
                    wind: { bgA: '#0b1f2a', bgB: '#12425d', ring: '#7be8ff', glow: '#3ecfff' },
                    dark: { bgA: '#130f21', bgB: '#2b1d44', ring: '#b388ff', glow: '#875eff' },
                    toxic: { bgA: '#111f12', bgB: '#234d1f', ring: '#7fff63', glow: '#43d94d' },
                    earth: { bgA: '#21150f', bgB: '#4d3320', ring: '#d9a46b', glow: '#c88042' },
                    tech: { bgA: '#0b1724', bgB: '#153347', ring: '#62f0ff', glow: '#24d2ff' },
                    holy: { bgA: '#241c0f', bgB: '#5a4522', ring: '#ffd769', glow: '#ffbf33' },
                    arcane: { bgA: '#161227', bgB: '#322552', ring: '#c387ff', glow: '#a75dff' }
                };

                if (id.includes('fire') || id.includes('flame') || id.includes('magma') || id.includes('draconic') || id.includes('mars') || id.includes('apocalypse') || id.includes('fury') || id.includes('rage') || id.includes('burn') || id.includes('phoenix')) return { kind: 'fire', ...palette.fire };
                if (id.includes('shield') || id.includes('testudo') || id.includes('phalanx') || id.includes('barrier') || id.includes('wall') || id.includes('guardian') || id.includes('fortress')) return { kind: 'shield', ...palette.shield };
                if (id.includes('gladius') || id.includes('blade') || id.includes('slash') || id.includes('dory') || id.includes('pilum') || id.includes('spear') || id.includes('thermopylae') || id.includes('charge') || id.includes('aroo') || id.includes('molon') || id.includes('claw') || id.includes('cut') || id.includes('strike')) return { kind: 'blade', ...palette.blade };
                if (id.includes('wind') || id.includes('ciclon') || id.includes('ventoso') || id.includes('tornado') || id.includes('storm') || id.includes('tempest') || id.includes('pressure') || id.includes('barrage') || id.includes('air') || id.includes('gust') || id.includes('zephyr')) return { kind: 'wind', ...palette.wind };
                if (id.includes('shadow') || id.includes('void') || id.includes('dark') || id.includes('night') || id.includes('abyss') || id.includes('death') || id.includes('smoke') || id.includes('ninja') || id.includes('phantom') || id.includes('underworld')) return { kind: 'dark', ...palette.dark };
                if (id.includes('toxic') || id.includes('radioactive') || id.includes('plague') || id.includes('poison') || id.includes('venom')) return { kind: 'toxic', ...palette.toxic };
                if (id.includes('tectonic') || id.includes('earth') || id.includes('mountain') || id.includes('geological') || id.includes('fissure') || id.includes('crystal') || id.includes('stone') || id.includes('sand') || id.includes('quake')) return { kind: 'earth', ...palette.earth };
                if (id.includes('plasma') || id.includes('drone') || id.includes('orbital') || id.includes('mech') || id.includes('photon') || id.includes('singularity') || id.includes('rapid') || id.includes('grenade') || id.includes('gun') || id.includes('cyber') || id.includes('laser')) return { kind: 'tech', ...palette.tech };
                if (id.includes('divine') || id.includes('victoria') || id.includes('jupiter') || id.includes('rome') || id.includes('praetorian') || id.includes('ankh') || id.includes('judgment') || id.includes('aquila') || id.includes('legio') || id.includes('anubis') || id.includes('imperator') || id.includes('ares') || id.includes('avatar') || id.includes('sacred') || id.includes('soul')) return { kind: 'holy', ...palette.holy };
                return { kind: 'arcane', ...palette.arcane };
            },

            motifFor(iconId) {
                const hash = this.hashFor(iconId);
                return {
                    hash,
                    ringStyle: hash % 4,
                    cornerStyle: (hash >>> 3) % 4,
                    lineStyle: (hash >>> 6) % 3,
                    glyphVariant: (hash >>> 9) % 4,
                    innerMark: (hash >>> 12) % 5,
                    rotation: ((hash >>> 17) % 360) * (Math.PI / 180)
                };
            },

            drawBase(ctx, s, theme, motif) {
                const c = s / 2;
                const dir = motif.rotation;
                const x0 = c + Math.cos(dir + Math.PI) * s * 0.65;
                const y0 = c + Math.sin(dir + Math.PI) * s * 0.65;
                const x1 = c + Math.cos(dir) * s * 0.65;
                const y1 = c + Math.sin(dir) * s * 0.65;
                const g = ctx.createLinearGradient(x0, y0, x1, y1);
                g.addColorStop(0, theme.bgA);
                g.addColorStop(1, theme.bgB);
                const radiusMap = [0.14, 0.18, 0.22, 0.26];
                const r = s * radiusMap[motif.cornerStyle];

                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.roundRect(s * 0.08, s * 0.08, s * 0.84, s * 0.84, r);
                ctx.fill();

                ctx.strokeStyle = theme.ring;
                ctx.lineWidth = Math.max(2, s * 0.05);
                ctx.globalAlpha = 0.92;
                if (motif.lineStyle === 0) {
                    ctx.stroke();
                } else if (motif.lineStyle === 1) {
                    ctx.setLineDash([s * 0.09, s * 0.05]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else {
                    ctx.globalAlpha = 0.8;
                    ctx.stroke();
                    ctx.globalAlpha = 0.5;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = Math.max(1, s * 0.02);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;

                ctx.save();
                ctx.translate(c, c);
                ctx.rotate(motif.rotation * 0.6);
                ctx.strokeStyle = theme.ring;
                ctx.lineWidth = Math.max(1.5, s * 0.03);
                ctx.globalAlpha = 0.8;
                if (motif.ringStyle === 0) {
                    ctx.beginPath();
                    ctx.arc(0, 0, s * 0.31, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (motif.ringStyle === 1) {
                    ctx.beginPath();
                    ctx.arc(0, 0, s * 0.31, -Math.PI * 0.85, -Math.PI * 0.1);
                    ctx.arc(0, 0, s * 0.31, Math.PI * 0.2, Math.PI * 0.95);
                    ctx.stroke();
                } else if (motif.ringStyle === 2) {
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const a = (-Math.PI / 2) + i * (Math.PI / 3);
                        const x = Math.cos(a) * s * 0.31;
                        const y = Math.sin(a) * s * 0.31;
                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.roundRect(-s * 0.27, -s * 0.27, s * 0.54, s * 0.54, s * 0.08);
                    ctx.stroke();
                }
                ctx.restore();

                ctx.save();
                ctx.beginPath();
                ctx.arc(c, c, s * 0.3, 0, Math.PI * 2);
                ctx.clip();
                const rg = ctx.createRadialGradient(c, c, s * 0.04, c, c, s * 0.42);
                rg.addColorStop(0, theme.glow + 'cc');
                rg.addColorStop(1, theme.glow + '00');
                ctx.fillStyle = rg;
                ctx.fillRect(0, 0, s, s);
                ctx.restore();
            },

            drawGlyph(ctx, s, theme, motif) {
                const c = s / 2;
                const v = motif.glyphVariant;
                ctx.save();
                ctx.translate(c, c);
                ctx.rotate((v - 1) * 0.16);
                ctx.translate(-c, -c);
                ctx.strokeStyle = '#f8fbff';
                ctx.fillStyle = '#f8fbff';
                ctx.lineWidth = Math.max(2, s * 0.05);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                switch (theme.kind) {
                    case 'fire':
                        ctx.beginPath();
                        ctx.moveTo(c, s * 0.2);
                        ctx.quadraticCurveTo(s * (0.66 + v * 0.02), s * 0.42, c, s * 0.8);
                        ctx.quadraticCurveTo(s * 0.3, s * (0.5 + v * 0.01), c, s * 0.2);
                        ctx.fill();
                        if (v >= 2) {
                            ctx.globalAlpha = 0.72;
                            ctx.beginPath();
                            ctx.moveTo(c, s * 0.34);
                            ctx.quadraticCurveTo(s * 0.56, s * 0.48, c, s * 0.68);
                            ctx.quadraticCurveTo(s * 0.44, s * 0.56, c, s * 0.34);
                            ctx.fill();
                        }
                        break;
                    case 'shield':
                        ctx.beginPath();
                        ctx.moveTo(c, s * 0.2);
                        ctx.lineTo(s * 0.78, s * 0.32);
                        ctx.lineTo(s * 0.7, s * 0.68);
                        ctx.lineTo(c, s * 0.84);
                        ctx.lineTo(s * 0.3, s * 0.68);
                        ctx.lineTo(s * 0.22, s * 0.32);
                        ctx.closePath();
                        ctx.stroke();
                        if (v % 2 === 1) {
                            ctx.beginPath();
                            ctx.moveTo(c, s * 0.3);
                            ctx.lineTo(c, s * 0.72);
                            ctx.stroke();
                        }
                        break;
                    case 'blade':
                        ctx.beginPath();
                        ctx.moveTo(s * 0.3, s * 0.74);
                        ctx.lineTo(s * 0.7, s * 0.26);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(s * (0.24 + v * 0.01), s * 0.62);
                        ctx.lineTo(s * (0.42 + v * 0.01), s * 0.8);
                        ctx.stroke();
                        if (v >= 2) {
                            ctx.beginPath();
                            ctx.moveTo(s * 0.46, s * 0.54);
                            ctx.lineTo(s * 0.6, s * 0.68);
                            ctx.stroke();
                        }
                        break;
                    case 'wind':
                        for (let i = 0; i < 2 + v; i++) {
                            const y = s * (0.3 + i * 0.13);
                            ctx.beginPath();
                            ctx.moveTo(s * 0.2, y);
                            ctx.quadraticCurveTo(s * 0.5, y - s * (0.1 + v * 0.01), s * 0.8, y);
                            ctx.stroke();
                        }
                        break;
                    case 'dark': {
                        const off = s * (0.08 + v * 0.015);
                        ctx.beginPath();
                        ctx.arc(c, c, s * 0.25, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.fillStyle = theme.bgA;
                        ctx.beginPath();
                        ctx.arc(c + off, c - s * 0.02, s * 0.23, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    }
                    case 'toxic':
                        ctx.beginPath();
                        ctx.arc(c, s * 0.43, s * 0.13, 0, Math.PI * 2);
                        ctx.arc(s * 0.35, s * 0.62, s * 0.11, 0, Math.PI * 2);
                        ctx.arc(s * 0.65, s * 0.62, s * 0.11, 0, Math.PI * 2);
                        ctx.stroke();
                        if (v >= 1) {
                            ctx.beginPath();
                            ctx.arc(c, c, s * 0.03, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    case 'earth':
                        ctx.beginPath();
                        ctx.moveTo(s * 0.3, s * 0.24);
                        ctx.lineTo(s * 0.24, s * 0.56);
                        ctx.lineTo(s * 0.44, s * 0.48);
                        ctx.lineTo(s * 0.4, s * 0.78);
                        ctx.lineTo(s * 0.7, s * 0.42);
                        ctx.lineTo(s * 0.52, s * 0.52);
                        ctx.lineTo(s * 0.58, s * (0.24 + v * 0.01));
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'tech': {
                        const box = s * (0.4 + v * 0.01);
                        const left = c - box / 2;
                        const top = c - box / 2;
                        ctx.strokeRect(left, top, box, box);
                        for (let i = 0; i < 4; i++) {
                            const p = left + (i + 0.5) * (box / 4);
                            ctx.beginPath();
                            ctx.moveTo(p, top - s * 0.08);
                            ctx.lineTo(p, top);
                            ctx.moveTo(p, top + box);
                            ctx.lineTo(p, top + box + s * 0.08);
                            ctx.stroke();
                        }
                        break;
                    }
                    case 'holy':
                        ctx.beginPath();
                        ctx.moveTo(c, s * 0.24);
                        ctx.lineTo(c, s * 0.76);
                        ctx.moveTo(s * 0.28, c);
                        ctx.lineTo(s * 0.72, c);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(c, c, s * (0.24 + v * 0.02), 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    default: {
                        const sides = 5 + (v % 4);
                        ctx.beginPath();
                        for (let i = 0; i < sides; i++) {
                            const a = (-Math.PI / 2) + (i * Math.PI * 2 / sides);
                            const x = c + Math.cos(a) * s * 0.28;
                            const y = c + Math.sin(a) * s * 0.28;
                            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(c, c, s * (0.08 + v * 0.015), 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    }
                }
                ctx.restore();
            },

            drawCoreMarks(ctx, s, theme, motif) {
                const c = s / 2;
                ctx.save();
                ctx.strokeStyle = theme.ring;
                ctx.fillStyle = theme.ring;
                ctx.globalAlpha = 0.75;
                ctx.lineWidth = Math.max(1.5, s * 0.025);
                switch (motif.innerMark) {
                    case 0:
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.08, c + s * 0.24);
                        ctx.lineTo(c + s * 0.08, c + s * 0.24);
                        ctx.stroke();
                        break;
                    case 1:
                        ctx.beginPath();
                        ctx.arc(c, c, s * 0.04, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 2:
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.16, c);
                        ctx.lineTo(c + s * 0.16, c);
                        ctx.stroke();
                        break;
                    case 3:
                        ctx.beginPath();
                        ctx.moveTo(c, c - s * 0.16);
                        ctx.lineTo(c, c + s * 0.16);
                        ctx.stroke();
                        break;
                    default:
                        ctx.beginPath();
                        ctx.arc(c - s * 0.12, c + s * 0.14, s * 0.025, 0, Math.PI * 2);
                        ctx.arc(c + s * 0.12, c + s * 0.14, s * 0.025, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
                ctx.restore();
            },

            create(iconId) {
                const theme = this.themeFor(iconId);
                const motif = this.motifFor(iconId);
                return (ctx, size) => {
                    this.drawBase(ctx, size, theme, motif);
                    this.drawGlyph(ctx, size, theme, motif);
                    this.drawCoreMarks(ctx, size, theme, motif);
                };
            }
        };

        // ===== ROLE DATA - ORIGINAL CHARACTERS (NO COPYRIGHT) =====
        const rolesData = {
            // CHARACTERS = Unique heroes with special abilities
            characters: [
                {
                    id: 'char_rex',
                    name: 'Rex "Thunderjaw" Striker',
                    title: 'El Depredador Primordial',
                    type: 'character',
                    imagePath: 'assets/characters/rex.png',
                    icon: '🦖',
                    race: 'Saurio Ancestral',
                    age: '10,000 años',
                    origin: 'Tierras Salvajes del Cretáceo',

                    // Atributos base
                    stats: {
                        strength: 95,      // Fuerza física
                        agility: 70,       // Velocidad y reflejos
                        intelligence: 45,  // Poder mágico
                        vitality: 90,      // HP y resistencia
                        luck: 60          // Crítico y drops
                    },

                    // Personalidad y trasfondo
                    personality: 'Feroz pero honorable. Rex es un guerrero ancestral que valora la fuerza bruta y el combate directo.',
                    backstory: 'íltimo superviviente de una era olvidada, Rex despertí de su letargo milenario para enfrentar las amenazas del presente. Su rugido hace temblar montañas y su furia es legendaria.',

                    // Especialización
                    playstyle: 'Bruiser de corto alcance con alto daño físico y resistencia',
                    strengths: ['Daño cuerpo a cuerpo devastador', 'Alta supervivencia', 'Control de írea con rugidos'],
                    weaknesses: ['Vulnerable a ataques a distancia', 'Baja movilidad', 'Sin habilidades mígicas'],

                    description: 'Guerrero primordial con fuerza devastadora y rugidos que aturden enemigos',
                    abilities: [
                        { id: 'rex_claw', name: 'Garra Primordial', type: 'standard', cooldown: 2500, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_claw', icon: '🦖', description: 'Golpe salvaje que inflige daño masivo y aplica sangrado' },
                        { id: 'rex_roar', name: 'Rugido del Trueno', type: 'standard', cooldown: 4000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_roar', icon: '📢', description: 'Aturde enemigos cercanos y reduce su defensa por 5s' }
                    ],
                    ultimateAbility: { id: 'rex_ultimate', name: 'Furia del Apex', type: 'ultimate', cooldown: 20000, currentCooldown: 0, keyBinding: 'r', effectId: 'effect_apex', icon: '🔥', description: 'Entra en modo berserker: +50% daño, +30% velocidad, inmune a control por 8s' }
                },
                {
                    id: 'char_nova',
                    name: 'Nova "Stardust" Lumina',
                    title: 'La Guardiana Cósmica',
                    type: 'character',
                    imagePath: 'assets/characters/nova.png',
                    icon: '⭐',
                    race: 'Celestial Estelar',
                    age: '5,000 años luz',
                    origin: 'Nebulosa de Andrómeda',

                    stats: {
                        strength: 40,
                        agility: 85,
                        intelligence: 95,
                        vitality: 65,
                        luck: 75
                    },

                    personality: 'Serena y sabia. Nova busca el equilibrio entre luz y oscuridad, protegiendo a los inocentes con su poder císmico.',
                    backstory: 'Nacida del corazón de una supernova, Nova viaja entre dimensiones como guardiana del balance universal. Su luz puede sanar o destruir según su voluntad.',

                    playstyle: 'Mago de soporte/daño con habilidades versátiles de luz cósmica',
                    strengths: ['Alto daño mágico a distancia', 'Escudos protectores', 'Movilidad aírea'],
                    weaknesses: ['Baja defensa física', 'Vulnerable en combate cercano', 'Cooldowns largos'],

                    description: 'Ser celestial que manipula energía estelar para proteger y devastar',
                    abilities: [
                        { id: 'nova_beam', name: 'Rayo Estelar', type: 'standard', cooldown: 3000, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_star_beam', icon: '✨', description: 'Dispara un rayo de luz pura que atraviesa enemigos' },
                        { id: 'nova_shield', name: 'Escudo Cósmico', type: 'standard', cooldown: 4500, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_cosmic_shield', icon: '🛡️', description: 'Crea un escudo que absorbe daño y refleja proyectiles' }
                    ],
                    ultimateAbility: { id: 'nova_ultimate', name: 'Supernova Divina', type: 'ultimate', cooldown: 22000, currentCooldown: 0, keyBinding: 'r', effectId: 'effect_supernova', icon: '⭐', description: 'Explota en luz cegadora: daño masivo AoE + cura aliados cercanos' }
                },
                {
                    id: 'char_blade',
                    name: 'Kael "Nightblade" Umbra',
                    title: 'El Asesino Fantasma',
                    type: 'character',
                    imagePath: 'assets/characters/blade.png',
                    icon: '🗡️',
                    race: 'Elfo Oscuro',
                    age: '247 años',
                    origin: 'Reino de las Sombras Eternas',

                    stats: {
                        strength: 70,
                        agility: 98,
                        intelligence: 60,
                        vitality: 55,
                        luck: 85
                    },

                    personality: 'Silencioso y letal. Kael es un perfeccionista que valora la precisión sobre la fuerza bruta. Habla poco pero sus acciones son definitivas.',
                    backstory: 'Exiliado de su clan por negarse a asesinar inocentes, Kael ahora usa sus habilidades para cazar a los verdaderos villanos. Sus espadas gemelas nunca fallan.',

                    playstyle: 'Asesino de alta movilidad con daño explosivo y evasión',
                    strengths: ['Críticos devastadores', 'Movilidad extrema', 'Invisibilidad temporal'],
                    weaknesses: ['Muy frágil', 'Requiere precisión', 'Inefectivo contra grupos grandes'],

                    description: 'Maestro de espadas gemelas que danza entre las sombras con letalidad absoluta',
                    abilities: [
                        { id: 'blade_slash', name: 'Corte Fantasma', type: 'standard', cooldown: 2800, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_shadow_slash', icon: '⚔️', description: 'Dash rápido que corta múltiples veces, garantiza crítico' },
                        { id: 'blade_dash', name: 'Paso de Sombra', type: 'standard', cooldown: 4200, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_dash', icon: '👤', description: 'Teletransporte corto + invisibilidad por 2s' }
                    ],
                    ultimateAbility: { id: 'blade_ultimate', name: 'Danza de las Mil Hojas', type: 'ultimate', cooldown: 18000, currentCooldown: 0, keyBinding: 'r', effectId: 'effect_blade_storm', icon: '⚔️', description: 'Ataque frenético: 20 cortes en 3s, cada uno con 50% crítico' }
                },
                {
                    id: 'char_phoenix',
                    name: 'Ember "Ashborn" Pyra',
                    title: 'La Inmortal Llameante',
                    type: 'character',
                    imagePath: 'assets/characters/phoenix.png',
                    icon: '🔥',
                    race: 'Fénix Ancestral',
                    age: 'Inmortal (renacida 47 veces)',
                    origin: 'Volcán del Fin del Mundo',

                    stats: {
                        strength: 65,
                        agility: 75,
                        intelligence: 80,
                        vitality: 70,
                        luck: 90
                    },

                    personality: 'Apasionada y resiliente. Ember ha vivido mil vidas y cada muerte la hace más fuerte. Nunca se rinde y siempre encuentra esperanza en las cenizas.',
                    backstory: 'Cada vez que muere, renace más poderosa. Ember ha presenciado el ascenso y caída de imperios, y su sabiduría es tan vasta como su poder sobre las llamas.',

                    playstyle: 'Mago de fuego con regeneraciín y segunda oportunidad al morir',
                    strengths: ['Renace al morir (1 vez por raid)', 'DoT de fuego potente', 'Auto-curación'],
                    weaknesses: ['Vulnerable a hielo/agua', 'Daño moderado', 'Depende de su pasiva de renacimiento'],

                    description: 'Ave inmortal que controla llamas purificadoras y renace de sus cenizas',
                    abilities: [
                        { id: 'phoenix_flame', name: 'Alas de Fuego', type: 'standard', cooldown: 3200, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_flame_wing', icon: '🔥', description: 'Lanza plumas ardientes que aplican quemadura por 6s' },
                        { id: 'phoenix_heal', name: 'Renacimiento Menor', type: 'standard', cooldown: 6000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_rebirth', icon: '💚', description: 'Cura 30% HP + elimina efectos negativos' }
                    ],
                    ultimateAbility: { id: 'phoenix_ultimate', name: 'Resurrección del Fénix', type: 'ultimate', cooldown: 25000, currentCooldown: 0, keyBinding: 'r', effectId: 'effect_phoenix_rise', icon: '🔥', description: 'Explota en llamas: daño AoE + renace con 50% HP si muere en 10s' }
                },
                {
                    id: 'char_titan',
                    name: 'Gorath "Ironheart" Magnus',
                    title: 'El Coloso Inquebrantable',
                    type: 'character',
                    imagePath: 'assets/characters/titan.png',
                    icon: '🏚️',
                    race: 'Gigante de Piedra',
                    age: '800 años',
                    origin: 'Montañas del Fin del Mundo',

                    stats: {
                        strength: 92,
                        agility: 45,
                        intelligence: 50,
                        vitality: 100,
                        luck: 55
                    },

                    personality: 'Estoico y protector. Gorath habla con acciones, no palabras. Su presencia inspira confianza y su determinación es inquebrantable.',
                    backstory: 'Forjado en las profundidades de la tierra, Gorath jurí proteger a los díbiles. Su cuerpo de piedra viviente puede soportar cualquier castigo mientras sus aliados están a salvo.',

                    playstyle: 'Tanque puro con control de masas y protección de equipo',
                    strengths: ['HP masivo', 'Alta defensa', 'Aturde grupos', 'Protege aliados'],
                    weaknesses: ['Muy lento', 'Bajo daño', 'Vulnerable a magia penetrante'],

                    description: 'Gigante de piedra viviente con defensa impenetrable y fuerza titánica',
                    abilities: [
                        { id: 'titan_smash', name: 'Puño Sísmico', type: 'standard', cooldown: 3500, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_smash', icon: '👊', description: 'Golpea el suelo: daño AoE + aturde 2s + ralentiza' },
                        { id: 'titan_wall', name: 'Muro de Hierro', type: 'standard', cooldown: 5000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_wall', icon: '🧱', description: 'Crea barrera que bloquea proyectiles + reduce daño 40% por 5s' }
                    ],
                    ultimateAbility: { id: 'titan_ultimate', name: 'Ira del Coloso', type: 'ultimate', cooldown: 24000, currentCooldown: 0, keyBinding: 'r', effectId: 'effect_titan_wrath', icon: '🌋', description: 'Crece al doble: +100% HP, +50% defensa, ondas de choque cada 2s por 10s' }
                }
            ],

            // CLASSES = Combat styles/themes
            classes: [
                // SSS TIER - Legendary (1 ticket required) - 6 ABILITIES TOTAL
                {
                    id: 'class_dragonhunter',
                    name: 'Dragonhunter',
                    type: 'class',
                    tier: 'SSS',
                    tierColor: '#ff0000',
                    ticketsRequired: 1,
                    imagePath: 'assets/dragonhunter.jpg',
                    icon: '🐉',
                    description: 'Legendary dragon slayer with devastating fire abilities',
                    abilities: [
                        { id: 'dragon_arrow', name: 'Triple Flecha Flamígera', type: 'standard', cooldown: 3000, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_flame_arrow', icon: '🏹', iconImage: 'assets/tripleflechaflamigera.jpg', burnStacks: 0, description: 'Dispara tres flechas flamígeras que aplican quemadura acumulativa a los enemigos.' },
                        { id: 'dragon_breath', name: 'Bomba de Aliento de Dragón', type: 'standard', cooldown: 8000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_dragon_breath', icon: '🐉', description: 'Lanza una bomba explosiva que libera aliento de dragón, quemando a todos los enemigos en el área.' },
                        { id: 'triple_arrow', name: 'Flecha Triple Uso', type: 'standard', cooldown: 5000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_triple', icon: '🏹', description: 'Dispara tres flechas simultáneas en diferentes direcciones para atacar múltiples objetivos.' },
                        { id: 'nature_rise', name: 'Naturaleza en Ascenso', type: 'standard', cooldown: 12000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_nature', icon: '🌿', description: 'Invoca el poder de la naturaleza para regenerar vida y aumentar tu defensa temporalmente.' }
                    ],
                    semiUltimate: { id: 'dragon_madness', name: 'Locura Dracónica', type: 'semi-ultimate', cooldown: 18000, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_madness', icon: '🐉', description: 'Entras en un estado de locura dracónica que aumenta masivamente tu velocidad de ataque y daño por fuego.' },
                    ultimateAbility: { id: 'dragon_ultimate', name: 'Explosión Dracónica', type: 'ultimate', cooldown: 25000, currentCooldown: 0, keyBinding: 's', effectId: 'effect_draconic', icon: '💥', description: 'Liberas una explosión devastadora de energía dracónica que vaporiza a todos los enemigos cercanos.' }
                },
                // SSS TIER - REWORK: LEGIONARIO ROMANO
                {
                    id: 'class_roman_legionary',
                    name: 'Legionario Romano',
                    type: 'class',
                    tier: 'SSS',
                    tierColor: '#dc143c', // Rojo carmesí romano
                    ticketsRequired: 1,
                    imagePath: 'assets/legionarioromano.jpg',
                    icon: '🦅',
                    title: 'Gloria Aeterna de Roma',
                    description: 'REWORK v2.0 - Guerrero legendario del Imperio Romano. Maestro absoluto de la disciplina militar, las formaciones tácticas y el combate de legión. Cada golpe de su gladius carga la gloria de mil batallas.',
                    passiveSystem: {
                        name: 'Disciplina Romana',
                        description: 'Cada enemigo eliminado otorga +2% de daño y +1% de defensa (máx 30 stacks). Acumula "Gloria" que reduce cooldowns un 1% por stack.'
                    },
                    abilities: [
                        { id: 'roman_gladius', name: 'Gladius Fulminante', type: 'standard', cooldown: 2500, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_gladius', icon: '⚔️', iconImage: 'assets/gladiusfulminante.jpg', description: 'Ejecuta una combo de 5 estocadas letales con el gladius. Cada golpe aumenta velocidad de ataque +8% (máx 40%). El 5° golpe causa CRÍTICO garantizado y aplica "Herida Romana" (sangrado 15 daño/s por 6s).' },
                        { id: 'roman_testudo', name: 'Formación Testudo Sagrada', type: 'standard', cooldown: 8000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_testudo', icon: '🛡️', iconImage: 'assets/formaciontestudo.jpg', description: 'Adoptas la legendaria formación tortuga. Reduces daño 80%, reflejas 50% del daño bloqueado, y generas un aura que protege aliados cercanos (-40% daño). Duración: 6s. Al terminar, libera una onda de escudo que aturde 2s.' },
                        { id: 'roman_pilum', name: 'Lluvia de Pilum', type: 'standard', cooldown: 5000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_pilum', icon: '🏹', iconImage: 'assets/lanzamientopilum.jpg', description: 'Lanzas 5 jabalinas pilum en abanico. Cada pilum atraviesa 3 enemigos, causa sangrado masivo (20 daño/s por 5s), reduce armadura 50% y ralentiza 40%. Los pilum clavados en el suelo explotan tras 3s.' },
                        { id: 'roman_mars_shield', name: 'Escudo de Marte', type: 'standard', cooldown: 12000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_mars', icon: '🔥', iconImage: 'assets/escudodemarte.jpg', description: 'NUEVA HABILIDAD: Invocas la bendición del dios Marte. Tu escudo se enciende con fuego divino. Por 8s: Bloqueas TODO el daño frontal, tus ataques queman (25 daño/s), y cada bloqueo exitoso lanza una onda de fuego.' }
                    ],
                    semiUltimate: {
                        id: 'roman_aquila',
                        name: 'Águila Imperial Divina',
                        type: 'semi-ultimate',
                        cooldown: 18000,
                        currentCooldown: 0,
                        keyBinding: 'a',
                        effectId: 'effect_aquila',
                        icon: '🦅',
                        iconImage: 'assets/aguilaimperial.jpg',
                        description: 'REWORK: Alzas el Aquila sagrada al cielo. Un Águila dorada GIGANTE (5x tamaño) desciende con un rugido de trueno. Invulnerable 4s. El Águila ataca independientemente (80 daño/golpe), emite ondas doradas cada 0.5s, y al finalizar realiza un picado devastador (200 daño AoE). Tu siguiente habilidad tiene cooldown 0.'
                    },
                    ultimateAbility: {
                        id: 'roman_legio',
                        name: 'Legio Aeterna Invicta',
                        type: 'ultimate',
                        cooldown: 28000,
                        currentCooldown: 0,
                        keyBinding: 's',
                        effectId: 'effect_legio_aeterna',
                        icon: '⚔️',
                        iconImage: 'assets/legioaeterna.jpg',
                        description: 'REWORK ÉPICO: El campo de batalla se oscurece con nubes carmesí. Levantas tu gladius al cielo mientras un rayo dorado te ilumina. Aparecen 25 Legionarios Espectrales de Élite en formación perfecta de cuña que cargan al unísono. Cada legionario causa 60 daño y aplica "Terror Romano" (-90% velocidad, -70% daño por 8s). Tú flotas en el centro con aura dorada radiante, toga carmesí ondeando épicamente, INVULNERABLE 6s. Los legionarios persiguen y ejecutan enemigos <30% HP. Al finalizar, todos alzan sus escudos y explotan en luz dorada (300 daño AoE).'
                    }
                },
                // SSS TIER - REWORK: HOPLITA ESPARTANO
                {
                    id: 'class_spartan_hoplite',
                    name: 'Hoplita Espartano',
                    type: 'class',
                    tier: 'SSS',
                    tierColor: '#8B0000', // Rojo espartano
                    ticketsRequired: 1,
                    imagePath: 'assets/hoplitaespartano.jpg',
                    icon: '🛡️',
                    title: 'Molon Labe - Gloria Eterna de Esparta',
                    description: 'REWORK v2.0 - Guerrero inmortal de Esparta. Entrenado desde los 7 años en la Agoge, representa la perfección del combate griego. "Vuelve con tu escudo, o sobre él." - el código supremo del guerrero espartano.',
                    passiveSystem: {
                        name: 'Furia Espartana',
                        description: 'Cuanto menos HP tengas, más daño infliges (hasta +100% a 20% HP). Cada kill restaura 5% HP y otorga "Kléos" (gloria) que aumenta todas tus stats 2% por stack (máx 15).'
                    },
                    abilities: [
                        { id: 'spartan_dory', name: 'Doru del Rey Leónidas', type: 'standard', cooldown: 2800, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_dory', icon: '🔱', iconImage: 'assets/dorupenetrante.jpg', description: 'REWORK: Lanzas la lanza legendaria de Leónidas. Atraviesa TODOS los enemigos en línea recta (rango infinito), causa 80 daño + sangrado 25/s por 5s. Si mata a un enemigo, rebota al siguiente con +30% daño. Máx 5 rebotes.' },
                        { id: 'spartan_phalanx', name: 'Falange Inmortal', type: 'standard', cooldown: 9000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_phalanx', icon: '🛡️', iconImage: 'assets/falangeespartana.jpg', description: 'REWORK: Adoptas la formación de falange perfecta. Invulnerable de frente. Reduces 90% daño lateral. Empujas enemigos constantemente. Generas un aura de +50% defensa para aliados. Duración: 7s. Al terminar: golpe de escudo que lanza enemigos.' },
                        { id: 'spartan_leonidas_charge', name: 'Carga de Leónidas', type: 'standard', cooldown: 6000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_charge', icon: '⚡', iconImage: 'assets/cargaespartana.jpg', description: 'NUEVA: "THIS IS SPARTA!" - Cargas con furia divina. Dash de 500 unidades, enemigos impactados son lanzados hacia atrás y aturdidos 3s. Si impactas a un boss, causas CRÍTICO x3. Ganas +80% velocidad por 4s.' },
                        { id: 'spartan_aroo', name: '¡AROO! Grito de los 300', type: 'standard', cooldown: 14000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_aroo', icon: '📯', iconImage: 'assets/gritodeguerraaroo.jpg', description: 'REWORK: Emites el legendario grito de guerra espartano en 3 pulsos. Cada pulso: +25% daño (acumulativo, máx +75%), +15% defensa, +20% velocidad. Enemigos sufren "Terror de Esparta": -50% daño, huyen por 2s. Duración: 12s.' }
                    ],
                    semiUltimate: {
                        id: 'spartan_ares',
                        name: 'Avatar de Ares',
                        type: 'semi-ultimate',
                        cooldown: 20000,
                        currentCooldown: 0,
                        keyBinding: 'a',
                        effectId: 'effect_ares',
                        icon: '⚔️',
                        iconImage: 'assets/bendiciondeares.jpg',
                        description: 'REWORK ÉPICO: Ares, dios de la guerra, POSEE tu cuerpo. Transformación: Ojos rojos brillantes, aura de fuego carmesí, capa ondeando. Por 10s: Daño x3, robo de vida 30%, inmune a CC, velocidad +60%. Cada golpe tiene 25% de ejecutar enemigos <40% HP. Al terminar, Ares lanza un rayo de guerra que causa 150 daño a todos los enemigos.'
                    },
                    ultimateAbility: {
                        id: 'spartan_thermopylae',
                        name: 'Los 300 de las Termópilas',
                        type: 'ultimate',
                        cooldown: 32000,
                        currentCooldown: 0,
                        keyBinding: 's',
                        effectId: 'effect_thermopylae',
                        icon: '🏛️',
                        iconImage: 'assets/lastermopilas.jpg',
                        description: 'REWORK LEGENDARIO: "¡ESPARTANOS! ¿CUÁL ES VUESTRO OFICIO?" - El campo se oscurece con nubes de tormenta rojas. 30 Hoplitas espectrales de los 300 originales emergen del suelo en formación de falange perfecta, liderados por el espíritu de Leónidas. Marchan cantando el Paean de guerra. Cada hoplita causa 50 daño y tiene 150 HP. Aplican "Miedo de las Termópilas" (-80% velocidad/daño). Tú flotas en el centro con armadura dorada brillante, capa carmesí épica, INVULNERABLE 7s. Los hoplitas forman un muro viviente que bloquea TODO. Al finalizar, todos alzan sus lanzas y disparan una lluvia de dorus (40 proyectiles, 60 daño c/u).'
                    }
                },

                // SSS TIER - EVENTO ESPECIAL: RUINAS ANTIGUAS
                {
                    id: 'ancient-guardian',
                    name: 'Taurha Colossus',
                    type: 'class',
                    tier: 'SSS',
                    tierColor: '#8B7355', // Color piedra/ruinas
                    ticketsRequired: 1,
                    imagePath: 'assets/guardianancestral.jpg',
                    icon: '???',
                    title: 'Pillar Sovereign of Ancient Ruins',
                    description: 'Legendary colossus wielder of a giant pillar. Taurha controls sand, ruin magic, and meteor barrages, becoming stronger in late combat phases.',
                    abilities: [
                        { id: 'guardian_glyph', name: 'Sweep', type: 'standard', cooldown: 10000, currentCooldown: 0, keyBinding: 'q', effectId: 'guardian_glyph', icon: '??', iconImage: null, description: 'Performs a heavy pillar sweep toward the target direction. Fast frontal control strike and knockback setup tool.' },
                        { id: 'guardian_hurl', name: 'Strike Frenzy', type: 'standard', cooldown: 25000, currentCooldown: 0, keyBinding: 'w', effectId: 'guardian_hurl', icon: '??', iconImage: null, description: 'Multi-impact frenzy: 3 alternating pillar strikes followed by chained angular sweeps. High burst zone pressure.' },
                        { id: 'guardian_tablets', name: 'Sandstorm', type: 'standard', cooldown: 25000, currentCooldown: 0, keyBinding: 'e', effectId: 'guardian_tablets', icon: '??', iconImage: null, description: 'Summons a sand tornado and meteor shower. Meteors poison enemies, then Taurha detonates the area with a ruin-slam.' },
                        { id: 'guardian_burrow', name: 'Pillar Guard', type: 'standard', cooldown: 16000, currentCooldown: 0, keyBinding: 't', effectId: 'guardian_burrow', icon: '??', iconImage: null, description: 'Defensive stance with the pillar: incoming damage reduced and M1 pillar attacks become empowered for a short duration.' }
                    ],
                    semiUltimate: {
                        id: 'guardian_construct',
                        name: 'Titan Dive',
                        type: 'semi-ultimate',
                        cooldown: 32000,
                        currentCooldown: 0,
                        keyBinding: 'a',
                        effectId: 'guardian_construct',
                        icon: '??',
                        iconImage: null,
                        description: 'Leaps into the sky and crashes down in a huge impact zone. Core phase-shift move in Taurha kit.'
                    },
                    ultimateAbility: {
                        id: 'guardian_worldbreaker',
                        name: 'Pillar Cannon',
                        type: 'ultimate',
                        cooldown: 35000,
                        currentCooldown: 0,
                        keyBinding: 's',
                        effectId: 'guardian_worldbreaker',
                        icon: '??',
                        iconImage: null,
                        description: 'Launches a giant pillar-orb skyward, splitting into recursive meteor cascades. Total saturation strike for endgame pressure.'
                    }
                },
                // SSS TIER - EVENTO ESPECIAL: CIVILIZACIONES ANTIGUAS - EGIPTO
                {
                    id: 'class_anubis',
                    name: 'Guardián de Anubis',
                    type: 'class',
                    tier: 'SSS',
                    tierColor: '#FFD700', // Dorado egipcio
                    ticketsRequired: 1,
                    imagePath: 'assets/anubis',
                    icon: '🐺',
                    title: 'Juez de las Almas',
                    description: 'Guardián legendario del inframundo egipcio. Maestro de la muerte y la resurrección, pesa las almas de los caídos y controla las arenas del desierto eterno. El poder de los dioses antiguos fluye en cada movimiento.',
                    abilities: [
                        { id: 'anubis_judgment', name: 'Juicio de las Almas', type: 'standard', cooldown: 3500, currentCooldown: 0, keyBinding: 'q', effectId: 'anubis_judgment', icon: '⚖️', iconImage: 'assets/juiciodelasalmas.jpg', description: 'Invocas la balanza sagrada de Anubis. Lanzas 3 proyectiles de energía dorada que persiguen a los enemigos más cercanos. Al impactar, "pesan" el alma del enemigo: si tiene más del 50% HP, recibe daño normal; si tiene menos del 50% HP, recibe el doble de daño y es marcado con el "Sello de la Muerte" que aumenta el daño recibido un 30% por 5 segundos.' },
                        { id: 'anubis_sandstorm', name: 'Tormenta de Arena Maldita', type: 'standard', cooldown: 6000, currentCooldown: 0, keyBinding: 'w', effectId: 'anubis_sandstorm', icon: '🌪️', iconImage: 'assets/tormentadearenamaldita.jpg', description: 'Creas una tormenta de arena dorada en un radio de 300 unidades alrededor tuyo. La tormenta dura 6 segundos, inflige 20 de daño por segundo a todos los enemigos dentro, reduce su precisión un 40% y aplica "Ceguera del Desierto" que invierte sus controles de movimiento. Tú eres inmune y te curas 15 HP por segundo mientras estás en la tormenta.' },
                        { id: 'anubis_jackal', name: 'Forma del Chacal Divino', type: 'standard', cooldown: 8000, currentCooldown: 0, keyBinding: 'e', effectId: 'anubis_jackal', icon: '🐺', iconImage: 'assets/formadelchacaldivino.jpg', description: 'Te transformas en un chacal espectral dorado durante 8 segundos. Tu velocidad de movimiento aumenta un 60%, tus ataques aplican sangrado que causa 10 de daño por segundo durante 4 segundos, y dejas un rastro de fuego dorado que daña a los enemigos que lo pisan (15 daño/s). Además, tus ataques tienen 40% de probabilidad de ejecutar instantáneamente enemigos con menos del 15% HP.' },
                        { id: 'anubis_ankh', name: 'Ankh de la Resurrección', type: 'standard', cooldown: 12000, currentCooldown: 0, keyBinding: 't', effectId: 'anubis_ankh', icon: '☥', iconImage: 'assets/ankhdelaresurreccion.jpg', description: 'Invocas el poder del Ankh sagrado. Creas un símbolo dorado brillante en el suelo (radio 200) que dura 10 segundos. Mientras estés dentro del área: te curas 25 HP por segundo, tu daño aumenta un 35%, y si tu HP llega a 0, automáticamente resucitas con 40% HP (solo una vez por uso). Los enemigos dentro del área reciben daño de 15 por segundo y tienen su curación reducida un 80%.' }
                    ],
                    semiUltimate: {
                        id: 'anubis_plague',
                        name: 'Plaga de las Diez Maldiciones',
                        type: 'semi-ultimate',
                        cooldown: 25000,
                        currentCooldown: 0,
                        keyBinding: 'a',
                        effectId: 'anubis_plague',
                        icon: '💀',
                        iconImage: 'assets/plagadelasdiezmaldiciones.jpg',
                        description: 'Invocas las legendarias plagas de Egipto. Levantas tu cetro mientras el cielo se oscurece con un tono verde enfermizo. Durante 10 segundos, desatas 5 plagas consecutivas cada 2 segundos: 1) Lluvia de sangre (30 daño AoE), 2) Enjambre de langostas (aplica veneno 15 daño/s por 5s), 3) Oscuridad total (enemigos ciegos por 3s), 4) Granizo de fuego (40 daño + quemadura), 5) Muerte de los primogénitos (ejecuta instantáneamente enemigos con menos del 25% HP). Eres invulnerable durante la canalización y emites un aura verde-dorada pulsante. Los enemigos afectados reciben el debuff "Maldición Faraónica" que reduce todos sus stats un 50% por 8 segundos.'
                    },
                    ultimateAbility: {
                        id: 'anubis_underworld',
                        name: 'Portal del Inframundo',
                        type: 'ultimate',
                        cooldown: 35000,
                        currentCooldown: 0,
                        keyBinding: 's',
                        effectId: 'anubis_underworld',
                        icon: '🌑',
                        iconImage: 'assets/portaldelinframundo.jpg',
                        description: 'Abres un portal masivo al Duat (inframundo egipcio). Golpeas el suelo con tu cetro mientras el campo de batalla se oscurece completamente. Un portal circular gigante (radio 600) se abre bajo tus pies con jeroglíficos dorados brillantes girando en sus bordes. Del portal emergen 12 guerreros momificados de élite con armaduras doradas que atacan a todos los enemigos durante 7 segundos. Simultáneamente, 8 columnas de fuego espectral verde-dorado erupcionan aleatoriamente cada segundo causando 120 de daño cada una. Tú levitas en el centro con una forma espectral de Anubis (cabeza de chacal gigante) manifestándose detrás de ti, invulnerable durante toda la duración. Los enemigos dentro del portal sufren "Juicio Final": -90% velocidad de movimiento, -80% daño, y sus almas son "pesadas" - si tienen más kills que muertes, reciben 200 de daño adicional; si no, son aturdidos por 4 segundos. Al finalizar, el portal implosiona causando 300 de daño a todos los enemigos restantes y absorbiendo sus almas para curarte 50 HP por enemigo eliminado. Colores: Negro profundo, dorado brillante egipcio, verde espectral, y destellos de energía turquesa antigua.'
                    }
                },
                // S+ TIER (2 tickets required) - 5 ABILITIES
                {
                    id: 'class_gunslinger',
                    name: 'Cyber Gunslinger',
                    type: 'class',
                    tier: 'S+',
                    tierColor: '#ffd700',
                    ticketsRequired: 2,
                    imagePath: 'assets/cybergunslinger.jpg',
                    icon: '🔫',
                    description: 'High-tech ranged specialist',
                    abilities: [
                        { id: 'gun_rapid', name: 'Rapid Fire', type: 'standard', cooldown: 2200, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_rapid', icon: '🔫', description: 'Dispara una ráfaga rápida de proyectiles de energía hacia los enemigos cercanos.' },
                        { id: 'gun_grenade', name: 'Plasma Grenade', type: 'standard', cooldown: 4800, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_grenade', icon: '💣', description: 'Lanza una granada de plasma que explota causando daño en área.' },
                        { id: 'gun_shield', name: 'Energy Shield', type: 'standard', cooldown: 8000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_shield', icon: '🛡️', description: 'Activa un escudo de energía que te protege del daño enemigo temporalmente.' },
                        { id: 'gun_dash', name: 'Tactical Dash', type: 'standard', cooldown: 5000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_dash', icon: '🏃', description: 'Realiza un dash táctico rápido para reposicionarte y esquivar ataques.' }
                    ],
                    ultimateAbility: { id: 'gun_ultimate', name: 'Orbital Strike', type: 'ultimate', cooldown: 16000, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_orbital', icon: '🛰️', description: 'Llama un ataque orbital devastador que aniquila a todos los enemigos en el área objetivo.' }
                },
                // S TIER (3 tickets required)
                {
                    id: 'class_elementalist',
                    name: 'Elementalist',
                    type: 'class',
                    tier: 'S',
                    tierColor: '#7c3aed',
                    ticketsRequired: 3,
                    imagePath: 'assets/elementalist.jpg',
                    icon: '🔥',
                    title: 'Arcanista de los Cuatro Nucleos',
                    description: 'REWORK v3.0 - Mago de control de zonas. Encadena rayos, congela frentes y desata un cataclismo elemental por fases.',
                    abilities: [
                        { id: 'elem_storm', name: 'Arco Tempestuoso', type: 'standard', cooldown: 3600, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_elem_bolt', icon: '⚡', description: 'Descarga en cadena con rebotes electricos. Aturde brevemente y aplica Vulnerabilidad de Voltaje.' },
                        { id: 'elem_ice', name: 'Prision Criogenica', type: 'standard', cooldown: 5200, currentCooldown: 0, keyBinding: 't', effectId: 'effect_barrier', icon: '🧊', description: 'Genera un anillo de hielo que inmoviliza y erosiona defensa enemiga antes de fracturar.' }
                    ],
                    ultimateAbility: { id: 'elem_ultimate', name: 'Cataclismo de Convergencia', type: 'ultimate', cooldown: 23000, currentCooldown: 0, keyBinding: 'f', effectId: 'effect_fury', icon: '🌪️', description: 'Convergencia de rayo, fuego, hielo y tierra en una secuencia AoE que termina en detonacion de alto dano.' }
                },
                // S+ TIER - REWORK: MYSTIC SAGE
                {
                    id: 'class_mystic',
                    name: 'Mystic Sage',
                    type: 'class',
                    tier: 'S+',
                    tierColor: '#9932CC', // Púrpura místico
                    ticketsRequired: 2,
                    imagePath: 'assets/mysticsage.jpg',
                    icon: '🔮',
                    title: 'Archimago de los Reinos Olvidados',
                    description: 'REWORK v2.0 - Portador de magia ancestral que ha transcendido los límites mortales. Sus conjuros canalizan el poder de dimensiones prohibidas. Cada hechizo resuena con el eco de civilizaciones perdidas.',
                    passiveSystem: {
                        name: 'Resonancia Arcana',
                        description: 'Cada habilidad usada otorga 1 stack de "Poder Arcano" (+5% daño mágico, máx 10). Al llegar a 10 stacks, tu siguiente habilidad tiene cooldown 0 y causa +50% daño. Los stacks se consumen al usar esta habilidad empoderada.'
                    },
                    abilities: [
                        { id: 'mystic_orb', name: 'Orbe Arcano Supremo', type: 'standard', cooldown: 2500, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_orb', icon: '🔮', iconImage: 'assets/orbearcanosupreme.jpg', description: 'REWORK: Lanzas 3 orbes místicos de energía arcana pura que persiguen enemigos independientemente. Cada orbe causa 40 daño + explosión al impactar (radio 80, 25 daño). Los orbes pueden rebotar 2 veces entre enemigos. Si los 3 orbes golpean al mismo enemigo, causa "Sobrecarga Arcana" (aturdido 2s, +40% daño recibido).' },
                        { id: 'mystic_heal', name: 'Santuario de Luz Divina', type: 'standard', cooldown: 8000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_heal_aura', icon: '✨', iconImage: 'assets/santuariodeluz.jpg', description: 'REWORK: Creas un santuario sagrado (radio 200) que dura 10s. Dentro del santuario: curas 15 HP/s, ganas +30% velocidad, +25% defensa, y eres inmune a efectos negativos. Los enemigos dentro reciben 10 daño/s y tienen -40% velocidad. Al terminar, el santuario explota curándote 50 HP.' },
                        { id: 'mystic_chains', name: 'Cadenas del Vacío Eterno', type: 'standard', cooldown: 6000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_chains', icon: '⛓️', iconImage: 'assets/cadenasdelvacio.jpg', description: 'NUEVA: Invocas 6 cadenas espectrales del vacío que emergen del suelo y atrapan a todos los enemigos en radio 250. Los enemigos atrapados: inmobilizados 3s, reciben daño gradual (15/s), y son vulnerables (+35% daño recibido). Si un enemigo muere mientras está encadenado, las cadenas saltan al siguiente enemigo más cercano.' },
                        { id: 'mystic_shield', name: 'Escudo del Archimago', type: 'standard', cooldown: 10000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_shield', icon: '🛡️', iconImage: 'assets/escudodelarchimago.jpg', description: 'NUEVA: Te envuelves en un escudo de energía arcana que absorbe hasta 200 de daño. Mientras el escudo está activo: reflejas 30% del daño bloqueado como proyectiles mágicos, y cada 2s dispara un pulso arcano (radio 150, 30 daño). El escudo dura 8s o hasta que absorba todo el daño. Si el escudo expira sin romperse, explota causando 100 daño AoE.' }
                    ],
                    semiUltimate: {
                        id: 'mystic_avatar',
                        name: 'Avatar Astral Trascendente',
                        type: 'semi-ultimate',
                        cooldown: 18000,
                        currentCooldown: 0,
                        keyBinding: 'a',
                        effectId: 'effect_avatar',
                        icon: '👁️',
                        iconImage: 'assets/avatarastral.jpg',
                        description: 'NUEVA SEMI-ULTIMATE: Tu espíritu abandona tu cuerpo y se eleva como un Avatar Astral gigante (3x tamaño). Tu cuerpo físico es invulnerable mientras el avatar existe. El Avatar: flota libremente, atraviesa paredes, causa 50 daño al tocar enemigos, y puede usar tus habilidades sin cooldown. Duración: 8s. Al regresar a tu cuerpo, liberas una onda de energía astral (radio 300, 80 daño).'
                    },
                    ultimateAbility: {
                        id: 'mystic_ultimate',
                        name: 'Apocalipsis Arcano',
                        type: 'ultimate',
                        cooldown: 25000,
                        currentCooldown: 0,
                        keyBinding: 's',
                        effectId: 'effect_arcane_storm',
                        icon: '🌌',
                        iconImage: 'assets/apocalipsisarcano.jpg',
                        description: 'REWORK DEVASTADOR: Canalizas el poder de todas las dimensiones arcanas. El cielo se resquebraja revelando el vacío cósmico. Flotas al centro con 8 runas gigantes orbitando tu cuerpo mientras llueven meteoros arcanos (15 meteoros, 60 daño c/u). Simultáneamente, cadenas cósmicas emergen atrapando a TODOS los enemigos. Eres INVULNERABLE 6s. Durante la canalización: regeneras 25 HP/s, tus stats aumentan +100%, y cada enemigo que muere libera una explosión arcana (radio 100, 40 daño). Al finalizar, las runas convergen en ti y explotan en una supernova arcana (radio 500, 200 daño).'
                    }
                },
                // S TIER - REWORK: WILD BERSERKER
                {
                    id: 'class_berserker',
                    name: 'Wild Berserker',
                    type: 'class',
                    tier: 'S',
                    tierColor: '#DC143C', // Carmesí
                    ticketsRequired: 3,
                    imagePath: 'assets/wild_berserker_icon.png',
                    icon: '🪓',
                    title: 'Avatar de la Destrucción Primigenia',
                    description: 'REWORK v2.0 - Guerrero salvaje que ha abrazado la locura del combate. Cada herida recibida alimenta su furia incontenible. La sangre de sus enemigos es su elixir de poder. No conoce el miedo, solo la sed de destrucción.',
                    passiveSystem: {
                        name: 'Sed de Batalla',
                        description: 'Cuanto menos HP tengas, más poderoso eres: <50% HP = +50% daño, +30% velocidad. <25% HP = +100% daño, +60% velocidad, inmune a aturdimientos. <10% HP = +200% daño, +100% velocidad, robo de vida 20%, inmune a todo CC. Cada kill restaura 10% HP.'
                    },
                    abilities: [
                        { id: 'berserker_rage', name: 'Ira del Titán Carmesí', type: 'standard', cooldown: 3500, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_rage', icon: '🔥', iconImage: 'assets/iraimparable.jpg', description: 'REWORK ÉPICO: Sacrificas 15% HP para entrar en estado de furia total. Por 10s: +80% daño, +50% velocidad de ataque, +40% velocidad movimiento. Tus ojos brillan carmesí y dejas un rastro de fuego. Cada golpe tiene 20% de causar CRÍTICO x2.5. Si matas mientras está activo, se extiende 3s.' },
                        { id: 'berserker_whirlwind', name: 'Torbellino Devorador', type: 'standard', cooldown: 4000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_whirlwind', icon: '🌪️', iconImage: 'assets/hachagiratoria.jpg', description: 'REWORK: Giras violentamente durante 4s creando un vórtice de destrucción (radio 180). ATRAE enemigos hacia ti con fuerza imparable mientras los trituras (40 daño/s). Inmune a knockback durante el giro. Al terminar, liberas una onda expansiva que lanza enemigos y causa 60 daño.' },
                        { id: 'berserker_axes', name: 'Hacha del Juicio Final', type: 'standard', cooldown: 6000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_axes', icon: '🪓', iconImage: 'assets/doblehacha.jpg', description: 'REWORK: Saltas al aire y caes con un golpe devastador. El impacto: causa 100 daño en el centro, 50 daño en radio 150, aturde 3s, rompe armaduras (-50% defensa por 8s), y crea fisuras en el suelo que causan daño continuo (20/s por 4s).' },
                        { id: 'berserker_bloodlust', name: 'Sed de Sangre Eterna', type: 'standard', cooldown: 10000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_bloodlust', icon: '🩸', iconImage: 'assets/frenesidebatalla.jpg', description: 'NUEVA: Marcas a todos los enemigos en radio 300 con "Sed de Sangre". Por 12s: cada golpe a enemigos marcados te cura 8% del daño infligido, +40% daño contra marcados, y si matas a un marcado, explotan causando 50 daño AoE y restaurándote 25 HP.' }
                    ],
                    semiUltimate: {
                        id: 'berserker_transform',
                        name: 'Transformación del Berserker',
                        type: 'semi-ultimate',
                        cooldown: 16000,
                        currentCooldown: 0,
                        keyBinding: 'a',
                        effectId: 'effect_transform',
                        icon: '👹',
                        iconImage: 'assets/cortesorpresa.jpg',
                        description: 'NUEVA SEMI-ULTIMATE: Tu cuerpo se transforma en una bestia de guerra. Creces 150%, ganas +100% HP temporal, +60% daño, inmune a CC. Tu piel se vuelve carmesí con venas de fuego. Tus ataques causan ondas de choque (radio 100, 30 daño). Duración: 12s. Al terminar, liberas toda la furia acumulada en una explosión (daño = daño recibido durante transformación).'
                    },
                    ultimateAbility: {
                        id: 'berserker_ultimate',
                        name: 'Apocalipsis del Dios Carmesí',
                        type: 'ultimate',
                        cooldown: 24000,
                        currentCooldown: 0,
                        keyBinding: 's',
                        effectId: 'effect_apocalypse',
                        icon: '💀',
                        iconImage: 'assets/frenesidebatalla.jpg',
                        description: 'REWORK LEGENDARIO: Te conviertes en el DIOS CARMESÍ DE LA DESTRUCCIÓN. Transformación épica: Tamaño x3, cuernos de fuego, alas de energía carmesí, hachas duplicadas brillando con fuego infernal. Por 8s: INVULNERABLE, +300% daño, robo de vida 50%, velocidad x2. Cada kill durante el ultimate: +20% daño permanente (máx +100%). Tus ataques causan explosiones (radio 150, 80 daño). Al terminar, clavas ambas hachas en el suelo causando un terremoto masivo (radio 500, 200 daño) y un grito que aturde 4s.'
                    }
                },

                {
                    id: 'class_ninja',
                    name: 'Shadow Ninja',
                    type: 'class',
                    tier: 'A',
                    tierColor: '#9d4edd',
                    ticketsRequired: 5,
                    imagePath: 'assets/shadowninja.jpg',
                    icon: '🥷',
                    description: 'Maestro de las sombras que ataca desde la oscuridad con letalidad absoluta',
                    abilities: [
                        { id: 'ninja_shadow_strike', name: 'Golpe de Sombra', type: 'standard', cooldown: 3500, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_shadow_strike', icon: '🗡️', description: 'Dash rápido hacia el enemigo más cercano infligiendo daño crítico. Deja una estela de sombras que daña a enemigos que la atraviesen.' },
                        { id: 'ninja_shuriken', name: 'Marca de Muerte', type: 'standard', cooldown: 5000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_shuriken', icon: '⚔️', description: 'Marca a los 3 enemigos más cercanos. Los enemigos marcados reciben 30% más daño por 8 segundos.' },
                        { id: 'ninja_smoke', name: 'Paso Fantasma', type: 'standard', cooldown: 6000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_smoke', icon: '👤', description: 'Te teletransportas detrás del enemigo más cercano, infliges un golpe crítico y te vuelves invisible por 2 segundos.' },
                        { id: 'ninja_clone', name: 'Clon de Sombra', type: 'standard', cooldown: 8000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_clone', icon: '👥', description: 'Crea 2 clones de sombra que atacan a enemigos cercanos durante 6 segundos. Los clones infligen 50% de tu daño.' }
                    ],
                    ultimateAbility: { id: 'ninja_ultimate', name: 'Asesino de Sombras', type: 'ultimate', cooldown: 17000, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_assassin', icon: '💀', description: 'Ejecuta instantáneamente a todos los enemigos con menos del 30% de HP. Inflige daño masivo a los demás y te vuelves invisible por 4 segundos.' }
                },
                {
                    id: 'class_wind_master',
                    name: 'Wind Master',
                    type: 'class',
                    tier: 'S',
                    tierColor: '#ff0080',
                    ticketsRequired: 3,
                    imagePath: 'assets/windmaster.jpg',
                    icon: '🌀',
                    description: 'Maestro supremo del viento que controla el aire tóxico y radioactivo para devastar enemigos. Sus mobs son extremadamente peligrosos.',
                    abilities: [
                        { id: 'wind_radioactive', name: 'Viento Radioactivo', type: 'standard', cooldown: 3800, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_radioactive', icon: '☢️', description: 'Lanza viento radioactivo en 4 direcciones que aplica daño continuo por radiación a los enemigos afectados.' },
                        { id: 'wind_bubbles', name: 'Burbujas de Aire Tóxico', type: 'standard', cooldown: 3200, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_toxic', icon: '🟢', description: 'Crea 5 burbujas tóxicas que explotan al contacto con enemigos, causando daño en írea.' },
                        { id: 'wind_ventoso', name: 'Ventoso', type: 'standard', cooldown: 5000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_ventoso', icon: '💨', description: 'Genera un viento poderoso que empuja a los enemigos lejos de ti y los ralentiza.' },
                        { id: 'wind_ciclon', name: 'Ciclón', type: 'standard', cooldown: 7000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_ciclon', icon: '🌀', description: 'Crea un ciclón que atrae a los enemigos hacia su centro y los daña continuamente.' }
                    ],
                    ultimateAbility: { id: 'wind_ultimate', name: 'Atracción del Viento Fuerte', type: 'ultimate', cooldown: 18000, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_wind_pull', icon: '🌪️', description: 'Desata un viento devastador que atrae a todos los enemigos hacia ti y los aplasta con presión atmosfírica.' }
                },
                // B TIER (8 tickets required)
                {
                    id: 'class_samurai',
                    name: 'Ronin Samurai',
                    type: 'class',
                    tier: 'B',
                    tierColor: '#38bdf8',
                    ticketsRequired: 8,
                    imagePath: 'assets/roninsamurai.jpg',
                    icon: '⚔️',
                    title: 'Disciplina del Acero Silente',
                    description: 'REWORK v3.0 - Clase inicial de control y precision. Combina cortes de iaido, parries y niebla tactica para dominar duelos y limpiar grupos.',
                    abilities: [
                        { id: 'samurai_dash', name: 'Iaido Relampago', type: 'standard', cooldown: 3000, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_iaido', icon: '🗡️', description: 'Dash de corte lineal. Golpea enemigos en trayectoria, aplica sangrado breve y reposiciona al instante.' },
                        { id: 'samurai_counter', name: 'Parada del Ronin', type: 'standard', cooldown: 5500, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_parry', icon: '🛡️', description: 'Entras en postura defensiva. Si recibes impacto, bloqueas gran parte del dano y respondes con corte de ruptura.' },
                        { id: 'samurai_ninja_power', name: 'Niebla Silente', type: 'standard', cooldown: 12000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_ninja_power', icon: '👤', description: 'Despliegas niebla de combate, ganas movilidad, invisibilidad corta y debuffeas enemigos dentro del humo.' },
                        { id: 'samurai_surprise_cut', name: 'Secuencia de Tres Cortes', type: 'standard', cooldown: 6500, currentCooldown: 0, keyBinding: 't', effectId: 'effect_surprise_cut', icon: '⚡', description: 'Encadenas 3 tajos al objetivo mas cercano con ejecucion extra contra enemigos debilitados.' }
                    ],
                    ultimateAbility: { id: 'samurai_ultimate', name: 'Kyokujin: Danza de Acero', type: 'ultimate', cooldown: 19000, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_thousand', icon: '⚔️', description: 'Tormenta circular de tajos con 3 fases: atraccion ligera, rafaga multi-hit y corte final que ignora parte de la defensa.' }
                }
            ],

            // FRUITS = Special powers
            fruits: [
                {
                    id: 'fruit_inferno',
                    name: 'Inferno Fruit',
                    type: 'fruit',
                    imagePath: 'assets/fruits/inferno.png',
                    icon: '🔥',
                    description: 'Grants mastery over flames',
                    abilities: [
                        { id: 'inferno_blast', name: 'Fire Blast', type: 'standard', cooldown: 2500, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_fire_blast', icon: '🔥' },
                        { id: 'inferno_wall', name: 'Flame Wall', type: 'standard', cooldown: 4000, currentCooldown: 0, keyBinding: 's', effectId: 'effect_flame_wall', icon: '🧡' }
                    ],
                    ultimateAbility: { id: 'inferno_ultimate', name: 'Inferno Nova', type: 'ultimate', cooldown: 15000, currentCooldown: 0, keyBinding: 'd', effectId: 'effect_inferno_nova', icon: '💥' }
                },
                {
                    id: 'fruit_glacier',
                    name: 'Glacier Fruit',
                    type: 'fruit',
                    imagePath: 'assets/fruits/glacier.png',
                    icon: '❄️',
                    description: 'Controls ice and frost',
                    abilities: [
                        { id: 'glacier_shard', name: 'Ice Shard', type: 'standard', cooldown: 2500, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_ice_shard', icon: '🧊' },
                        { id: 'glacier_freeze', name: 'Deep Freeze', type: 'standard', cooldown: 5000, currentCooldown: 0, keyBinding: 's', effectId: 'effect_freeze', icon: '❄️' }
                    ],
                    ultimateAbility: { id: 'glacier_ultimate', name: 'Eternal Winter', type: 'ultimate', cooldown: 18000, currentCooldown: 0, keyBinding: 'd', effectId: 'effect_winter', icon: '🌨️' }
                },
                {
                    id: 'fruit_storm',
                    name: 'Storm Fruit',
                    type: 'fruit',
                    imagePath: 'assets/fruits/storm.png',
                    icon: '⚡',
                    description: 'Commands thunder and lightning',
                    abilities: [
                        { id: 'storm_bolt', name: 'Lightning Bolt', type: 'standard', cooldown: 2000, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_lightning', icon: '⚡' },
                        { id: 'storm_field', name: 'Thunder Field', type: 'standard', cooldown: 4500, currentCooldown: 0, keyBinding: 's', effectId: 'effect_thunder_field', icon: '🌩️' }
                    ],
                    ultimateAbility: { id: 'storm_ultimate', name: 'Tempest Rage', type: 'ultimate', cooldown: 16000, currentCooldown: 0, keyBinding: 'd', effectId: 'effect_tempest', icon: '🌪️' }
                },
                {
                    id: 'fruit_void',
                    name: 'Void Fruit',
                    type: 'fruit',
                    imagePath: 'assets/fruits/void.png',
                    icon: '🕳️',
                    description: 'Manipulates darkness and gravity',
                    abilities: [
                        { id: 'void_hole', name: 'Void Hole', type: 'standard', cooldown: 3000, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_void_hole', icon: '⚫' },
                        { id: 'void_pull', name: 'Gravity Pull', type: 'standard', cooldown: 4000, currentCooldown: 0, keyBinding: 's', effectId: 'effect_gravity', icon: '🌑' }
                    ],
                    ultimateAbility: { id: 'void_ultimate', name: 'Singularity', type: 'ultimate', cooldown: 17000, currentCooldown: 0, keyBinding: 'd', effectId: 'effect_singularity', icon: '🕳️' }
                },
                {
                    id: 'fruit_radiance',
                    name: 'Radiance Fruit',
                    type: 'fruit',
                    imagePath: 'assets/fruits/radiance.png',
                    icon: '✨',
                    description: 'Harnesses pure light energy',
                    abilities: [
                        { id: 'radiance_beam', name: 'Light Beam', type: 'standard', cooldown: 2000, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_light_beam', icon: '💡' },
                        { id: 'radiance_speed', name: 'Light Speed', type: 'standard', cooldown: 6000, currentCooldown: 0, keyBinding: 's', effectId: 'effect_light_speed', icon: '⚡' }
                    ],
                    ultimateAbility: { id: 'radiance_ultimate', name: 'Solar Flare', type: 'ultimate', cooldown: 14000, currentCooldown: 0, keyBinding: 'd', effectId: 'effect_solar', icon: '☀️' }
                },
                {
                    id: 'fruit_nature',
                    name: 'Nature Fruit',
                    type: 'fruit',
                    imagePath: 'assets/fruits/nature.png',
                    icon: '🌿',
                    description: 'Controls plants and life force',
                    abilities: [
                        { id: 'nature_vine', name: 'Vine Whip', type: 'standard', cooldown: 2800, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_vine', icon: '🌱' },
                        { id: 'nature_growth', name: 'Rapid Growth', type: 'standard', cooldown: 5500, currentCooldown: 0, keyBinding: 's', effectId: 'effect_growth', icon: '🌳' }
                    ],
                    ultimateAbility: { id: 'nature_ultimate', name: 'Forest Awakening', type: 'ultimate', cooldown: 19000, currentCooldown: 0, keyBinding: 'd', effectId: 'effect_forest', icon: '🌲' }
                }
            ],

            // MASTER CLASSES - Unlocked through mastery missions
            masterClasses: [
                {
                    id: 'master_storm_of_tornados',
                    name: 'Tornado Overlord',
                    type: 'master_class',
                    tier: 'MASTER',
                    tierColor: '#ff00ff',
                    baseClassId: 'class_wind_master',
                    imagePath: 'assets/tornadooverlord.jpg',
                    icon: '🌪️',
                    description: 'Versión maestra del Wind Master. Dominio absoluto sobre tormentas devastadoras y vientos apocalípticos.',
                    abilities: [
                        { id: 'master_singularity', name: 'Singularidad Eólica', type: 'standard', cooldown: 8000, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_singularity', icon: '⚫', description: 'Crea una esfera de vacío estática que atrae a todos los enemigos cercanos hacia su centro y los aturde por 3 segundos.' },
                        { id: 'master_pressure', name: 'Presión Atmosférica', type: 'standard', cooldown: 7000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_pressure', icon: '🛡️', description: 'Aumenta la presión del aire hacia abajo, inmovilizando enemigos por 2s y rompiendo su armadura (Defensa 0, +20% daño recibido) por 4s.' },
                        { id: 'master_tornado_barrage', name: 'Ráfaga de Tornados', type: 'standard', cooldown: 3500, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_tornado_barrage', icon: '🌀', description: 'Lanza 5 tornados que atraviesan enemigos, causando daño y confusión por 4 segundos.' },
                        { id: 'master_storm_shield', name: 'Escudo de Tormenta', type: 'standard', cooldown: 6000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_storm_shield', icon: '🛡️', description: 'Crea un escudo que te hace invulnerable por 4s y reduce el daño recibido en 30% por 6s adicionales.' }
                    ],
                    semiUltimate: { id: 'master_enemy_tornado', name: 'Tornado de Enemigo', type: 'semi_ultimate', cooldown: 15000, currentCooldown: 0, keyBinding: 's', effectId: 'effect_enemy_tornado', icon: '🌪️', description: 'Toma al enemigo más cercano y lo hace girar creando un tornado masivo. Empuja y daña gravemente a otros enemigos, luego lanza a la víctima y genera 4 tormentas estáticas. Aplica Viento Fuerte por 7s.' },
                    ultimateAbility: { id: 'master_apocalyptic_storm', name: 'Tormenta Apocalíptica', type: 'ultimate', cooldown: 25000, currentCooldown: 0, keyBinding: 'd', effectId: 'effect_apocalyptic', icon: '☄️', description: 'Desata una tormenta apocalíptica que atrae enemigos, inflige daño masivo, aplica confusión y radioactividad, y lanza 20 tornados devastadores. +50% daño por 10s.' },
                    masteryMission: {
                        title: 'Dominio de la Tormenta',
                        description: 'Demuestra tu maestría sobre el viento completando estos desafíos extremos',
                        requirements: [
                            { id: 'kill_tempest_lord', type: 'kill_boss', target: 'tempest_lord', amount: 5, current: 0, description: 'Derrota al Tempest Lord 5 veces' },
                            { id: 'kill_with_wind', type: 'kill_count', classId: 'class_wind_master', amount: 100, current: 0, description: 'Elimina 100 enemigos usando Wind Master' },
                            { id: 'survive_raid', type: 'survive_waves', classId: 'class_wind_master', waves: 15, current: 0, description: 'Sobrevive 15 oleadas en una raid usando Wind Master' },
                            { id: 'deal_damage', type: 'damage_dealt', classId: 'class_wind_master', amount: 50000, current: 0, description: 'Inflige 50,000 de daño total con Wind Master' }
                        ]
                    }
                },
                {
                    id: 'master_cybernetic_warlord',
                    name: 'Cybernetic Warlord',
                    type: 'master_class',
                    tier: 'MASTER',
                    tierColor: '#00ffff',
                    baseClassId: 'class_gunslinger',
                    imagePath: 'assets/cyberneticwarlord.jpg',
                    icon: '🤖',
                    description: 'Versión maestra del Cyber Gunslinger. Tecnología de guerra avanzada con sistema de calor y armamento devastador.',
                    passiveSystem: {
                        name: 'Sistema de Calor',
                        description: 'Cada disparo aumenta el calor. >50%: Doble daño. 100%: Sobrecarga (explosión AoE + Silencio 2s)'
                    },
                    abilities: [
                        { id: 'cyber_plasma_cannon', name: 'Cañón de Plasma', type: 'standard', cooldown: 5000, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_plasma_cannon', icon: '🔫', description: 'Dispara un rayo láser grueso continuo que atraviesa todos los enemigos en línea recta. Genera +15% Calor.' },
                        { id: 'cyber_singularity_grenade', name: 'Granada de Singularidad', type: 'standard', cooldown: 8000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_singularity_grenade', icon: '💣', description: 'Lanza un dispositivo que crea un campo de gravedad, atrayendo enemigos por 2s antes de detonar con daño masivo.' },
                        { id: 'cyber_drone_swarm', name: 'Enjambre de Drones', type: 'standard', cooldown: 12000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_drone_swarm', icon: '🛸', description: 'Despliega 4 drones que orbitan alrededor del jugador por 8s, disparando láseres automíticamente.' },
                        { id: 'cyber_photon_barrier', name: 'Barrera de Fotones', type: 'standard', cooldown: 15000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_photon_barrier', icon: '🛡️', description: 'Despliega un muro de energía estático que dura 5s. Bloquea enemigos y los quema al contacto. Puedes disparar a travís.' }
                    ],
                    semiUltimate: { id: 'cyber_mech_suit', name: 'Protocolo: MECH-SUIT', type: 'semi_ultimate', cooldown: 20000, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_mech_suit', icon: '🦾', description: 'Invoca armadura pesada que cae del cielo. Durante 10s: -20% velocidad, +80% defensa, ataques se convierten en misiles teledirigidos.' },
                    ultimateAbility: { id: 'cyber_orbital_ragnarok', name: 'Satélite Orbital "Ragnarok"', type: 'ultimate', cooldown: 30000, currentCooldown: 0, keyBinding: 'f', effectId: 'effect_orbital_ragnarok', icon: '🛰️', description: 'Marca una zona. Tras 3s, un rayo láser masivo vaporiza todo (9999 daño puro) y deja suelo quemado por 5s.' },
                    masteryMission: {
                        title: 'Supremacía Cibernética',
                        description: 'Demuestra tu dominio sobre la tecnología de guerra avanzada',
                        requirements: [
                            { id: 'kill_mech_titan', type: 'kill_boss', target: 'mech_titan', amount: 3, current: 0, description: 'Derrota al Mech Titan 3 veces' },
                            { id: 'kill_combat_drones', type: 'kill_specific', target: 'combat_drone', amount: 50, current: 0, description: 'Elimina 50 Combat Drones' },
                            { id: 'kill_with_gunslinger', type: 'kill_count', classId: 'class_gunslinger', amount: 100, current: 0, description: 'Elimina 100 enemigos usando Cyber Gunslinger' },
                            { id: 'use_orbital_strike', type: 'ability_usage', abilityId: 'gun_ultimate', amount: 15, current: 0, description: 'Usa Orbital Strike 15 veces' }
                        ]
                    }
                },
                {
                    id: 'master_abyssal_shadowlord',
                    name: 'Abyssal Shadowlord',
                    type: 'master_class',
                    tier: 'MASTER',
                    tierColor: '#2f2f2f',
                    baseClassId: 'class_ninja',
                    imagePath: 'assets/abyssalshadowlord.jpg',
                    icon: '👹',
                    description: 'Versión maestra del Shadow Ninja. Dominio absoluto sobre el Reino de las Sombras con clones legionarios y oscuridad que ciega enemigos.',
                    passiveSystem: {
                        name: 'Abismo Letal',
                        description: 'Cada kill genera esencia sombra (+10% crítico stackeable hasta 5 stacks). Resetea al morir.'
                    },
                    abilities: [
                        { id: 'abyssal_blade_storm', name: 'Tormenta de Cuchillas Sombrías', type: 'standard', cooldown: 3000, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_blade_storm', icon: '🗡️', description: 'Dash múltiple con 5 slashes giratorios. Deja estelas que causan DoT y ralentizan 50%.' },
                        { id: 'abyssal_death_chain', name: 'Cadena de Muerte', type: 'standard', cooldown: 4000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_death_chain', icon: '⛓️', description: 'Marca 6 enemigos en cadena (+40% daño recibido). El daño salta entre targets cercanos.' },
                        { id: 'abyssal_void_leap', name: 'Salto al Vacío Fantasma', type: 'standard', cooldown: 5000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_void_leap', icon: '👤', description: 'TP detrás del boss/enemigo elite + crítico x2 + AoE oscuridad que ciega 3s y reduce visión enemiga.' },
                        { id: 'abyssal_shadow_legion', name: 'Legión de Sombras', type: 'standard', cooldown: 8000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_shadow_legion', icon: '👥', description: 'Invoca 5 clones (75% de tu daño, duran 8s). Explotan al morir causando 60 de daño.' }
                    ],
                    semiUltimate: { id: 'abyssal_shadow_emperor', name: 'Emperador Sombra', type: 'semi_ultimate', cooldown: 15000, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_shadow_emperor', icon: '👑', description: 'Invoca un mini-boss sombra (200 HP) que ataca independientemente y copia tus ataques bísicos.' },
                    ultimateAbility: { id: 'abyssal_eternal_night', name: 'Noche Eterna', type: 'ultimate', cooldown: 25000, currentCooldown: 0, keyBinding: 'r', effectId: 'effect_eternal_night', icon: '🌑', description: 'Oscurece toda la pantalla 6s. Ejecuta enemigos <25% HP en cadena (salta 10x) + DoT masivo. Tí invisible + 50% velocidad permanente durante.' },
                    masteryMission: {
                        title: 'Señor del Abismo',
                        description: 'Demuestra tu dominio sobre las sombras completando estos desafíos letales',
                        requirements: [
                            { id: 'kill_shadow_emperor', type: 'kill_boss', target: 'shadow_emperor', amount: 3, current: 0, description: 'Derrota al Shadow Emperor 3 veces' },
                            { id: 'kill_with_ninja', type: 'kill_count', classId: 'class_ninja', amount: 150, current: 0, description: 'Elimina 150 enemigos usando Shadow Ninja' },
                            { id: 'survive_ninja_raid', type: 'survive_waves', classId: 'class_ninja', waves: 20, current: 0, description: 'Sobrevive 20 oleadas en una raid usando Shadow Ninja' },
                            { id: 'use_silent_execution', type: 'ability_usage', abilityId: 'ninja_ultimate', amount: 12, current: 0, description: 'Usa Asesino de Sombras 12 veces' }
                        ]
                    }
                },
                // ===== NUEVA MAESTRÍA: IMPERATOR AETERNUS (Legionario Romano) =====
                {
                    id: 'master_imperator_aeternus',
                    name: 'Imperator Aeternus',
                    type: 'master_class',
                    tier: 'MASTER',
                    tierColor: '#FFD700', // Oro Imperial
                    baseClassId: 'class_roman_legionary',
                    imagePath: 'assets/imperatoraeternus.jpg',
                    icon: '👑',
                    title: 'Emperador Eterno de Roma',
                    description: 'La forma maestra del Legionario Romano. Has transcendido de soldado a DIOS EMPERADOR. Comandas legiones infinitas y portas la bendición de Júpiter, Marte y Victoria. Roma es ETERNA contigo.',
                    passiveSystem: {
                        name: 'Gloria Imperial',
                        description: 'Cada kill otorga "Gloria" (+3% daño, +2% defensa, máx 20 stacks). A 10 stacks, invocas un Centurión Fantasma que lucha a tu lado. A 20 stacks, te coronas con laureles dorados y tus habilidades cuestan 0 cooldown por 5s.'
                    },
                    abilities: [
                        { id: 'imperator_divine_gladius', name: 'Gladius del Dios Emperador', type: 'standard', cooldown: 2000, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_divine_gladius', icon: '⚔️', description: 'Combo de 7 estocadas divinas a velocidad sobrehumana. Cada golpe causa 50 daño + "Marca Imperial" (+25% daño recibido). El 7° golpe ejecuta enemigos <20% HP instantáneamente.' },
                        { id: 'imperator_jupiter_shield', name: 'Escudo de Júpiter', type: 'standard', cooldown: 10000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_jupiter_shield', icon: '⚡', description: 'Júpiter te bendice con su escudo de rayos. Invulnerable 5s. Cada golpe bloqueado lanza un rayo (80 daño) al atacante. Al terminar, una tormenta eléctrica golpea a todos los enemigos (100 daño AoE).' },
                        { id: 'imperator_mars_wrath', name: 'Furia de Marte', type: 'standard', cooldown: 8000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_mars_wrath', icon: '🔥', description: 'Marte posee tu cuerpo. Por 10s: Daño x2, velocidad +80%, ataques incendian (30 daño/s). Cada kill extiende la duración 2s. Dejas un rastro de fuego sagrado que daña enemigos.' },
                        { id: 'imperator_victoria_blessing', name: 'Bendición de Victoria', type: 'standard', cooldown: 15000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_victoria', icon: '🏆', description: 'La diosa Victoria te corona. Por 12s: Crítico garantizado, robo de vida 25%, inmune a CC. Generas un aura dorada que aturde enemigos cercanos cada 2s. Cada kill restaura 15% HP.' }
                    ],
                    semiUltimate: { id: 'imperator_praetorian_guard', name: 'Guardia Pretoriana Divina', type: 'semi_ultimate', cooldown: 18000, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_praetorian', icon: '🛡️', description: 'Invocas 8 Pretorianos de Élite dorados que te rodean en formación. Cada uno tiene 200 HP, causa 40 daño, y te protegen con sus cuerpos. Duran 15s o hasta morir. Al morir explotan en luz dorada (60 daño AoE).' },
                    ultimateAbility: { id: 'imperator_rome_eternal', name: 'Roma Aeterna: Juicio del Emperador', type: 'ultimate', cooldown: 30000, currentCooldown: 0, keyBinding: 's', effectId: 'effect_rome_eternal', icon: '🏛️', description: 'ULTIMATE DIVINO: El Coliseo se materializa alrededor del campo de batalla. El cielo se tiñe de púrpura imperial. 50 Legionarios Dorados emergen en formación perfecta mientras tú asciendes como DIOS EMPERADOR con toga púrpura, corona de laureles, y aura solar. Por 8s: INVULNERABLE, +500% daño. Los legionarios ejecutan TODO. Cada enemigo eliminado restaura 10% HP. Al finalizar, alzas tu gladius y un rayo de Júpiter cae del cielo (radio 1000, 500 daño). Efectos: Luz dorada cegadora, águilas imperiales volando, cánticos de guerra romanos.' },
                    masteryMission: {
                        title: 'Ascensión Imperial',
                        description: 'Demuestra que eres digno del trono eterno de Roma',
                        requirements: [
                            { id: 'kill_barbarian_king', type: 'kill_boss', target: 'barbarian_king', amount: 5, current: 0, description: 'Derrota al Rey Bárbaro 5 veces' },
                            { id: 'kill_with_legionary', type: 'kill_count', classId: 'class_roman_legionary', amount: 300, current: 0, description: 'Elimina 300 enemigos usando Legionario Romano' },
                            { id: 'survive_legionary_raid', type: 'survive_waves', classId: 'class_roman_legionary', waves: 25, current: 0, description: 'Sobrevive 25 oleadas usando Legionario Romano' },
                            { id: 'use_legio_aeterna', type: 'ability_usage', abilityId: 'roman_legio', amount: 15, current: 0, description: 'Usa Legio Aeterna Invicta 15 veces' }
                        ]
                    }
                },
                // ===== NUEVA MAESTRÍA: GUERRERO INMORTAL DE ESPARTA (Hoplita Espartano) =====
                {
                    id: 'master_immortal_spartan',
                    name: 'Guerrero Inmortal de Esparta',
                    type: 'master_class',
                    tier: 'MASTER',
                    tierColor: '#8B0000', // Rojo Espartano
                    baseClassId: 'class_spartan_hoplite',
                    imagePath: 'assets/immortalspartan.jpg',
                    icon: '⚔️',
                    title: 'El Último de los 300',
                    description: 'La forma maestra del Hoplita Espartano. El espíritu del Rey Leónidas te ha bendecido. Eres la encarnación viviente de Esparta: inmortal, imparable, LEGENDARIO. "Ven y tómalas" es tu credo eterno.',
                    passiveSystem: {
                        name: 'Espíritu de los 300',
                        description: 'Nunca puedes ser reducido a menos de 1 HP mientras tengas "Voluntad Espartana" (se carga matando 10 enemigos). Al activarse, eres invulnerable 3s y ganas +100% daño. Cada kill bajo 30% HP otorga +5% daño permanente durante la raid (máx +50%).'
                    },
                    abilities: [
                        { id: 'immortal_leonidas_spear', name: 'Lanza del Rey Leónidas', type: 'standard', cooldown: 2500, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_leonidas_spear', icon: '🔱', description: 'Lanzas la lanza legendaria de Leónidas con furia divina. Atraviesa INFINITOS enemigos causando 100 daño + sangrado letal (40 daño/s por 6s). Si mata, REBOTA indefinidamente hasta que no mate. Cada rebote +20% daño.' },
                        { id: 'immortal_phalanx_wall', name: 'Muro de la Falange Inmortal', type: 'standard', cooldown: 12000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_phalanx_wall', icon: '🛡️', description: 'Invocas los espíritus de los 300 para formar un MURO DE ESCUDOS IMPENETRABLE. Frente: 100% inmune. Lados: 80% reducción. Por 8s, el muro avanza lentamente aplastando todo. Los enemigos que toquen el muro son destrozados (150 daño + aturde 4s).' },
                        { id: 'immortal_ares_possession', name: 'Posesión de Ares', type: 'standard', cooldown: 15000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_ares_possession', icon: '👹', description: 'Ares POSEE completamente tu cuerpo. Transformación: Ojos de fuego, aura carmesí, capa de sangre. Por 12s: Daño x3, robo de vida 40%, velocidad x2, inmune a TODO. Cada kill genera una explosión de sangre (80 daño AoE). Al terminar, Ares ruge causando terror (enemigos huyen 3s).' },
                        { id: 'immortal_war_cry', name: '¡MOLON LABE! Rugido de Guerra', type: 'standard', cooldown: 18000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_molon_labe', icon: '📯', description: 'Ruges "¡VEN Y TÓMALAS!" con la fuerza de 300 espartanos. Onda de choque masiva (radio 500): 100 daño, enemigos aturdidos 5s, -70% daño por 10s. Tú y aliados: +100% daño, +50% velocidad, regeneración 20 HP/s por 10s.' }
                    ],
                    semiUltimate: { id: 'immortal_spartan_charge', name: 'Carga de los 300', type: 'semi_ultimate', cooldown: 20000, currentCooldown: 0, keyBinding: 'a', effectId: 'effect_300_charge', icon: '⚡', description: '30 Hoplitas Espectrales cargan contigo en formación de cuña. Dash de 800 unidades atravesando TODO. Cada hoplita causa 40 daño. Los enemigos impactados son empalados y arrastrados. Al finalizar: explosión de lanzas (200 daño AoE). "¡AROO! ¡AROO! ¡AROO!"' },
                    ultimateAbility: { id: 'immortal_thermopylae_eternal', name: 'Las Termópilas Eternas: Última Defensa', type: 'ultimate', cooldown: 35000, currentCooldown: 0, keyBinding: 's', effectId: 'effect_thermopylae_eternal', icon: '🏛️', description: 'ULTIMATE LEGENDARIO: Las Puertas Calientes se materializan. Nubes de tormenta rojas cubren el cielo. Los 300 Espartanos ORIGINALES emergen del suelo cantando el Paean, liderados por el ESPÍRITU DEL REY LEÓNIDAS que lucha a tu lado (500 HP, 100 daño/golpe). Por 10s: INMORTAL ABSOLUTO (no puedes morir). Los 300 forman la falange perfecta y avanzan destruyendo TODO. Cada espartano tiene 100 HP y causa 60 daño. Al finalizar: TODOS alzan sus lanzas y disparan una LLUVIA MORTAL (300 lanzas, 50 daño c/u). Leónidas ruge "¡ESTA ES ESPARTA!" causando una onda final (radio 800, 400 daño). Colores: Rojo sangre espartano, bronce reluciente, aura dorada de gloria.' },
                    masteryMission: {
                        title: 'La Gloria de los 300',
                        description: 'Demuestra que eres digno del legado de Leónidas',
                        requirements: [
                            { id: 'kill_persian_immortal', type: 'kill_boss', target: 'persian_immortal', amount: 10, current: 0, description: 'Derrota 10 Inmortales Persas' },
                            { id: 'kill_with_spartan', type: 'kill_count', classId: 'class_spartan_hoplite', amount: 300, current: 0, description: 'Elimina 300 enemigos (en honor a los 300)' },
                            { id: 'survive_spartan_raid', type: 'survive_waves', classId: 'class_spartan_hoplite', waves: 30, current: 0, description: 'Sobrevive 30 oleadas (La Última Defensa)' },
                            { id: 'use_thermopylae', type: 'ability_usage', abilityId: 'spartan_thermopylae', amount: 20, current: 0, description: 'Usa Los 300 de las Termópilas 20 veces' }
                        ]
                    }
                },

                // ===== NUEVA MAESTRÍA: GORATH, DIOS DE LA MONTAÑA =====
                {
                    id: 'master_gorath_mountain_god',
                    name: 'Gorath, Dios de la Montaña Eterna',
                    type: 'master_character',
                    tier: 'LEGENDARY',
                    tierColor: '#8B4513', // Marrón tierra
                    baseCharacterId: 'char_titan',
                    imagePath: 'assets/gorathmountaingod.jpg',
                    icon: '🏔️',
                    title: 'La Montaña que Camina',
                    description: 'MAESTRÍA LEGENDARIA - Gorath ha trascendido su forma mortal, fusionándose con el espíritu primigenio de las montañas más antiguas del mundo. Su cuerpo ahora ES la montaña viviente, un titán de roca, magma y cristales ancestrales. Cuando camina, la tierra tiembla. Cuando lucha, continentes se resquebrajan.',
                    passiveSystem: {
                        name: 'Corazón de la Montaña',
                        description: 'Gorath es INMUNE a aturdimientos y knockbacks. Cada 5% de HP perdido aumenta su defensa +3% y genera una onda sísmica (radio 100, 15 daño). Cuando su HP cae bajo 30%, activa "Núcleo de Magma": regenera 5 HP/s, sus ataques queman, y es inmune a daño de fuego. Cada kill otorga +1% HP máximo permanente (máx +25%).'
                    },
                    abilities: [
                        { id: 'gorath_tectonic_slam', name: 'Impacto Tectónico', type: 'standard', cooldown: 3000, currentCooldown: 0, keyBinding: 'q', effectId: 'effect_tectonic_slam', icon: '💥', iconImage: 'assets/impactotectonico.jpg', description: 'Gorath levanta ambos puños y los clava en la tierra con furia primigenia. Genera 5 ondas sísmicas concéntricas (radio 100/200/300/400/500) que causan daño decreciente (100/80/60/40/20) pero aturdimiento creciente (0.5s/1s/1.5s/2s/2.5s). Enemigos en el epicentro son lanzados 200 unidades al aire. El suelo queda fracturado 6s, ralentizando enemigos 60%.' },
                        { id: 'gorath_crystal_fortress', name: 'Fortaleza de Cristal Ancestral', type: 'standard', cooldown: 8000, currentCooldown: 0, keyBinding: 'w', effectId: 'effect_crystal_fortress', icon: '💎', iconImage: 'assets/fortalezadecristal.jpg', description: 'Gorath invoca 12 pilares de cristal que emergen en formación circular (radio 200). Cada cristal tiene 100 HP y refleja 20% del daño recibido como rayos prismáticos. Mientras estás dentro: +80% defensa, regeneras 10 HP/s, inmune a proyectiles. Al destruirse cada cristal, explota causando 40 daño. Puedes reactivar para hacer explotar TODOS los cristales simultáneamente (480 daño total AoE).' },
                        { id: 'gorath_magma_fissure', name: 'Fisura de Magma Primordial', type: 'standard', cooldown: 6000, currentCooldown: 0, keyBinding: 'e', effectId: 'effect_magma_fissure', icon: '🌋', iconImage: 'assets/fisuraddemagma.jpg', description: 'Gorath abre 3 fisuras volcánicas en el suelo que se extienden 400 unidades en 3 direcciones. Cada fisura: erupciona 8 géiseres de magma (50 daño c/u), aplica quemadura (20 daño/s por 5s), y deja charcos de lava persistentes (10s, 30 daño/s al pisar). Los enemigos que mueran sobre la lava generan explosiones volcánicas adicionales.' },
                        { id: 'gorath_earthquake_aura', name: 'Aura del Terremoto Eterno', type: 'standard', cooldown: 12000, currentCooldown: 0, keyBinding: 't', effectId: 'effect_earthquake_aura', icon: '🌍', iconImage: 'assets/auradelterremoto.jpg', description: 'Gorath canaliza el poder telúrico de la tierra misma. Por 15s: El suelo tiembla constantemente en radio 350 a tu alrededor. Efectos: Enemigos sufren -50% velocidad, -30% precisión, y reciben 25 daño/s. Cada 3s, una onda de choque mayor aturde 1s. Tú ganas +50% daño, +30% velocidad, y tus ataques causan knockback.' }
                    ],
                    semiUltimate: {
                        id: 'gorath_mountain_form',
                        name: 'Transformación: Montaña Viviente',
                        type: 'semi-ultimate',
                        cooldown: 20000,
                        currentCooldown: 0,
                        keyBinding: 'a',
                        effectId: 'effect_mountain_form',
                        icon: '🗻',

                        description: 'TRANSFORMACIÓN ÉPICA: Gorath se fusiona completamente con la tierra, convirtiéndose en una MONTAÑA VIVIENTE COLOSAL (5x tamaño original). En esta forma: HP +300%, defensa +100%, velocidad -40% pero cada paso causa terremoto (radio 150, 60 daño). Sus ataques son golpes de montaña: gigantescos, lentos, pero devastadores (200 daño, aturde 3s, destruye terreno). Genera avalanchas de rocas cada 4s que barren en cono (10 rocas, 30 daño c/u). Inmune a TODO control de masas y efectos negativos. Duración: 15s. Al terminar, Gorath golpea el suelo causando un mega-terremoto final (radio 500, 150 daño, aturde 4s).'
                    },
                    ultimateAbility: {
                        id: 'gorath_apocalypse_geological',
                        name: 'Apocalipsis Geológico: El Fin de los Tiempos',
                        type: 'ultimate',
                        cooldown: 35000,
                        currentCooldown: 0,
                        keyBinding: 's',
                        effectId: 'effect_geological_apocalypse',
                        icon: '🌋',

                        description: 'ULTIMATE LEGENDARIO: Gorath ruge con el poder de todas las montañas del mundo. El cielo se oscurece con nubes volcánicas carmesí. La tierra entera se resquebraja bajo sus pies mientras se eleva flotando rodeado de una órbita de rocas, cristales y magma. Por 10s: INVULNERABLE, 30 volcanes erupcionan simultáneamente en el campo de batalla (60 daño c/u), 50 grietas de magma se abren creando un laberinto de fuego, 20 meteoros de roca caen del cielo (80 daño c/u), y una gigantesca serpiente de magma (el espíritu de la montaña) emerge y ataca independientemente (100 HP, 50 daño/golpe). Todos los enemigos sufren "Maldición de la Tierra": -90% velocidad, -80% daño, +100% daño recibido. Al finalizar, Gorath desciende y clava ambos puños causando el MEGA-CATACLISMO FINAL: gigantesca explosión de roca y magma (radio 800, 400 daño), todos los enemigos restantes son enterrados vivos (aturdidos 6s), y tú regeneras 50% HP. Colores: Marrón tierra, naranja magma, cristales prismáticos, y aura dorada ancestral.'
                    },
                    masteryMission: {
                        title: 'Ascensión del Titán',
                        description: 'Demuestra que mereces el poder de la Montaña Eterna completando estos desafíos titánicos',
                        requirements: [
                            { id: 'kill_earth_colossus', type: 'kill_boss', target: 'earth_colossus', amount: 5, current: 0, description: 'Derrota al Coloso de Tierra 5 veces' },
                            { id: 'survive_gorath', type: 'survive_waves', characterId: 'char_titan', waves: 25, current: 0, description: 'Sobrevive 25 oleadas usando Gorath el Titán' },
                            { id: 'block_damage', type: 'damage_blocked', characterId: 'char_titan', amount: 100000, current: 0, description: 'Bloquea 100,000 de daño total con Gorath' },
                            { id: 'use_titan_wrath', type: 'ability_usage', abilityId: 'titan_ultimate', amount: 20, current: 0, description: 'Usa Ira del Coloso 20 veces' },
                            { id: 'kill_with_gorath', type: 'kill_count', characterId: 'char_titan', amount: 500, current: 0, description: 'Elimina 500 enemigos usando Gorath' }
                        ]
                    }
                }
            ]
        };

        // Register missing 2D models for abilities (characters, classes, masteries, fruits)
        (function registerClassMasterAbility2DModels() {
            const iconIds = new Set();
            const collect = (role) => {
                if (!role) return;
                (role.abilities || []).forEach(a => {
                    if (a?.id) iconIds.add(a.id);
                    if (a?.effectId) iconIds.add(a.effectId);
                });
                if (role.semiUltimate?.id) iconIds.add(role.semiUltimate.id);
                if (role.semiUltimate?.effectId) iconIds.add(role.semiUltimate.effectId);
                if (role.ultimateAbility?.id) iconIds.add(role.ultimateAbility.id);
                if (role.ultimateAbility?.effectId) iconIds.add(role.ultimateAbility.effectId);
            };

            (rolesData.characters || []).forEach(collect);
            (rolesData.classes || []).forEach(collect);
            (rolesData.masterClasses || []).forEach(collect);
            (rolesData.fruits || []).forEach(collect);

            iconIds.forEach((iconId) => {
                if (!iconId) return;
                const current = IconRenderer.icons[iconId];
                if (current && !current.__generatedByAbility2DModelFactory) return;
                const generated = Ability2DModelFactory.create(iconId);
                generated.__generatedByAbility2DModelFactory = true;
                IconRenderer.icons[iconId] = generated;
            });
        })();


        // ===== CLASS PROGRESSION SYSTEM =====
        const ClassProgressionSystem = {
            classLevels: {}, // { classId: { level: 1, exp: 0, expToNext: 100 } }
            maxClassLevel: 10,

            // Define unique upgrades for each class
            // Each class has its own progression tree based on its abilities and playstyle
            classUpgrades: {
                // DRAGONHUNTER - Fire and Nature themed
                'class_dragonhunter': {
                    icon: '🐉',
                    name: 'Dragonhunter',
                    upgrades: {
                        2: [{ type: 'damage', bonus: 5, icon: '🏹', description: 'Triple Flecha Flamigera', detail: '+5% Dano de fuego' }],
                        3: [{ type: 'burn_damage', bonus: 10, icon: '🔥', description: 'Quemadura Intensa', detail: '+10% Dano de quemadura' }],
                        4: [{ type: 'nature_heal', bonus: 15, icon: '🌿', description: 'Naturaleza en Ascenso', detail: '+15% Curacion y defensa' }],
                        5: [{ type: 'arrow_count', bonus: 1, icon: '🏹', description: 'Flecha Triple Uso', detail: 'Dispara 1 flecha adicional' }],
                        6: [{ type: 'cooldown', bonus: 10, icon: '⏱️', description: 'Aliento Rapido', detail: '-10% Cooldown' }],
                        7: [{ type: 'crit', bonus: 15, icon: '🎯', description: 'Punteria Mortal', detail: '+15% Critico' }],
                        8: [{ type: 'range', bonus: 20, icon: '📍', description: 'Alcance Draconico', detail: '+20% Rango' }],
                        9: [{ type: 'madness_duration', bonus: 30, icon: '🐉', description: 'Locura Draconica', detail: '+30% Duracion' }],
                        10: [{ type: 'ultimate', bonus: 50, icon: '💥', description: 'EXPLOSION DRACONICA', detail: 'Ultimate +50% dano' }]
                    }
                },

                // SHADOW NINJA - Stealth and assassination
                'class_ninja': {
                    icon: '🥷',
                    name: 'Shadow Ninja',
                    upgrades: {
                        2: [{ type: 'stealth_duration', bonus: 20, icon: '👤', description: 'Paso Fantasma', detail: '+20% Duración de invisibilidad' }],
                        3: [{ type: 'backstab', bonus: 25, icon: '🗡️', description: 'Golpe de Sombra', detail: '+25% Daño desde invisibilidad' }],
                        4: [{ type: 'speed', bonus: 15, icon: '💨', description: 'Paso Silencioso', detail: '+15% Velocidad de movimiento' }],
                        5: [{ type: 'shuriken_count', bonus: 2, icon: '⚔️', description: 'Marca de Muerte', detail: '+2 Enemigos marcados' }],
                        6: [{ type: 'clone_damage', bonus: 30, icon: '👥', description: 'Clon de Sombra', detail: '+30% Daño de clones' }],
                        7: [{ type: 'cooldown', bonus: 15, icon: '⏱️', description: 'Asesino Eficiente', detail: '-15% Cooldown' }],
                        8: [{ type: 'crit', bonus: 20, icon: '🎯', description: 'Golpe Crítico Ninja', detail: '+20% Crítico' }],
                        9: [{ type: 'smoke_radius', bonus: 40, icon: '🌫️', description: 'Velo Expandido', detail: '+40% Radio de humo' }],
                        10: [{ type: 'ultimate', bonus: 100, icon: '💀', description: 'Asesino de Sombras', detail: 'Ultimate +100% daño' }]
                    }
                },

                // WIND MASTER - Wind and toxic abilities
                'class_wind_master': {
                    icon: '🌀',
                    name: 'Wind Master',
                    upgrades: {
                        2: [{ type: 'toxic_damage', bonus: 10, icon: '💚', description: 'Burbujas de Aire Toxico', detail: '+10% Dano de veneno' }],
                        3: [{ type: 'bubble_duration', bonus: 25, icon: '🟢', description: 'Burbujas de Aire Toxico', detail: '+25% Duracion de burbujas' }],
                        4: [{ type: 'wind_speed', bonus: 15, icon: '💨', description: 'Ventoso', detail: '+15% Velocidad de viento' }],
                        5: [{ type: 'ciclon_size', bonus: 30, icon: '🌀', description: 'Ciclon', detail: '+30% Tamano de Ciclon' }],
                        6: [{ type: 'radioactive_spread', bonus: 20, icon: '☢️', description: 'Viento Radioactivo', detail: '+20% Radio de propagacion' }],
                        7: [{ type: 'cooldown', bonus: 12, icon: '⏱️', description: 'Vientos Rapidos', detail: '-12% Cooldown' }],
                        8: [{ type: 'dot_damage', bonus: 35, icon: '🔥', description: 'Veneno Letal', detail: '+35% Dano con el tiempo' }],
                        9: [{ type: 'attraction_power', bonus: 40, icon: '🌀', description: 'Atraccion del Viento Fuerte', detail: '+40% Poder de atraccion' }],
                        10: [{ type: 'ultimate', bonus: 50, icon: '🌪️', description: 'Atraccion del Viento Fuerte', detail: 'Ultimate +50% dano' }]
                    }
                },

                // WILD BERSERKER - Rage and brute force
                'class_berserker': {
                    icon: '⚔️',
                    name: 'Wild Berserker',
                    upgrades: {
                        2: [{ type: 'rage_damage', bonus: 15, icon: '🔥', description: 'Ira Imparable', detail: '+15% Dano durante furia' }],
                        3: [{ type: 'lifesteal', bonus: 5, icon: '❤️', description: 'Frenesi de Batalla', detail: '+5% Robo de vida' }],
                        4: [{ type: 'leap_damage', bonus: 25, icon: '🌪️', description: 'Hacha Giratoria', detail: '+25% Dano de giro' }],
                        5: [{ type: 'axes_count', bonus: 1, icon: '🪓', description: 'Doble Hacha', detail: 'Lanza 1 hacha adicional' }],
                        6: [{ type: 'rage_duration', bonus: 30, icon: '⏱️', description: 'Furia Prolongada', detail: '+30% Duracion de buffs' }],
                        7: [{ type: 'crit', bonus: 18, icon: '💥', description: 'Golpe Brutal', detail: '+18% Critico' }],
                        8: [{ type: 'bloodlust_heal', bonus: 40, icon: '⚡', description: 'Corte Sorpresa', detail: '+40% Buff de dano' }],
                        9: [{ type: 'damage', bonus: 35, icon: '⚔️', description: 'Fuerza Titanica', detail: '+35% Dano total' }],
                        10: [{ type: 'ultimate', bonus: 50, icon: '💀', description: 'Frenesí de Batalla', detail: 'Ultimate +50% daño' }]
                    }
                },

                // GUARDIAN ANCESTRAL - Tank and earth abilities
                'ancient-guardian': {
                    icon: '🗿',
                    name: 'Guardián Ancestral',
                    upgrades: {
                        2: [{ type: 'quake_waves', bonus: 1, icon: '🌋', description: 'Fisura Sísmica Ancestral', detail: '+1 Onda sísmica' }],
                        3: [{ type: 'pillar_duration', bonus: 30, icon: '🏛️', description: 'Bastión de los Antiguos', detail: '+30% Duración pilares' }],
                        4: [{ type: 'armor_reduction', bonus: 10, icon: '🛡️', description: 'Piel de Titán Pétreo', detail: '+10% Reducción daño' }],
                        5: [{ type: 'spike_count', bonus: 3, icon: '⛰️', description: 'Lanzas del Subsuelo', detail: '+3 Pinchos' }],
                        6: [{ type: 'colossus_size', bonus: 25, icon: '🗿', description: 'Despertar del Titán Olvidado', detail: '+25% Tamaño' }],
                        7: [{ type: 'cooldown', bonus: 15, icon: '⚡', description: 'Tierra Rápida', detail: '-15% Cooldown' }],
                        8: [{ type: 'stun_duration', bonus: 40, icon: '💫', description: 'Aturdimiento Pétreo', detail: '+40% Duración stun' }],
                        9: [{ type: 'range', bonus: 30, icon: '📏', description: 'Alcance Telúrico', detail: '+30% Rango' }],
                        10: [{ type: 'ultimate', bonus: 75, icon: '💥', description: 'Juicio de las Ruinas Eternas', detail: 'Ultimate +75% daño' }]
                    }
                },

                // ELEMENTALIST - Master of elements
                'class_elementalist': {
                    icon: '🔥',
                    name: 'Elementalist',
                    upgrades: {
                        2: [{ type: 'chain_damage', bonus: 10, icon: '⚡', description: 'Cadena de Relámpagos', detail: '+10% Daño eléctrico' }],
                        3: [{ type: 'chain_targets', bonus: 1, icon: '⚡', description: 'Cadena de Relámpagos', detail: '+1 Objetivo en cadena' }],
                        4: [{ type: 'ice_duration', bonus: 25, icon: '🧊', description: 'Prisión de Hielo', detail: '+25% Duración congelamiento' }],
                        5: [{ type: 'freeze_radius', bonus: 20, icon: '❄️', description: 'Prisión de Hielo', detail: '+20% Radio de hielo' }],
                        6: [{ type: 'cooldown', bonus: 12, icon: '⏱️', description: 'Maestría Elemental', detail: '-12% Cooldown' }],
                        7: [{ type: 'crit', bonus: 15, icon: '🎯', description: 'Golpe Elemental', detail: '+15% Crítico' }],
                        8: [{ type: 'damage', bonus: 25, icon: '🔥', description: 'Poder Elemental', detail: '+25% Daño' }],
                        9: [{ type: 'storm_duration', bonus: 35, icon: '🌪️', description: 'Tormenta Prolongada', detail: '+35% Duración efectos' }],
                        10: [{ type: 'ultimate', bonus: 60, icon: '🌪️', description: 'Furia Elemental', detail: 'Ultimate +60% daño' }]
                    }
                },

                // RONIN SAMURAI - Honorable warrior
                'class_samurai': {
                    icon: '⚔️',
                    name: 'Ronin Samurai',
                    upgrades: {
                        2: [{ type: 'dash_damage', bonus: 15, icon: '🗡️', description: 'Corte Veloz', detail: '+15% Daño de dash' }],
                        3: [{ type: 'counter_multiplier', bonus: 20, icon: '🛡️', description: 'Contraataque', detail: '+20% Daño reflejado' }],
                        4: [{ type: 'invisibility_duration', bonus: 30, icon: '👤', description: 'Poder Ninja', detail: '+30% Duración invisibilidad' }],
                        5: [{ type: 'surprise_hits', bonus: 1, icon: '⚡', description: 'Golpe Rápido', detail: '+1 Corte adicional' }],
                        6: [{ type: 'cooldown', bonus: 15, icon: '⏱️', description: 'Samurai Veloz', detail: '-15% Cooldown' }],
                        7: [{ type: 'crit', bonus: 20, icon: '🎯', description: 'Corte Crítico', detail: '+20% Crítico' }],
                        8: [{ type: 'speed', bonus: 18, icon: '💨', description: 'Paso del Viento', detail: '+18% Velocidad' }],
                        9: [{ type: 'confusion_duration', bonus: 40, icon: '🌫️', description: 'Humo Persistente', detail: '+40% Duración confusión' }],
                        10: [{ type: 'ultimate', bonus: 80, icon: '⚔️', description: 'Danza de las Mil Hojas', detail: 'Ultimate +80% daño' }]
                    }
                },

                // ROMAN LEGIONARY - Roman warrior
                'class_roman_legionary': {
                    icon: '🦅',
                    name: 'Roman Legionary',
                    upgrades: {
                        2: [{ type: 'gladius_damage', bonus: 12, icon: '⚔️', description: 'Gladius Fulminante', detail: '+12% Daño de espada' }],
                        3: [{ type: 'testudo_defense', bonus: 20, icon: '🛡️', description: 'Formación Testudo', detail: '+20% Defensa' }],
                        4: [{ type: 'pilum_pierce', bonus: 15, icon: '🏹', description: 'Lanzamiento Pilum', detail: '+15% Penetración' }],
                        5: [{ type: 'centurion_buff', bonus: 25, icon: '📢', description: 'Grito del Centurión', detail: '+25% Buff de equipo' }],
                        6: [{ type: 'cooldown', bonus: 12, icon: '⏱️', description: 'Disciplina Romana', detail: '-12% Cooldown' }],
                        7: [{ type: 'armor_reduction', bonus: 15, icon: '🗡️', description: 'Rompe Armaduras', detail: '+15% Reducción armadura enemiga' }],
                        8: [{ type: 'bleed_damage', bonus: 30, icon: '🩸', description: 'Sangrado Profundo', detail: '+30% Daño sangrado' }],
                        9: [{ type: 'eagle_power', bonus: 35, icon: '🦅', description: 'Águila Imperial', detail: '+35% Poder de Águila' }],
                        10: [{ type: 'ultimate', bonus: 70, icon: '🏛️', description: 'Legio Aeterna', detail: 'Ultimate +70% daño' }]
                    }
                },

                // SPARTAN HOPLITE - Spartan warrior
                'class_spartan_hoplite': {
                    icon: '🛡️',
                    name: 'Spartan Hoplite',
                    upgrades: {
                        2: [{ type: 'dory_damage', bonus: 15, icon: '🗡️', description: 'Doru Penetrante', detail: '+15% Daño de lanza' }],
                        3: [{ type: 'phalanx_defense', bonus: 25, icon: '🛡️', description: 'Falange Espartana', detail: '+25% Defensa' }],
                        4: [{ type: 'charge_damage', bonus: 30, icon: '⚡', description: 'Carga Espartana', detail: '+30% Daño de carga' }],
                        5: [{ type: 'aroo_buff', bonus: 20, icon: '📯', description: 'Grito de Guerra: AROO!', detail: '+20% Buff de combate' }],
                        6: [{ type: 'cooldown', bonus: 15, icon: '⏱️', description: 'Guerrero Veloz', detail: '-15% Cooldown' }],
                        7: [{ type: 'ares_blessing', bonus: 35, icon: '⚔️', description: 'Bendición de Ares', detail: '+35% Daño bendecido' }],
                        8: [{ type: 'shield_bash', bonus: 25, icon: '🛡️', description: 'Golpe de Escudo', detail: '+25% Daño de escudo' }],
                        9: [{ type: 'formation_bonus', bonus: 40, icon: '🛡️', description: 'Formación Perfecta', detail: '+40% Bonus formación' }],
                        10: [{ type: 'ultimate', bonus: 100, icon: '⚔️', description: 'Las Termópilas', detail: 'Invulnerabilidad mejorada' }]
                    }
                },

                // CYBER GUNSLINGER - Tech warrior
                'class_gunslinger': {
                    icon: '🔫',
                    name: 'Cyber Gunslinger',
                    upgrades: {
                        2: [{ type: 'bullet_damage', bonus: 10, icon: '💥', description: 'Rapid Fire', detail: '+10% Daño de balas' }],
                        3: [{ type: 'fire_rate', bonus: 15, icon: '💥', description: 'Rapid Fire', detail: '+15% Velocidad de disparo' }],
                        4: [{ type: 'reload_speed', bonus: 20, icon: '🛡️', description: 'Energy Shield', detail: '+20% Velocidad recarga' }],
                        5: [{ type: 'crit', bonus: 18, icon: '🎯', description: 'Tiro Certero', detail: '+18% Crítico' }],
                        6: [{ type: 'cooldown', bonus: 12, icon: '⏱️', description: 'Pistolero Veloz', detail: '-12% Cooldown' }],
                        7: [{ type: 'penetration', bonus: 25, icon: '💣', description: 'Plasma Grenade', detail: '+25% Penetración' }],
                        8: [{ type: 'multishot', bonus: 2, icon: '⚡', description: 'Tactical Dash', detail: '+2 Balas por disparo' }],
                        9: [{ type: 'range', bonus: 30, icon: '🎯', description: 'Alcance Extendido', detail: '+30% Rango' }],
                        10: [{ type: 'ultimate', bonus: 100, icon: '🛰️', description: 'Orbital Strike', detail: 'Ultimate +100% daño' }]
                    }
                },

                // ===== MASTER CLASSES =====

                // TORNADO OVERLORD - Master of Wind Master
                'master_storm_of_tornados': {
                    icon: '🌪️',
                    name: 'Tornado Overlord',
                    upgrades: {
                        2: [{ type: 'singularity_power', bonus: 15, icon: '⚫', description: 'Singularidad Eólica', detail: '+15% Poder de atracción' }],
                        3: [{ type: 'pressure_duration', bonus: 25, icon: '🛡️', description: 'Presión Atmosférica', detail: '+25% Duración inmovilización' }],
                        4: [{ type: 'tornado_count', bonus: 2, icon: '🌀', description: 'Ráfaga de Tornados', detail: '+2 Tornados adicionales' }],
                        5: [{ type: 'shield_duration', bonus: 30, icon: '🛡️', description: 'Escudo de Tormenta', detail: '+30% Duración escudo' }],
                        6: [{ type: 'cooldown', bonus: 15, icon: '⏱️', description: 'Señor de las Tormentas', detail: '-15% Cooldown' }],
                        7: [{ type: 'enemy_tornado_damage', bonus: 40, icon: '🌪️', description: 'Tornado de Enemigo', detail: '+40% Daño' }],
                        8: [{ type: 'confusion_duration', bonus: 35, icon: '💫', description: 'Confusión Prolongada', detail: '+35% Duración confusión' }],
                        9: [{ type: 'storm_radius', bonus: 45, icon: '🌪️', description: 'Tormenta Expandida', detail: '+45% Radio de tormenta' }],
                        10: [{ type: 'ultimate', bonus: 100, icon: '☄️', description: 'Tormenta Apocalíptica', detail: 'Ultimate +100% daño' }]
                    }
                },

                // CYBERNETIC WARLORD - Master of Cyber Gunslinger
                'master_cybernetic_warlord': {
                    icon: '🤖',
                    name: 'Cybernetic Warlord',
                    upgrades: {
                        2: [{ type: 'plasma_damage', bonus: 20, icon: '🔫', description: 'Cañón de Plasma', detail: '+20% Daño de plasma' }],
                        3: [{ type: 'singularity_radius', bonus: 25, icon: '💣', description: 'Granada de Singularidad', detail: '+25% Radio de singularidad' }],
                        4: [{ type: 'drone_count', bonus: 2, icon: '🛸', description: 'Enjambre de Drones', detail: '+2 Drones adicionales' }],
                        5: [{ type: 'barrier_strength', bonus: 30, icon: '🛡️', description: 'Barrera de Fotones', detail: '+30% Resistencia barrera' }],
                        6: [{ type: 'cooldown', bonus: 15, icon: '⏱️', description: 'Sistemas Optimizados', detail: '-15% Cooldown' }],
                        7: [{ type: 'mech_duration', bonus: 40, icon: '🦾', description: 'Protocolo: MECH-SUIT', detail: '+40% Duración mech' }],
                        8: [{ type: 'heat_efficiency', bonus: 35, icon: '🔥', description: 'Gestión Térmica', detail: '+35% Eficiencia calor' }],
                        9: [{ type: 'tech_damage', bonus: 50, icon: '⚡', description: 'Sobrecarga Tecnológica', detail: '+50% Daño tecnológico' }],
                        10: [{ type: 'ultimate', bonus: 150, icon: '🛰️', description: 'Satélite Orbital "Ragnarok"', detail: 'Ultimate +150% daño' }]
                    }
                },

                // ABYSSAL SHADOWLORD - Master of Shadow Ninja
                'master_abyssal_shadowlord': {
                    icon: '👹',
                    name: 'Abyssal Shadowlord',
                    upgrades: {
                        2: [{ type: 'blade_storm_damage', bonus: 25, icon: '🗡️', description: 'Tormenta de Cuchillas Sombrías', detail: '+25% Daño de hojas' }],
                        3: [{ type: 'death_chain_targets', bonus: 2, icon: '⛓️', description: 'Cadena de Muerte', detail: '+2 Objetivos en cadena' }],
                        4: [{ type: 'void_leap_distance', bonus: 30, icon: '👤', description: 'Salto al Vacío Fantasma', detail: '+30% Distancia de salto' }],
                        5: [{ type: 'shadow_legion_count', bonus: 2, icon: '👥', description: 'Legión de Sombras', detail: '+2 Clones adicionales' }],
                        6: [{ type: 'cooldown', bonus: 18, icon: '⏱️', description: 'Señor de las Sombras', detail: '-18% Cooldown' }],
                        7: [{ type: 'emperor_power', bonus: 45, icon: '👑', description: 'Emperador Sombra', detail: '+45% Poder imperial' }],
                        8: [{ type: 'darkness_duration', bonus: 40, icon: '🌑', description: 'Noche Eterna', detail: '+40% Duración oscuridad' }],
                        9: [{ type: 'abyss_damage', bonus: 60, icon: '👹', description: 'Poder Abisal', detail: '+60% Daño abisal' }],
                        10: [{ type: 'ultimate', bonus: 200, icon: '🌑', description: 'Noche Eterna', detail: 'Ultimate +200% daño' }]
                    }
                }
            },

            init() {
                this.loadProgress();
            },

            getClassLevel(classId) {
                if (!this.classLevels[classId]) {
                    this.classLevels[classId] = {
                        level: 1,
                        exp: 0,
                        expToNext: 100
                    };
                }
                return this.classLevels[classId];
            },

            addClassExp(classId, exp) {
                const classData = this.getClassLevel(classId);

                if (classData.level >= this.maxClassLevel) {
                    console.log(`? ${classId} ya está en nivel máximo (${this.maxClassLevel})`);
                    return false;
                }

                classData.exp += exp;

                // Check for level up
                while (classData.exp >= classData.expToNext && classData.level < this.maxClassLevel) {
                    classData.exp -= classData.expToNext;
                    classData.level++;
                    classData.expToNext = Math.floor(classData.expToNext * 1.5); // Increase exp requirement

                    this.onLevelUp(classId, classData.level);
                }

                this.saveProgress();
                return true;
            },

            onLevelUp(classId, newLevel) {
                console.log(`?? í${classId} subií a nivel ${newLevel}!`);

                // Show level up notification
                this.showLevelUpNotification(classId, newLevel);

                // Apply new upgrades
                this.applyClassUpgrades(classId);
            },

            showLevelUpNotification(classId, level) {
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #ffbe0b, #ff006e);
                    color: white;
                    padding: 30px 50px;
                    border-radius: 20px;
                    font-size: 24px;
                    font-weight: 900;
                    z-index: 10000;
                    box-shadow: 0 0 50px rgba(255, 190, 11, 0.8);
                    animation: levelUpPulse 0.5s ease-out;
                    text-align: center;
                    font-family: 'Orbitron', sans-serif;
                `;

                const upgrades = this.getClassUpgrades(classId, level);
                const upgradeText = upgrades.map(u => u.description).join('<br>');

                notification.innerHTML = `
                    <div style="font-size: 32px; margin-bottom: 10px;">? NIVEL ${level} ?</div>
                    <div style="font-size: 18px; margin-bottom: 15px;">${classId.toUpperCase()}</div>
                    <div style="font-size: 14px; color: #fff; opacity: 0.9;">${upgradeText}</div>
                `;

                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.animation = 'fadeOut 0.5s ease-out';
                    setTimeout(() => notification.remove(), 500);
                }, 3000);
            },

            getClassUpgrades(classId, level) {
                const classTree = this.classUpgrades[classId];
                if (!classTree) return [];
                return classTree.upgrades[level] || [];
            },

            getAllUpgradesForClass(classId) {
                const classData = this.getClassLevel(classId);
                const classTree = this.classUpgrades[classId];
                if (!classTree) return [];

                const allUpgrades = [];

                // Get all upgrades up to current level
                for (let lvl = 1; lvl <= classData.level; lvl++) {
                    const levelUpgrades = classTree.upgrades[lvl] || [];
                    allUpgrades.push(...levelUpgrades);
                }

                return allUpgrades;
            },

            getClassInfo(classId) {
                return this.classUpgrades[classId] || { icon: '?', name: 'Unknown', upgrades: {} };
            },

            applyClassUpgrades(classId) {
                // Upgrades are applied dynamically when calculating damage/duration/cooldown
                // This method is called to trigger any immediate effects
                console.log(`? Mejoras aplicadas para ${classId}`);
            },

            getDamageMultiplier(classId) {
                const allUpgrades = this.getAllUpgradesForClass(classId);
                const damageUpgrades = allUpgrades.filter(u => u.type === 'damage');
                const totalBonus = damageUpgrades.reduce((sum, u) => sum + u.bonus, 0);
                return 1 + (totalBonus / 100);
            },

            getDurationMultiplier(classId) {
                const allUpgrades = this.getAllUpgradesForClass(classId);
                const durationUpgrades = allUpgrades.filter(u => u.type === 'duration');
                const totalBonus = durationUpgrades.reduce((sum, u) => sum + u.bonus, 0);
                return 1 + (totalBonus / 100);
            },

            getCooldownMultiplier(classId) {
                const allUpgrades = this.getAllUpgradesForClass(classId);
                const cooldownUpgrades = allUpgrades.filter(u => u.type === 'cooldown');
                const totalBonus = cooldownUpgrades.reduce((sum, u) => sum + u.bonus, 0);
                return 1 - (totalBonus / 100);
            },

            getSpeedMultiplier(classId) {
                const allUpgrades = this.getAllUpgradesForClass(classId);
                const speedUpgrades = allUpgrades.filter(u => u.type === 'speed');
                const totalBonus = speedUpgrades.reduce((sum, u) => sum + u.bonus, 0);
                return 1 + (totalBonus / 100);
            },

            saveProgress() {
                try {
                    localStorage.setItem('wildDestinyClassLevels', JSON.stringify(this.classLevels));
                } catch (e) {
                    console.error('Failed to save class levels:', e);
                }
            },

            loadProgress() {
                try {
                    const saved = localStorage.getItem('wildDestinyClassLevels');
                    if (saved) {
                        this.classLevels = JSON.parse(saved);
                        console.log('?? Class levels loaded:', this.classLevels);
                    }
                } catch (e) {
                    console.error('Failed to load class levels:', e);
                }
            },

            showUpgradesModal() {
                const modal = document.createElement('div');
                modal.id = 'class-upgrades-modal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.95);
                    z-index: 10000;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    animation: fadeIn 0.3s ease-out;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    background: linear-gradient(135deg, rgba(10, 14, 39, 0.98), rgba(15, 5, 30, 0.98));
                    border: 3px solid #00d9ff;
                    border-radius: 20px;
                    width: 90%;
                    max-width: 1200px;
                    height: 85%;
                    padding: 30px;
                    overflow-y: auto;
                    box-shadow: 0 0 50px rgba(0, 217, 255, 0.5);
                `;

                // Get current equipped class
                const equippedRole = EquipmentManager.equippedRole;
                let html = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                        <h2 style="color: #00d9ff; font-family: 'Orbitron', sans-serif; font-size: 32px; margin: 0;">
                            ? MEJORAS DE CLASE
                        </h2>
                        <button id="close-upgrades-modal" style="background: #ff006e; border: none; color: white; padding: 10px 20px; border-radius: 10px; font-size: 16px; font-weight: 700; cursor: pointer;">
                            ? Cerrar
                        </button>
                    </div>
                `;

                if (equippedRole && (equippedRole.type === 'class' || equippedRole.type === 'master_class')) {
                    const classData = this.getClassLevel(equippedRole.id);
                    const classInfo = this.getClassInfo(equippedRole.id);
                    const allUpgrades = this.getAllUpgradesForClass(equippedRole.id);

                    // Header with class info
                    html += `
                        <div style="background: rgba(0, 217, 255, 0.1); border: 2px solid #00d9ff; border-radius: 15px; padding: 20px; margin-bottom: 30px;">
                            <div style="display: flex; align-items: center; gap: 20px;">
                                <div style="font-size: 64px;">${IconRenderer.icons[classInfo.id] ? IconRenderer.getIconHTML(classInfo.id, 64) : classInfo.icon}</div>
                                <div style="flex: 1;">
                                    <h3 style="color: #fff; font-size: 28px; margin: 0 0 10px 0;">${classInfo.name}</h3>
                                    <div style="color: #ffbe0b; font-size: 18px; font-weight: 700;">Nivel ${classData.level} / ${this.maxClassLevel}</div>
                                    <div style="background: rgba(0, 0, 0, 0.5); border-radius: 10px; height: 25px; margin-top: 10px; overflow: hidden;">
                                        <div style="background: linear-gradient(90deg, #ffbe0b, #ff006e); height: 100%; width: ${(classData.exp / classData.expToNext) * 100}%; transition: width 0.3s;"></div>
                                    </div>
                                    <div style="color: #fff; font-size: 14px; margin-top: 5px;">${classData.exp} / ${classData.expToNext} EXP</div>
                                </div>
                            </div>
                        </div>
                    `;

                    // Upgrades by level
                    html += `<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 20px;">`;

                    for (let level = 2; level <= this.maxClassLevel; level++) {
                        const levelUpgrades = this.getClassUpgrades(equippedRole.id, level);
                        const isUnlocked = classData.level >= level;

                        html += `
                            <div style="background: ${isUnlocked ? 'rgba(0, 217, 255, 0.1)' : 'rgba(100, 100, 100, 0.1)'}; border: 2px solid ${isUnlocked ? '#00d9ff' : '#666'}; border-radius: 15px; padding: 20px; ${!isUnlocked ? 'opacity: 0.5;' : ''}">
                                <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                                    <div style="background: ${isUnlocked ? 'linear-gradient(135deg, #ffbe0b, #ff006e)' : '#666'}; width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: 900; color: white;">
                                        ${level}
                                    </div>
                                    <div>
                                        <div style="color: ${isUnlocked ? '#00d9ff' : '#999'}; font-size: 18px; font-weight: 700;">NIVEL ${level}</div>
                                        <div style="color: ${isUnlocked ? '#0f0' : '#f00'}; font-size: 12px;">${isUnlocked ? '? DESBLOQUEADO' : '?? BLOQUEADO'}</div>
                                    </div>
                                </div>
                                <div style="display: flex; flex-direction: column; gap: 10px;">
                        `;

                        levelUpgrades.forEach(upgrade => {
                            // Generate image path from description (ability name)
                            let imagePath = upgrade.iconImage;
                            if (!imagePath && upgrade.description) {
                                // Try to generate image path from ability name
                                const cleanName = upgrade.description
                                    .toLowerCase()
                                    .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // Remove accents
                                    .replace(/[^a-z0-9]+/g, '');
                                imagePath = `assets/${cleanName}.jpg`;
                            }

                            const iconHtml = `
                                <img src="${imagePath}" style="width: 48px; height: 48px; border-radius: 8px; object-fit: cover; border: 2px solid #ffbe0b; background: rgba(255, 190, 11, 0.1);" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                                <div style="display: none; font-size: 28px; width: 48px; height: 48px; align-items: center; justify-content: center; background: rgba(255, 190, 11, 0.2); border-radius: 8px; border: 2px solid #ffbe0b;">${IconRenderer.getIconFor({ icon: upgrade.icon, effectId: upgrade.effectId }) ? IconRenderer.getIconHTML(IconRenderer.getIconFor({ icon: upgrade.icon, effectId: upgrade.effectId }), 32) : upgrade.icon}</div>
                            `;

                            html += `
                                <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 12px; display: flex; align-items: center; gap: 12px;">
                                    <div style="display: flex; align-items: center; justify-content: center;">
                                        ${iconHtml}
                                    </div>
                                    <div style="flex: 1;">
                                        <div style="color: #ffbe0b; font-size: 14px; font-weight: 700;">${upgrade.description}</div>
                                        <div style="color: #fff; font-size: 12px; opacity: 0.8;">${upgrade.detail}</div>
                                    </div>
                                </div>
                            `;
                        });

                        html += `
                                </div>
                            </div>
                        `;
                    }

                    html += `</div>`;

                } else {
                    html += `
                        <div style="text-align: center; padding: 100px 20px; color: #999;">
                            <div style="font-size: 64px; margin-bottom: 20px;">?</div>
                            <h3 style="color: #fff; font-size: 24px; margin-bottom: 10px;">No hay clase equipada</h3>
                            <p style="font-size: 16px;">Equipa una clase para ver sus mejoras y progresiín</p>
                        </div>
                    `;
                }

                content.innerHTML = html;
                modal.appendChild(content);
                document.body.appendChild(modal);

                // Close button
                document.getElementById('close-upgrades-modal').addEventListener('click', () => {
                    modal.style.animation = 'fadeOut 0.3s ease-out';
                    setTimeout(() => modal.remove(), 300);
                });

                // Close on background click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.style.animation = 'fadeOut 0.3s ease-out';
                        setTimeout(() => modal.remove(), 300);
                    }
                });
            }
        };

        // ===== EQUIPMENT MANAGER =====
        const EquipmentManager = {
            equippedRole: null, // Only ONE role can be equipped
            classTickets: {}, // Object with class-specific tickets { dragonhunter: 2, elementalist: 1, ... }
            unlockedClasses: [], // Array of unlocked class IDs
            tierOrder: ['F', 'E', 'D', 'C', 'B', 'A', 'S', 'S+', 'SS', 'SSS', 'LEGENDARY', 'MASTER', 'MYTHIC'],

            getTierRank(tier) {
                const value = String(tier || '').toUpperCase().trim();
                const idx = this.tierOrder.indexOf(value);
                return idx >= 0 ? idx : this.tierOrder.indexOf('S');
            },

            getLowestTierStarterClass() {
                const classes = (rolesData.classes || []).filter(r => r && r.type === 'class' && r.id);
                if (!classes.length) return null;
                const sorted = [...classes].sort((a, b) => {
                    const rankDiff = this.getTierRank(a.tier) - this.getTierRank(b.tier);
                    if (rankDiff !== 0) return rankDiff;
                    const ticketA = Number(a.ticketsRequired || 0);
                    const ticketB = Number(b.ticketsRequired || 0);
                    if (ticketB !== ticketA) return ticketB - ticketA;
                    return String(a.name || '').localeCompare(String(b.name || ''));
                });
                return sorted[0] || null;
            },

            equipStarterClass() {
                const starterClass = this.getLowestTierStarterClass();
                if (!starterClass) return;
                if (!this.unlockedClasses.includes(starterClass.id)) {
                    this.unlockedClasses.push(starterClass.id);
                }
                this.equipRole(starterClass);
                console.log(`?? Starter class equipped: ${starterClass.name} (${starterClass.tier || 'N/A'})`);
            },

            ensureStarterUnlocked() {
                const starterClass = this.getLowestTierStarterClass();
                if (!starterClass) return;
                if (!this.unlockedClasses.includes(starterClass.id)) {
                    this.unlockedClasses.push(starterClass.id);
                    console.log(`?? Starter class unlocked: ${starterClass.name}`);
                }
            },

            // Load saved data from localStorage
            loadProgress() {
                try {
                    const saved = localStorage.getItem('wildDestinyProgress');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.classTickets = data.classTickets || {};
                        this.unlockedClasses = data.unlockedClasses || [];
                        this.ensureStarterUnlocked();

                        // Update ticket counter (show total)
                        const totalTickets = Object.values(this.classTickets).reduce((a, b) => a + b, 0);
                        document.getElementById('ticket-counter').textContent = totalTickets;

                        // Update stats display
                        this.updateStatsDisplay();

                        // Restore equipped role if saved
                        if (data.equippedRole) {
                            const allRoles = [...rolesData.characters, ...rolesData.classes, ...rolesData.masterClasses];
                            const role = allRoles.find(r => r.id === data.equippedRole.id);
                            if (role) {
                                this.equipRole(role);
                            } else {
                                this.equipStarterClass();
                            }
                        } else {
                            this.equipStarterClass();
                        }

                        console.log('?? Progress loaded:', data);
                    } else {
                        this.ensureStarterUnlocked();
                        this.equipStarterClass();
                    }
                } catch (e) {
                    console.error('Failed to load progress:', e);
                    this.ensureStarterUnlocked();
                    this.equipStarterClass();
                }
            },

            // Save data to localStorage
            saveProgress() {
                try {
                    const data = {
                        classTickets: this.classTickets,
                        unlockedClasses: this.unlockedClasses,
                        equippedRole: this.equippedRole ? { id: this.equippedRole.id, type: this.equippedRole.type } : null
                    };
                    localStorage.setItem('wildDestinyProgress', JSON.stringify(data));
                    console.log('?? Progress saved');

                    // Update stats display
                    this.updateStatsDisplay();
                } catch (e) {
                    console.error('Failed to save progress:', e);
                }
            },

            updateStatsDisplay() {
                // Update total tickets
                const totalTickets = Object.values(this.classTickets).reduce((a, b) => a + b, 0);
                const ticketEl = document.getElementById('total-tickets-display');
                if (ticketEl) ticketEl.textContent = totalTickets;

                // Update unlocked classes count
                const unlockedEl = document.getElementById('unlocked-classes-display');
                if (unlockedEl) unlockedEl.textContent = this.unlockedClasses.length;

                // Update masteries completed count
                const masteriesEl = document.getElementById('masteries-completed-display');
                if (masteriesEl) masteriesEl.textContent = LoadoutManager.unlockedMasterClasses.length;

                // Update Level and EXP bar
                const expPercent = (Player.exp / Player.expToNextLevel) * 100;
                const expCard = document.querySelector('.stat-card:nth-child(3)');
                if (expCard) {
                    const expBar = expCard.querySelector('.stat-bar-fill');
                    const expText = expCard.querySelectorAll('.stat-text span');

                    if (expBar) expBar.style.width = `${expPercent}%`;
                    if (expText[0]) expText[0].textContent = `Nivel ${Player.level}`;
                    if (expText[1]) expText[1].textContent = `${Math.floor(expPercent)}%`;
                }

                // Update HP bar
                const hpPercent = (Player.hp / Player.maxHp) * 100;
                const hpCard = document.querySelector('.stat-card:nth-child(1)');
                if (hpCard) {
                    const hpBar = hpCard.querySelector('.stat-bar-fill');
                    const hpText = hpCard.querySelectorAll('.stat-text span');

                    if (hpBar) hpBar.style.width = `${hpPercent}%`;
                    if (hpText[0]) hpText[0].textContent = `${Math.round(Player.hp)} / ${Player.maxHp}`;
                    if (hpText[1]) hpText[1].textContent = `${Math.floor(hpPercent)}%`;
                }

                // Update hero card in stats panel
                const heroCard = document.getElementById('stats-hero-card');
                const heroName = document.getElementById('stats-hero-name');
                const heroType = document.getElementById('stats-hero-type');
                const heroImage = document.getElementById('stats-hero-image');
                const sectionTitle = document.getElementById('stats-hero-section-title');

                if (this.equippedRole) {
                    const role = this.equippedRole;

                    // Update section title based on type
                    if (sectionTitle) {
                        if (role.type === 'character') {
                            sectionTitle.textContent = '👤 Héroe';
                        } else {
                            sectionTitle.textContent = '🎯 Clase';
                        }
                    }

                    // Update name and type
                    if (heroName) {
                        let displayName = role.name;
                        // Add class level for classes
                        if (role.type === 'class' || role.type === 'master_class') {
                            const classData = ClassProgressionSystem.getClassLevel(role.id);
                            displayName = `${role.name} [Nv.${classData.level}]`;
                        }
                        heroName.textContent = displayName;
                    }
                    if (heroType) {
                        if (role.type === 'character') {
                            heroType.textContent = '👤 Personaje';
                        } else if (role.type === 'master_class') {
                            const classData = ClassProgressionSystem.getClassLevel(role.id);
                            const expPercent = Math.floor((classData.exp / classData.expToNext) * 100);
                            heroType.textContent = `🏆 ${role.tier || 'Clase Maestra'} | EXP: ${expPercent}%`;
                        } else {
                            const classData = ClassProgressionSystem.getClassLevel(role.id);
                            const expPercent = Math.floor((classData.exp / classData.expToNext) * 100);
                            heroType.textContent = `🎯 ${role.tier || 'Clase'} | EXP: ${expPercent}%`;
                        }
                    }

                    // Update image with 2D renderer
                    if (heroImage) {
                        heroImage.innerHTML = `<div class="equip-card-image-fallback" style="display: flex;">${IconRenderer.getIconHTML(role.id, 80)}</div>`;
                    }

                    if (heroCard) heroCard.classList.add('equipped');
                } else {
                    // No equipment
                    if (sectionTitle) sectionTitle.textContent = '👤 Héroe';
                    if (heroName) heroName.textContent = 'Sin Equipamiento';
                    if (heroType) heroType.textContent = 'Selecciona un personaje o clase';
                    if (heroImage) heroImage.innerHTML = '<div class="equip-card-image-fallback">?</div>';
                    if (heroCard) heroCard.classList.remove('equipped');
                }
            },

            equipRole(role) {
                // Unequip previous role
                if (this.equippedRole) {
                    console.log(`? Unequipped ${this.equippedRole.type}: ${this.equippedRole.name}`);
                }

                // Equip new role
                this.equippedRole = role;

                // Update player image if it's a character
                if (role.type === 'character') {
                    const img = AssetLoader.getImage(role.imagePath);
                    if (img) Player.currentImage = img;
                } else {
                    Player.currentImage = null; // Reset to default if not a character
                }

                // Preload ability images
                if (role.abilities) {
                    role.abilities.forEach(ability => {
                        const imageName = normalizeImageName(ability.name);
                        const imagePath = ability.iconImage || `assets/${imageName}.jpg`;
                        AssetLoader.loadImage(imagePath);
                    });
                }
                if (role.semiUltimate) {
                    const imageName = normalizeImageName(role.semiUltimate.name);
                    const imagePath = role.semiUltimate.iconImage || `assets/${imageName}.jpg`;
                    AssetLoader.loadImage(imagePath);
                }
                if (role.ultimateAbility) {
                    const imageName = normalizeImageName(role.ultimateAbility.name);
                    const imagePath = role.ultimateAbility.iconImage || `assets/${imageName}.jpg`;
                    AssetLoader.loadImage(imagePath);
                }

                this.updateEquipmentUI();
                this.updateAbilityBar();
                this.saveProgress(); // Save after equipping
                console.log(`? Equipped ${role.type}: ${role.name}`);
            },

            unlockClass(classId) {
                if (!this.unlockedClasses.includes(classId)) {
                    this.unlockedClasses.push(classId);
                    this.saveProgress();
                    console.log(`?? Class unlocked: ${classId}`);
                }
            },

            isClassUnlocked(classId) {
                return this.unlockedClasses.includes(classId);
            },

            getEquippedRole(type) {
                // Return the equipped role if it matches the type, otherwise null
                if (this.equippedRole && this.equippedRole.type === type) {
                    return this.equippedRole;
                }
                return null;
            },

            getAllAbilities() {
                const abilities = [];
                if (this.equippedRole) {
                    abilities.push(...this.equippedRole.abilities);
                    // Add semi-ultimate if it exists (for SSS tier classes)
                    if (this.equippedRole.semiUltimate) {
                        abilities.push(this.equippedRole.semiUltimate);
                    }
                    abilities.push(this.equippedRole.ultimateAbility);
                }
                return abilities;
            },

            updateEquipmentUI() {
                const types = ['character', 'class', 'fruit'];
                const typeNames = {
                    character: 'Personaje',
                    class: 'Clase',
                    fruit: 'Fruta'
                };

                types.forEach(type => {
                    const role = this.getEquippedRole(type);
                    const card = document.getElementById(`card-${type}`);
                    const nameEl = document.getElementById(`${type === 'character' ? 'char' : type}-name`);
                    const imageContainer = document.getElementById(`${type === 'character' ? 'char' : type}-image`);
                    const status = card.querySelector('.equip-status');

                    if (role) {
                        nameEl.textContent = role.name;
                        status.textContent = '? Equipado';
                        card.classList.add('equipped');

                        // Update image with 2D renderer
                        imageContainer.innerHTML = `<div class="equip-card-image-fallback" style="display: flex;">${IconRenderer.getIconHTML(role.id, 80)}</div>`;
                    } else {
                        nameEl.textContent = `Sin ${typeNames[type]}`;
                        status.textContent = 'Vacío';
                        card.classList.remove('equipped');

                        // Reset to default icon
                        const defaultIcon = type === 'character' ? '👤' : type === 'class' ? '🎯' : '🍎';
                        imageContainer.innerHTML = `<div class="equip-card-image-fallback">${defaultIcon}</div>`;
                    }
                });
            },

            updateAbilityBar() {
                const abilities = this.getAllAbilities();
                const abilitySlots = document.querySelectorAll('.ability-slot');

                abilitySlots.forEach((slot, index) => {
                    const ability = abilities[index];
                    const iconElement = slot.querySelector('.ability-icon');

                    if (ability) {
                        const abilityIconId = ability.id || ability.effectId || IconRenderer.getIconFor(ability) || 'default';

                        if (ability.iconImage) {
                            iconElement.innerHTML = `<img src="${ability.iconImage}" style="width:100%; height:100%; object-fit:cover; display:block;">`;
                        } else {
                            // Create or update icon with 2D renderer
                            iconElement.innerHTML = IconRenderer.getIconHTML(abilityIconId, 48);
                        }

                        iconElement.style.padding = '0';
                        iconElement.style.overflow = 'hidden';
                        iconElement.style.display = 'flex';
                        iconElement.style.alignItems = 'center';
                        iconElement.style.justifyContent = 'center';
                        iconElement.style.background = 'rgba(0,0,0,0.3)';

                        slot.querySelector('.ability-name').textContent = ability.name;
                        slot.querySelector('.ability-key').textContent = ability.keyBinding.toUpperCase();
                        slot.dataset.abilityId = ability.id;
                        slot.dataset.key = ability.keyBinding.toUpperCase();
                    } else {
                        iconElement.innerHTML = '';
                        iconElement.textContent = '?';
                        iconElement.style.padding = '';
                        slot.querySelector('.ability-name').textContent = 'Empty';
                        slot.dataset.abilityId = '';
                    }
                });
            }
        };

        // ===== LOADOUT MANAGER - MASTERY MISSIONS SYSTEM =====
        const LoadoutManager = {
            masteryProgress: {}, // { class_id: { mission: {...}, unlocked: false } }
            unlockedMasterClasses: [], // Array of unlocked master class IDs
            currentTab: 'equipped',
            missionTrackerVisible: false, // Controls if mission tracker is shown in-game

            init() {
                this.loadMasteries();
                this.setupEventListeners();
                this.renderSidebarIcons();
            },

            loadMasteries() {
                try {
                    const saved = localStorage.getItem('wildDestinyMasteries');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.masteryProgress = data.masteryProgress || {};
                        this.unlockedMasterClasses = data.unlockedMasterClasses || [];
                        console.log('? Masteries loaded:', this.masteryProgress);
                    }
                } catch (e) {
                    console.error('Failed to load masteries:', e);
                }
            },

            saveMasteries() {
                try {
                    const data = {
                        masteryProgress: this.masteryProgress,
                        unlockedMasterClasses: this.unlockedMasterClasses
                    };
                    localStorage.setItem('wildDestinyMasteries', JSON.stringify(data));
                    console.log('? Masteries saved');
                } catch (e) {
                    console.error('Failed to save masteries:', e);
                }
            },

            getMissionProgress(classId) {
                if (!this.masteryProgress[classId]) {
                    const masterClass = rolesData.masterClasses.find(mc => mc.baseClassId === classId);
                    if (masterClass && masterClass.masteryMission) {
                        this.masteryProgress[classId] = {
                            requirements: JSON.parse(JSON.stringify(masterClass.masteryMission.requirements)),
                            completed: false
                        };
                    }
                }
                return this.masteryProgress[classId];
            },

            updateMissionProgress(classId, requirementId, amount = 1) {
                const progress = this.getMissionProgress(classId);
                if (!progress || progress.completed) return;

                const req = progress.requirements.find(r => r.id === requirementId);
                if (req) {
                    const maxValue = req.amount || req.waves || 0;
                    req.current = Math.min(req.current + amount, maxValue);

                    console.log(`? Mission Progress [${classId}]: ${req.description} - ${req.current}/${maxValue}`);

                    // Check if all requirements are met
                    const allComplete = progress.requirements.every(r =>
                        r.current >= (r.amount || r.waves)
                    );

                    if (allComplete && !progress.completed) {
                        this.completeMission(classId);
                    }

                    this.saveMasteries();
                }
            },

            trackAbilityUsage(abilityId) {
                // Track ability usage for mastery missions
                if (!EquipmentManager.equippedRole || EquipmentManager.equippedRole.type !== 'class') return;

                const classId = EquipmentManager.equippedRole.id;
                const progress = this.getMissionProgress(classId);
                if (!progress || progress.completed) return;

                // Find requirement that tracks this ability
                const req = progress.requirements.find(r => r.type === 'ability_usage' && r.abilityId === abilityId);
                if (req) {
                    this.updateMissionProgress(classId, req.id, 1);
                }
            },

            completeMission(classId) {
                const progress = this.getMissionProgress(classId);
                if (progress) {
                    progress.completed = true;
                    const masterClass = rolesData.masterClasses.find(mc => mc.baseClassId === classId);
                    if (masterClass && !this.unlockedMasterClasses.includes(masterClass.id)) {
                        this.unlockedMasterClasses.push(masterClass.id);
                        this.showMasterClassUnlocked(masterClass);
                    }
                    this.saveMasteries();

                    // Update stats display
                    EquipmentManager.updateStatsDisplay();
                }
            },

            showMasterClassUnlocked(masterClass) {
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, rgba(255, 0, 255, 0.95), rgba(138, 43, 226, 0.95));
                    border: 3px solid #ff00ff;
                    border-radius: 20px;
                    padding: 50px 70px;
                    z-index: 10000;
                    text-align: center;
                    box-shadow: 0 0 60px rgba(255, 0, 255, 0.9);
                    animation: popupFade 4s ease-out forwards;
                `;
                notification.innerHTML = `
                    <div style="font-size: 80px; margin-bottom: 20px;">??</div>
                    <div style="font-size: 36px; font-weight: 900; color: #fff; margin-bottom: 15px;">¡CLASE MAESTRA DESBLOQUEADA!</div>
                    <div style="font-size: 48px; margin-bottom: 10px;">${IconRenderer.icons[masterClass.id] ? IconRenderer.getIconHTML(masterClass.id, 80) : masterClass.icon}</div>
                    <div style="font-size: 32px; font-weight: 900; color: #fff;">${masterClass.name}</div>
                    <div style="font-size: 16px; color: rgba(255, 255, 255, 0.8); margin-top: 15px;">¡Ahora puedes equipar esta poderosa clase!</div>
                `;
                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 4000);
            },

            openLoadoutModal() {
                document.getElementById('loadout-modal').classList.remove('hidden');
                this.renderSidebarIcons(); // Refresh icons
                this.showTab('equipped');
            },

            renderSidebarIcons() {
                const icons = {
                    equipped: 'class_dragonhunter',
                    characters: 'char_rex',
                    classes: 'class_ninja',
                    fruits: 'fruit_inferno',
                    masteries: 'class_samurai'
                };

                for (const [tab, iconId] of Object.entries(icons)) {
                    const container = document.getElementById(`loadout-nav-icon-${tab}`);
                    if (container) {
                        container.innerHTML = IconRenderer.getIconHTML(iconId, 32);
                    }
                }
            },

            closeLoadoutModal() {
                document.getElementById('loadout-modal').classList.add('hidden');
            },

            setupEventListeners() {
                // Close button
                document.getElementById('close-loadout')?.addEventListener('click', () => {
                    this.closeLoadoutModal();
                });

                // Sidebar navigation items
                document.querySelectorAll('.loadout-nav-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const tab = item.dataset.tab;
                        this.showTab(tab);
                    });
                });
            },

            showTab(tabName) {
                this.currentTab = tabName;

                // Update active nav item
                document.querySelectorAll('.loadout-nav-item').forEach(item => {
                    const indicator = item.querySelector('.tab-indicator');
                    const iconContainer = item.querySelector('.nav-icon-container');
                    const text = item.querySelector('div:nth-child(2)'); // The label div

                    if (item.dataset.tab === tabName) {
                        item.classList.add('active');
                        item.style.opacity = '1';
                        if (indicator) {
                            indicator.style.opacity = '1';
                            indicator.style.bottom = '0';
                        }
                        if (iconContainer) iconContainer.style.filter = 'drop-shadow(0 0 8px rgba(0, 217, 255, 0.8))';
                        if (text) text.style.color = '#00d9ff';
                    } else {
                        item.classList.remove('active');
                        item.style.opacity = '0.6';
                        if (indicator) {
                            indicator.style.opacity = '0';
                            indicator.style.bottom = '-4px';
                        }
                        if (iconContainer) iconContainer.style.filter = 'none';
                        if (text) text.style.color = 'white';
                    }
                });

                // Update content header titles
                const titles = {
                    equipped: { title: 'EQUIPADO', subtitle: 'Gestiona tu equipamiento actual y habilidades' },
                    characters: { title: 'PERSONAJES', subtitle: 'Selecciona tu héroe y personaliza tu estilo de juego' },
                    classes: { title: 'CLASES', subtitle: 'Desbloquea y equipa clases poderosas con tickets' },
                    fruits: { title: 'FRUTAS', subtitle: 'Selecciona poderes elementales para personalizar tu combate' },
                    masteries: { title: 'MAESTRÍAS', subtitle: 'Completa misiones épicas para desbloquear clases maestras' }
                };

                const titleEl = document.getElementById('loadout-content-title');
                const subtitleEl = document.getElementById('loadout-content-subtitle');
                if (titleEl && titles[tabName]) {
                    titleEl.textContent = titles[tabName].title;
                    subtitleEl.textContent = titles[tabName].subtitle;
                }

                // Load content
                const content = document.getElementById('loadout-content');
                switch (tabName) {
                    case 'equipped':
                        content.innerHTML = this.renderEquippedTab();
                        break;
                    case 'characters':
                        content.innerHTML = this.renderCharactersTab();
                        this.attachCharacterListeners();
                        this.attachSelectorControls('characters');
                        break;
                    case 'classes':
                        content.innerHTML = this.renderClassesTab();
                        this.attachClassListeners();
                        this.attachSelectorControls('classes');
                        break;
                    case 'fruits':
                        content.innerHTML = this.renderFruitsTab();
                        this.attachFruitListeners();
                        this.attachSelectorControls('fruits');
                        break;
                    case 'masteries':
                        content.innerHTML = this.renderMasteriesTab();
                        break;
                }
            },

            renderEquippedTab() {
                const equipped = EquipmentManager.equippedRole;

                if (!equipped) {
                    return `
                            <div style="text-align: center; padding: 120px 50px; background: rgba(0, 0, 0, 0.2); border-radius: 20px; border: 1px dashed rgba(0, 217, 255, 0.2);">
                                <div style="width: 120px; height: 120px; margin: 0 auto 30px; opacity: 0.2; filter: grayscale(1);">
                                    ${IconRenderer.getIconHTML('class_dragonhunter', 120)}
                                </div>
                                <h2 style="font-family: 'Orbitron', sans-serif; font-size: 32px; color: #00d9ff; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 2px;">Sistema no Inicializado</h2>
                                <p style="font-size: 18px; color: rgba(224, 231, 255, 0.5); margin-bottom: 40px; font-weight: 300;">Selecciona una entidad de combate para sincronizar con el Vórtice.</p>
                                <button onclick="LoadoutManager.showTab('characters')" style="padding: 18px 45px; font-size: 16px; background: linear-gradient(135deg, #00d9ff, #7c3aed); border: none; border-radius: 30px; color: white; cursor: pointer; font-weight: 800; text-transform: uppercase; letter-spacing: 2px; box-shadow: 0 10px 30px rgba(0, 217, 255, 0.3); transition: all 0.3s;">
                                    Inicializar Personajes
                                </button>
                            </div>
                        `;
                }

                // Generate image path/identity
                const iconId = equipped.id;
                const tierColor = equipped.tierColor || '#00d9ff';

                // Check if this class has a mastery mission
                const hasMasteryMission = rolesData.masterClasses.some(mc => mc.baseClassId === equipped.id);
                const missionProgress = hasMasteryMission ? this.getMissionProgress(equipped.id) : null;

                let abilitiesHTML = '';
                if (equipped.abilities) {
                    equipped.abilities.forEach(ability => {
                        const abilityIconHtml = IconRenderer.getIconHTML(ability.id || ability.effectId || IconRenderer.getIconFor(ability) || 'default', 80);

                        abilitiesHTML += `
                            <div style="background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(10px); border: 2px solid rgba(0, 217, 255, 0.2); border-radius: 20px; overflow: hidden; transition: all 0.3s; cursor: pointer; position: relative; group" onmouseover="this.style.transform='translateY(-5px)'; this.style.borderColor='#00d9ff'; this.style.boxShadow='0 10px 30px rgba(0, 217, 255, 0.2)';" onmouseout="this.style.transform=''; this.style.borderColor='rgba(0, 217, 255, 0.2)'; this.style.boxShadow='';">
                                <!-- Ability Visual Header -->
                                <div style="width: 100%; height: 160px; display: flex; align-items: center; justify-content: center; background: radial-gradient(circle at center, rgba(0, 217, 255, 0.15), transparent); position: relative;">
                                    <div style="filter: drop-shadow(0 0 20px rgba(0, 217, 255, 0.4)); transform: scale(1.2);">
                                        ${abilityIconHtml}
                                    </div>
                                    <div style="position: absolute; top: 15px; right: 15px; background: rgba(0, 217, 255, 0.2); backdrop-filter: blur(5px); padding: 6px 14px; border-radius: 12px; border: 1px solid rgba(0, 217, 255, 0.4); font-family: 'Orbitron', sans-serif; font-size: 14px; font-weight: 800; color: #00d9ff;">
                                        ${ability.keyBinding.toUpperCase()}
                                    </div>
                                </div>
                                <div style="padding: 20px;">
                                    <div style="font-family: 'Orbitron', sans-serif; color: #fff; font-size: 18px; font-weight: 800; margin-bottom: 5px; letter-spacing: 1px;">${ability.name}</div>
                                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                                        <div style="width: 6px; height: 6px; border-radius: 50%; background: #00d9ff; box-shadow: 0 0 5px #00d9ff;"></div>
                                        <div style="color: rgba(224, 231, 255, 0.5); font-size: 12px; font-weight: 700; text-transform: uppercase;">Cooldown: ${ability.cooldown / 1000}s</div>
                                    </div>
                                    <div style="color: rgba(224, 231, 255, 0.8); font-size: 13px; line-height: 1.5; background: rgba(0,0,0,0.3); padding: 12px; border-radius: 10px; border-left: 3px solid #00d9ff;">
                                        ${ability.description || 'No description available for this protocol.'}
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                }

                // Final Ultimate rendering
                if (equipped.ultimateAbility) {
                    const ultimateIconHtml = IconRenderer.getIconHTML(equipped.ultimateAbility.id, 100);
                    abilitiesHTML += `
                         <div style="background: linear-gradient(135deg, rgba(255, 190, 11, 0.15), rgba(255, 0, 110, 0.15)); backdrop-filter: blur(15px); border: 3px solid #ffbe0b; border-radius: 25px; overflow: hidden; box-shadow: 0 15px 40px rgba(255, 190, 11, 0.2); transition: all 0.4s; cursor: pointer; grid-column: 1 / -1;" onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 20px 60px rgba(255, 190, 11, 0.3)';" onmouseout="this.style.transform=''; this.style.boxShadow='0 15px 40px rgba(255, 190, 11, 0.2)';">
                            <div style="display: flex; align-items: stretch; min-height: 220px;">
                                <div style="flex: 1; padding: 40px;">
                                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                                        <div style="background: #ffbe0b; color: #000; padding: 5px 15px; border-radius: 8px; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 900; letter-spacing: 2px;">ULTIMATE PROTOCOL</div>
                                        <div style="background: rgba(255, 255, 255, 0.1); padding: 5px 15px; border-radius: 8px; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 900; color: #fff;">CD: ${equipped.ultimateAbility.cooldown / 1000}s</div>
                                    </div>
                                    <div style="font-family: 'Orbitron', sans-serif; font-size: 32px; font-weight: 900; color: #fff; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255, 190, 11, 0.5);">${equipped.ultimateAbility.name}</div>
                                    <div style="font-size: 16px; color: rgba(255, 255, 255, 0.9); line-height: 1.6; max-width: 600px;">${equipped.ultimateAbility.description}</div>
                                </div>
                                <div style="width: 300px; background: radial-gradient(circle at center, rgba(255, 190, 11, 0.3), transparent); display: flex; align-items: center; justify-content: center; position: relative;">
                                    <div style="filter: drop-shadow(0 0 30px #ffbe0b); transform: scale(1.5);">
                                        ${ultimateIconHtml}
                                    </div>
                                    <div style="position: absolute; bottom: 30px; right: 30px; background: #fff; color: #000; width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-family: 'Orbitron', sans-serif; font-size: 24px; font-weight: 900; box-shadow: 0 0 20px #fff;">
                                        ${equipped.ultimateAbility.keyBinding.toUpperCase()}
                                    </div>
                                </div>
                            </div>
                        </div>
                        `;
                }

                return `
                    <div style="max-width: 1400px; margin: 0 auto; animation: slideUp 0.6s cubic-bezier(0.19, 1, 0.22, 1) forwards;">
                        <!-- Hero Overview Section -->
                        <div style="display: flex; gap: 40px; margin-bottom: 50px; background: rgba(0, 0, 0, 0.3); border-radius: 30px; padding: 40px; border: 1px solid rgba(0, 217, 255, 0.15); backdrop-filter: blur(20px);">
                            <!-- Hero Visual -->
                            <div style="width: 380px; height: 380px; background: radial-gradient(circle at center, rgba(0, 217, 255, 0.2), transparent); border-radius: 20px; display: flex; align-items: center; justify-content: center; position: relative; border: 2px solid ${tierColor}40; overflow: hidden;">
                                <div style="filter: drop-shadow(0 0 40px ${tierColor}); transform: scale(1.8);">
                                    ${IconRenderer.getIconHTML(iconId, 200)}
                                </div>
                                <!-- Tier Badge -->
                                <div style="position: absolute; top: 20px; left: 20px; background: ${tierColor}; color: #000; padding: 8px 20px; border-radius: 12px; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 900; box-shadow: 0 0 20px ${tierColor};">
                                    TIER ${equipped.tier || '?'}
                                </div>
                            </div>

                            <!-- Hero Info Content -->
                                    ${equipped.description || 'Sin descripción disponible'}
                                </div>
                                
                                ${equipped.stats ? `
                                    <div style="background: rgba(0, 0, 0, 0.4); border-radius: 20px; padding: 30px; border: 2px solid rgba(0, 217, 255, 0.3);">
                                        <div style="color: var(--primary); font-size: 14px; font-weight: 900; margin-bottom: 25px; letter-spacing: 3px; text-transform: uppercase;">⚡ ATRIBUTOS DEL HÉROE</div>
                                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 20px;">
                                            <div style="text-align: center; background: rgba(255, 107, 107, 0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(255, 107, 107, 0.3);">
                                                <div style="color: #ff6b6b; font-size: 38px; font-weight: 900; font-family: 'Orbitron', sans-serif; margin-bottom: 10px;">${equipped.stats.strength}</div>
                                                <div style="color: rgba(224, 231, 255, 0.9); font-size: 11px; text-transform: uppercase; font-weight: 700; letter-spacing: 1px;">?? Fuerza</div>
                                            </div>
                                            <div style="text-align: center; background: rgba(78, 205, 196, 0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(78, 205, 196, 0.3);">
                                                <div style="color: #4ecdc4; font-size: 38px; font-weight: 900; font-family: 'Orbitron', sans-serif; margin-bottom: 10px;">${equipped.stats.agility}</div>
                                                <div style="color: rgba(224, 231, 255, 0.9); font-size: 11px; text-transform: uppercase; font-weight: 700; letter-spacing: 1px;">? Agilidad</div>
                                            </div>
                                            <div style="text-align: center; background: rgba(162, 155, 254, 0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(162, 155, 254, 0.3);">
                                                <div style="color: #a29bfe; font-size: 38px; font-weight: 900; font-family: 'Orbitron', sans-serif; margin-bottom: 10px;">${equipped.stats.intelligence}</div>
                                                <div style="color: rgba(224, 231, 255, 0.9); font-size: 11px; text-transform: uppercase; font-weight: 700; letter-spacing: 1px;">?? Inteligencia</div>
                                            </div>
                                            <div style="text-align: center; background: rgba(85, 239, 196, 0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(85, 239, 196, 0.3);">
                                                <div style="color: #55efc4; font-size: 38px; font-weight: 900; font-family: 'Orbitron', sans-serif; margin-bottom: 10px;">${equipped.stats.vitality}</div>
                                                <div style="color: rgba(224, 231, 255, 0.9); font-size: 11px; text-transform: uppercase; font-weight: 700; letter-spacing: 1px;">?? Vitalidad</div>
                                            </div>
                                            <div style="text-align: center; background: rgba(255, 215, 0, 0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(255, 215, 0, 0.3);">
                                                <div style="color: #ffd700; font-size: 38px; font-weight: 900; font-family: 'Orbitron', sans-serif; margin-bottom: 10px;">${equipped.stats.luck}</div>
                                                <div style="color: rgba(224, 231, 255, 0.9); font-size: 11px; text-transform: uppercase; font-weight: 700; letter-spacing: 1px;">?? Suerte</div>
                                            </div>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>

                        <!-- Abilities Section -->
                        <div style="margin-bottom: 30px;">
                            <h3 style="color: #00d9ff; font-size: 32px; margin-bottom: 30px; font-weight: 900; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 20px rgba(0, 217, 255, 0.5); display: flex; align-items: center; gap: 15px;">
                                <span style="font-size: 40px;">??</span> HABILIDADES
                            </h3>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(380px, 1fr)); gap: 20px;">
                                ${abilitiesHTML}
                            </div>
                        </div>

                        <!-- Mastery Mission (if exists) -->
                        ${missionProgress ? `
                            <div style="background: linear-gradient(135deg, rgba(255, 0, 255, 0.15), rgba(138, 43, 226, 0.15)); border: 3px solid #ff00ff; border-radius: 20px; padding: 35px; box-shadow: 0 10px 40px rgba(255, 0, 255, 0.3);">
                                <h3 style="color: #ff00ff; font-size: 28px; margin-bottom: 20px; text-align: center; font-weight: 900; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 20px rgba(255, 0, 255, 0.8);">? MISIÓN DE MAESTRÍA</h3>
                                <div style="text-align: center; margin-bottom: 25px;">
                                    <div style="display: inline-block; background: ${missionProgress.completed ? 'rgba(0, 255, 0, 0.2)' : 'rgba(255, 215, 0, 0.2)'}; border: 2px solid ${missionProgress.completed ? '#00ff00' : '#ffd700'}; padding: 12px 30px; border-radius: 25px; font-size: 16px; color: ${missionProgress.completed ? '#00ff00' : '#ffd700'}; font-weight: 900;">
                                        ${missionProgress.completed ? '? COMPLETADA' : '?? EN PROGRESO'}
                                    </div>
                                </div>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-bottom: 20px;">
                                    ${missionProgress.requirements.map(req => `
                                        <div style="background: rgba(0, 0, 0, 0.4); padding: 20px; border-radius: 12px; border: 2px solid rgba(255, 0, 255, 0.3);">
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                                <span style="color: rgba(224, 231, 255, 0.95); font-size: 14px; font-weight: 600;">${req.description}</span>
                                                <span style="color: ${req.current >= (req.amount || req.waves) ? '#00ff00' : '#ffd700'}; font-weight: 900; font-size: 18px; font-family: 'Orbitron', sans-serif;">
                                                    ${req.current >= (req.amount || req.waves) ? '?' : `${req.current}/${req.amount || req.waves}`}
                                                </span>
                                            </div>
                                            <div style="background: rgba(0, 0, 0, 0.5); height: 10px; border-radius: 5px; overflow: hidden; border: 1px solid rgba(255, 0, 255, 0.3);">
                                                <div style="height: 100%; background: linear-gradient(90deg, #ff00ff, #8a2be2); width: ${(req.current / (req.amount || req.waves)) * 100}%; transition: width 0.3s; box-shadow: 0 0 10px rgba(255, 0, 255, 0.8);"></div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                                ${missionProgress.completed ? `
                                    <button onclick="LoadoutManager.showTab('masteries')" style="width: 100%; padding: 18px; background: linear-gradient(135deg, #ff00ff, #8a2be2); border: none; border-radius: 12px; color: white; font-weight: 900; cursor: pointer; font-size: 16px; text-transform: uppercase; letter-spacing: 2px; box-shadow: 0 8px 25px rgba(255, 0, 255, 0.5); transition: all 0.3s;" onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 12px 35px rgba(255, 0, 255, 0.7)';" onmouseout="this.style.transform=''; this.style.boxShadow='0 8px 25px rgba(255, 0, 255, 0.5)';">
                                        ?? Ver Clase Maestra Desbloqueada
                                    </button>
                                ` : ''}
                            </div>
                        ` : ''}
                    </div>
                `;
            },
            renderCharactersTab() {
                const classifyCharacter = (char) => {
                    const s = char.stats || {};
                    if ((s.strength || 0) >= 88 || (s.vitality || 0) >= 88) return 'frontline';
                    if ((s.agility || 0) >= 90) return 'assassin';
                    if ((s.intelligence || 0) >= 82) return 'caster';
                    return 'hybrid';
                };

                let html = `
                    <div class="loadout-selector-shell" data-selector-scope="characters">
                        <div class="loadout-selector-toolbar">
                            <div class="loadout-selector-head">
                                <div class="loadout-selector-title">Selector de Personajes</div>
                                <div class="loadout-selector-subtitle">Elige tu estilo principal de combate</div>
                            </div>
                            <div class="loadout-selector-controls">
                                <input class="loadout-selector-search" type="text" placeholder="Buscar personaje...">
                                <button class="loadout-filter-pill active" data-filter="all">Todos</button>
                                <button class="loadout-filter-pill" data-filter="equipped">Equipado</button>
                                <button class="loadout-filter-pill" data-filter="frontline">Frontline</button>
                                <button class="loadout-filter-pill" data-filter="assassin">Assassin</button>
                                <button class="loadout-filter-pill" data-filter="caster">Caster</button>
                            </div>
                        </div>
                        <div class="loadout-card-grid">
                `;

                rolesData.characters.forEach(char => {
                    const isEquipped = EquipmentManager.equippedRole?.id === char.id;
                    const styleTag = classifyCharacter(char);
                    const searchKey = `${char.name} ${char.title || ''}`.toLowerCase().replace(/"/g, '&quot;');

                    html += `
                        <div class="role-card loadout-role-card ${isEquipped ? 'active' : ''}"
                            data-role-id="${char.id}"
                            data-role-type="character"
                            data-role-name="${searchKey}"
                            data-role-state="${isEquipped ? 'equipped' : 'available'}"
                            data-role-style="${styleTag}">
                            <div class="loadout-card-visual">
                                <div style="filter: drop-shadow(0 0 22px rgba(103, 240, 255, 0.35));">
                                    ${IconRenderer.getIconHTML(char.id, 94)}
                                </div>
                                <div class="loadout-card-badge">${isEquipped ? 'EQUIPADO' : styleTag.toUpperCase()}</div>
                            </div>
                            <div class="loadout-card-body">
                                <div class="loadout-card-name">${char.name}</div>
                                <div class="loadout-card-meta">
                                    <span>${char.title || 'Especialista'}</span>
                                    <span>LVL STYLE</span>
                                </div>
                                <div class="loadout-card-desc">${char.description || 'Sin descripcion disponible.'}</div>
                                <div class="loadout-card-footer">
                                    <div class="loadout-card-chip">PWR ${char.stats?.strength || 0} | SPD ${char.stats?.agility || 0} | VIT ${char.stats?.vitality || 0}</div>
                                    <button class="loadout-card-cta">${isEquipped ? 'Activo' : 'Equipar'}</button>
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += '</div></div>';
                return html;
            },

            renderFruitsTab() {
                const classifyFruit = (fruit) => {
                    if (fruit.id.includes('void') || fruit.id.includes('glacier')) return 'control';
                    if (fruit.id.includes('nature') || fruit.id.includes('radiance')) return 'sustain';
                    return 'burst';
                };

                let html = `
                    <div class="loadout-selector-shell" data-selector-scope="fruits">
                        <div class="loadout-selector-toolbar">
                            <div class="loadout-selector-head">
                                <div class="loadout-selector-title">Selector de Frutas</div>
                                <div class="loadout-selector-subtitle">Poderes elementales para combinaciones tacticas</div>
                            </div>
                            <div class="loadout-selector-controls">
                                <input class="loadout-selector-search" type="text" placeholder="Buscar fruta...">
                                <button class="loadout-filter-pill active" data-filter="all">Todas</button>
                                <button class="loadout-filter-pill" data-filter="equipped">Equipada</button>
                                <button class="loadout-filter-pill" data-filter="burst">Burst</button>
                                <button class="loadout-filter-pill" data-filter="control">Control</button>
                                <button class="loadout-filter-pill" data-filter="sustain">Sustain</button>
                            </div>
                        </div>
                        <div class="loadout-card-grid">
                `;

                rolesData.fruits.forEach(fruit => {
                    const isEquipped = EquipmentManager.equippedRole?.id === fruit.id;
                    const styleTag = classifyFruit(fruit);
                    const searchKey = `${fruit.name} ${fruit.description || ''}`.toLowerCase().replace(/"/g, '&quot;');
                    const quickCd = fruit.ultimateAbility?.cooldown ? `${Math.round(fruit.ultimateAbility.cooldown / 1000)}s` : '--';

                    html += `
                        <div class="role-card loadout-role-card ${isEquipped ? 'active' : ''}"
                            data-role-id="${fruit.id}"
                            data-role-type="fruit"
                            data-role-name="${searchKey}"
                            data-role-state="${isEquipped ? 'equipped' : 'available'}"
                            data-role-style="${styleTag}">
                            <div class="loadout-card-visual">
                                <div style="filter: drop-shadow(0 0 22px rgba(103, 240, 255, 0.35));">
                                    ${IconRenderer.getIconHTML(fruit.id, 92)}
                                </div>
                                <div class="loadout-card-badge">${isEquipped ? 'EQUIPADA' : styleTag.toUpperCase()}</div>
                            </div>
                            <div class="loadout-card-body">
                                <div class="loadout-card-name">${fruit.name}</div>
                                <div class="loadout-card-meta">
                                    <span>Tipo ${styleTag}</span>
                                    <span>ULT ${quickCd}</span>
                                </div>
                                <div class="loadout-card-desc">${fruit.description || 'Sin descripcion disponible.'}</div>
                                <div class="loadout-card-footer">
                                    <div class="loadout-card-chip">${fruit.abilities?.length || 0} skills + ultimate</div>
                                    <button class="loadout-card-cta">${isEquipped ? 'Activa' : 'Equipar'}</button>
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += '</div></div>';
                return html;
            },

            renderClassesTab() {
                let html = `
                    <div class="loadout-selector-shell" data-selector-scope="classes">
                        <div class="loadout-selector-toolbar">
                            <div class="loadout-selector-head">
                                <div class="loadout-selector-title">Selector de Clases</div>
                                <div class="loadout-selector-subtitle">Tickets, tiers y maestrias en una vista unificada</div>
                            </div>
                            <div class="loadout-selector-controls">
                                <input class="loadout-selector-search" type="text" placeholder="Buscar clase o tier...">
                                <button class="loadout-filter-pill active" data-filter="all">Todas</button>
                                <button class="loadout-filter-pill" data-filter="unlocked">Desbloqueadas</button>
                                <button class="loadout-filter-pill" data-filter="ready">Listas</button>
                                <button class="loadout-filter-pill" data-filter="locked">Bloqueadas</button>
                                <button class="loadout-filter-pill" data-filter="master">Master</button>
                            </div>
                        </div>
                `;

                const tierGroups = { 'SSS': [], 'SS': [], 'S+': [], 'S': [], 'A': [], 'B': [] };

                rolesData.classes.forEach(cls => {
                    if (cls.tier && tierGroups[cls.tier]) tierGroups[cls.tier].push(cls);
                });

                Object.keys(tierGroups).forEach(tier => {
                    if (tierGroups[tier].length === 0) return;

                    html += `
                        <section class="loadout-group">
                            <div class="loadout-group-head">
                                <div class="loadout-group-title">TIER ${tier}</div>
                                <div class="loadout-group-line"></div>
                            </div>
                            <div class="loadout-card-grid">
                    `;

                    tierGroups[tier].forEach(cls => {
                        const isEquipped = EquipmentManager.equippedRole?.id === cls.id;
                        const isUnlocked = EquipmentManager.isClassUnlocked(cls.id);
                        const currentTickets = EquipmentManager.classTickets[cls.id] || 0;
                        const hasEnoughTickets = currentTickets >= cls.ticketsRequired;
                        const canUnlock = !isUnlocked && hasEnoughTickets;
                        const state = isUnlocked ? 'unlocked' : (canUnlock ? 'ready' : 'locked');
                        const searchKey = `${cls.name} tier ${cls.tier} ${cls.description || ''}`.toLowerCase().replace(/"/g, '&quot;');

                        html += `
                            <div class="role-card loadout-role-card ${isEquipped ? 'active' : ''}"
                                data-role-id="${cls.id}"
                                data-role-type="class"
                                data-role-kind="class"
                                data-role-name="${searchKey}"
                                data-role-state="${state}"
                                data-role-tier="${cls.tier || ''}">
                                <div class="loadout-card-visual" style="background: radial-gradient(circle at 50% 40%, ${cls.tierColor || '#00d9ff'}30, rgba(8, 14, 29, 0.2) 65%, transparent 95%);">
                                    <div style="filter: drop-shadow(0 0 18px ${cls.tierColor || '#00d9ff'});">
                                        ${IconRenderer.getIconHTML(cls.id, 88)}
                                    </div>
                                    <div class="loadout-card-badge" style="border-color:${cls.tierColor || '#00d9ff'}66; color:${cls.tierColor || '#00d9ff'};">${state.toUpperCase()}</div>
                                </div>
                                <div class="loadout-card-body">
                                    <div class="loadout-card-name">${cls.name}</div>
                                    <div class="loadout-card-meta">
                                        <span>TIER ${cls.tier || 'N/A'}</span>
                                        <span>${currentTickets}/${cls.ticketsRequired} TK</span>
                                    </div>
                                    <div class="loadout-card-desc">${cls.description || 'Sin descripcion disponible.'}</div>
                                    <div class="loadout-card-footer">
                                        <div class="loadout-card-chip">${state === 'unlocked' ? 'Desbloqueada' : state === 'ready' ? 'Lista para desbloquear' : 'Recolecta tickets'}</div>
                                        <button class="loadout-card-cta ${canUnlock ? 'ready' : ''}">${isEquipped ? 'Activa' : isUnlocked ? 'Ver clase' : canUnlock ? 'Desbloquear' : 'Bloqueada'}</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    });

                    html += '</div></section>';
                });

                html += `
                    <section class="loadout-group" style="margin-top: 20px;">
                        <div class="loadout-group-head">
                            <div class="loadout-group-title">MASTER CLASSES</div>
                            <div class="loadout-group-line"></div>
                        </div>
                        <div class="loadout-card-grid">
                `;

                rolesData.masterClasses.forEach(masterCls => {
                    const isEquipped = EquipmentManager.equippedRole?.id === masterCls.id;
                    const isUnlocked = LoadoutManager.unlockedMasterClasses.includes(masterCls.id);
                    const state = isUnlocked ? 'unlocked' : 'locked';
                    const color = masterCls.tierColor || '#ff00ff';
                    const searchKey = `${masterCls.name} master ${masterCls.description || ''}`.toLowerCase().replace(/"/g, '&quot;');

                    html += `
                        <div class="role-card loadout-role-card ${isEquipped ? 'active' : ''}"
                            data-role-id="${masterCls.id}"
                            data-role-type="master_class"
                            data-role-kind="master"
                            data-role-name="${searchKey}"
                            data-role-state="${state}"
                            data-role-tier="MASTER">
                            <div class="loadout-card-visual" style="background: radial-gradient(circle at 50% 40%, ${color}35, rgba(8, 14, 29, 0.2) 65%, transparent 95%);">
                                <div style="filter: drop-shadow(0 0 18px ${color});">${IconRenderer.getIconHTML(masterCls.id, 92)}</div>
                                <div class="loadout-card-badge" style="border-color:${color}66; color:${color};">${isUnlocked ? 'UNLOCKED' : 'LOCKED'}</div>
                            </div>
                            <div class="loadout-card-body">
                                <div class="loadout-card-name">${masterCls.name}</div>
                                <div class="loadout-card-meta">
                                    <span>MASTER TIER</span>
                                    <span>${isUnlocked ? 'READY' : 'MISSION'}</span>
                                </div>
                                <div class="loadout-card-desc">${masterCls.description || 'Sin descripcion disponible.'}</div>
                                <div class="loadout-card-footer">
                                    <div class="loadout-card-chip">${isUnlocked ? 'Lista para equipar' : 'Completa maestrias'}</div>
                                    <button onclick="LoadoutManager.showTab('masteries')" class="loadout-card-cta">${isUnlocked ? (isEquipped ? 'Activa' : 'Equipar') : 'Ver requisitos'}</button>
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += '</div></section></div>';
                return html;
            },

            renderMasteriesTab() {
                let html = '<div style="padding: 20px; animation: slideUp 0.5s cubic-bezier(0.19, 1, 0.22, 1);">';

                // --- 1. CLASS MASTERIES ---
                html += `
                        <div style="margin-bottom: 60px;">
                            <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 40px;">
                                <h2 style="font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 900; color: #fff; margin:0; letter-spacing: 4px;">CLASS EVOLUTION</h2>
                                <div style="height: 2px; flex: 1; background: linear-gradient(90deg, rgba(255, 0, 255, 0.2), transparent);"></div>
                            </div>
                        `;

                const classesWithMastery = rolesData.classes.filter(cls =>
                    rolesData.masterClasses.some(mc => mc.baseClassId === cls.id)
                );

                if (classesWithMastery.length === 0) {
                    html += `<div style="text-align:center; color: rgba(224, 231, 255, 0.3); font-family: 'Orbitron', sans-serif; padding: 40px; border: 1px dashed rgba(255,0,255,0.1); border-radius: 20px;">NO EVOLUTION VECTORS DETECTED</div>`;
                }

                classesWithMastery.forEach(cls => {
                    const masterClass = rolesData.masterClasses.find(mc => mc.baseClassId === cls.id);
                    const progress = this.getMissionProgress(cls.id);
                    const isUnlocked = this.unlockedMasterClasses.includes(masterClass.id);
                    const tierColor = masterClass.tierColor || '#ff00ff';

                    const totalReqs = progress?.requirements.length || 0;
                    const completedReqs = progress?.requirements.filter(r => r.current >= (r.amount || r.waves)).length || 0;
                    const percent = totalReqs > 0 ? (completedReqs / totalReqs) * 100 : 0;

                    html += `
                            <div style="background: rgba(0, 0, 0, 0.2); backdrop-filter: blur(20px); border: 2px solid ${isUnlocked ? '#00ff00' : 'rgba(255, 0, 255, 0.1)'}; border-radius: 30px; margin-bottom: 30px; overflow: hidden; position: relative;">
                                <div style="display: flex; align-items: stretch; flex-wrap: wrap;">
                                    
                                    <!-- Left Node: Base -->
                                    <div style="width: 220px; padding: 40px; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.2); border-right: 1px solid rgba(255,255,255,0.05);">
                                        <div style="filter: drop-shadow(0 0 15px ${cls.tierColor}); opacity: 0.6; transform: scale(0.8);">
                                            ${IconRenderer.getIconHTML(cls.id, 80)}
                                        </div>
                                        <div style="margin-top: 15px; font-family: 'Orbitron', sans-serif; font-size: 14px; font-weight: 800; color: ${cls.tierColor};">${cls.name}</div>
                                        <div style="font-size: 10px; color: rgba(224, 231, 255, 0.3); margin-top: 5px; font-weight: 800; letter-spacing: 2px;">BASE VECTOR</div>
                                    </div>

                                    <!-- Center Node: Transition -->
                                    <div style="width: 80px; display: flex; align-items: center; justify-content: center; position: relative;">
                                        <div style="width: 2px; height: 100px; background: linear-gradient(to bottom, transparent, ${tierColor}40, transparent); position: absolute;"></div>
                                        <div style="width: 40px; height: 40px; background: #000; border: 2px solid ${tierColor}; border-radius: 50%; display: flex; align-items: center; justify-content: center; z-index: 10; font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 900; color: ${tierColor}; box-shadow: 0 0 20px ${tierColor}40;">
                                            »
                                        </div>
                                    </div>

                                    <!-- Right Node: Evolution -->
                                    <div style="flex: 1; padding: 40px; position: relative;">
                                        <div style="display: flex; gap: 30px; align-items: center; margin-bottom: 30px;">
                                            <div style="filter: drop-shadow(0 0 25px ${tierColor});">
                                                ${IconRenderer.getIconHTML(masterClass.id, 100)}
                                            </div>
                                            <div>
                                                <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 8px;">
                                                    <h3 style="font-family: 'Orbitron', sans-serif; color: #fff; font-size: 28px; font-weight: 900; margin: 0;">${masterClass.name}</h3>
                                                    ${isUnlocked ? `
                                                        <div style="background: rgba(0, 255, 0, 0.1); border: 1px solid #00ff00; padding: 4px 12px; border-radius: 8px; color: #00ff00; font-family: 'Orbitron', sans-serif; font-size: 10px; font-weight: 900;">AUTHORIZED</div>
                                                    ` : ''}
                                                </div>
                                                <p style="color: rgba(224, 231, 255, 0.6); font-size: 14px; margin: 0; max-width: 600px; line-height: 1.6;">${masterClass.description}</p>
                                            </div>
                                        </div>

                                        ${!isUnlocked ? `
                                            <div style="background: rgba(255, 255, 255, 0.03); border-radius: 20px; padding: 25px; border: 1px solid rgba(255, 255, 255, 0.05);">
                                                <div style="display: flex; justify-content: space-between; margin-bottom: 12px; font-family: 'Orbitron', sans-serif;">
                                                    <span style="color: rgba(224, 231, 255, 0.4); font-size: 11px; font-weight: 800; text-transform: uppercase; letter-spacing: 2px;">Evolution Sync Status</span>
                                                    <span style="color: ${tierColor}; font-size: 14px; font-weight: 900;">${Math.round(percent)}%</span>
                                                </div>
                                                <div style="height: 6px; background: rgba(255,255,255,0.05); border-radius: 3px; overflow: hidden; margin-bottom: 20px;">
                                                    <div style="height: 100%; background: ${tierColor}; width: ${percent}%; box-shadow: 0 0 15px ${tierColor};"></div>
                                                </div>
                                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                                                    ${progress.requirements.map(req => {
                        const reqMet = req.current >= (req.amount || req.waves);
                        return `
                                                            <div style="display: flex; align-items: center; gap: 12px; font-size: 12px; color: ${reqMet ? '#00ff00' : 'rgba(224, 231, 255, 0.4)'}; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 10px; border: 1px solid ${reqMet ? 'rgba(0,255,0,0.2)' : 'rgba(255,255,255,0.03)'};">
                                                                <div style="width: 6px; height: 6px; border-radius: 50%; background: ${reqMet ? '#00ff00' : 'rgba(255,255,255,0.1)'}; box-shadow: ${reqMet ? '0 0 10px #00ff00' : 'none'};"></div>
                                                                <span style="flex: 1;">${req.description}</span>
                                                                <span style="font-family: 'Orbitron', sans-serif; font-size: 10px; font-weight: 800;">${req.current}/${req.amount || req.waves}</span>
                                                            </div>
                                                        `;
                    }).join('')}
                                                </div>
                                            </div>
                                        ` : `
                                            <div style="display: flex; align-items: center; gap: 20px; padding: 25px; background: rgba(0, 255, 0, 0.05); border-radius: 20px; border: 1px solid rgba(0, 255, 0, 0.1);">
                                                <div style="width: 40px; height: 40px; background: #00ff00; color: #000; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: 900;">✓</div>
                                                <div style="flex: 1;">
                                                    <div style="font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 900; color: #00ff00;">PROTOCOL READY</div>
                                                    <div style="color: rgba(224, 231, 255, 0.5); font-size: 11px; margin-top: 2px;">Evolution vector is available in the Classes terminal.</div>
                                                </div>
                                                <button onclick="LoadoutManager.showTab('classes')" style="padding: 10px 25px; background: #00ff00; color: #000; border: none; border-radius: 12px; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 900; cursor: pointer; transition: 0.2s;" onmouseover="this.style.transform='scale(1.05)';" onmouseout="this.style.transform='';">DEPLOY NOW</button>
                                            </div>
                                        `}
                                    </div>
                                </div>
                            </div>
                        `;
                });

                html += `</div>`;

                // --- 2. CHARACTER EVOLUTIONS (CONSTRUCTION ZONE) ---
                html += `
                        <div style="margin-top: 80px; position: relative; padding: 80px; border-radius: 40px; background: rgba(30, 0, 60, 0.2); border: 2px dashed rgba(255, 0, 255, 0.2); text-align: center; overflow: hidden;">
                            <div style="position: absolute; top:0; left:0; right:0; height: 10px; background: repeating-linear-gradient(45deg, #ff00ff, #ff00ff 20px, #000 20px, #000 40px);"></div>
                            <div style="position: absolute; bottom:0; left:0; right:0; height: 10px; background: repeating-linear-gradient(45deg, #ff00ff, #ff00ff 20px, #000 20px, #000 40px);"></div>
                            
                            <div style="font-family: 'Orbitron', sans-serif; font-size: 64px; color: #ff00ff; opacity: 0.1; position: absolute; transform: rotate(-15deg); top: 20px; left: 20px;">RESTRICTED</div>
                            <div style="font-family: 'Orbitron', sans-serif; font-size: 64px; color: #ff00ff; opacity: 0.1; position: absolute; transform: rotate(15deg); bottom: 20px; right: 20px;">OFF-LIMITS</div>
                            
                            <div style="position: relative; z-index: 10;">
                                <div style="font-size: 60px; margin-bottom: 20px; filter: drop-shadow(0 0 20px #ff00ff);">⚠️</div>
                                <h2 style="font-family: 'Orbitron', sans-serif; font-size: 32px; font-weight: 900; color: #fff; margin-bottom: 15px; letter-spacing: 4px;">CHARACTER TRANSCENDENCE</h2>
                                <p style="color: rgba(224, 231, 255, 0.5); font-weight: 700; text-transform: uppercase; letter-spacing: 2px;">System evolution in progress. Genetic locks active.</p>
                                <div style="display: inline-block; margin-top: 30px; padding: 10px 30px; border: 1px solid #ff00ff; color: #ff00ff; font-family: 'Orbitron', sans-serif; font-weight: 900; font-size: 12px; border-radius: 50px; background: rgba(255,0,255,0.05);">ESTIMATED SYNC: Q3-2026</div>
                            </div>
                        </div>
                        `;

                html += `</div>`;
                return html;
            },


            attachCharacterListeners() {
                document.querySelectorAll('[data-role-type="character"]').forEach(card => {
                    card.addEventListener('click', () => {
                        const roleId = card.dataset.roleId;
                        const role = rolesData.characters.find(r => r.id === roleId);
                        if (role) {
                            EquipmentManager.equipRole(role);
                            this.showTab('equipped');
                        }
                    });
                });
            },

            attachClassListeners() {
                document.querySelectorAll('[data-role-type="class"]').forEach(card => {
                    card.addEventListener('click', () => {
                        const roleId = card.dataset.roleId;
                        const role = rolesData.classes.find(r => r.id === roleId);
                        if (role) {
                            UIManager.showRoleInfoPanel(role,
                                !EquipmentManager.isClassUnlocked(role.id) && (EquipmentManager.classTickets[role.id] || 0) < role.ticketsRequired,
                                EquipmentManager.classTickets[role.id] || 0,
                                !EquipmentManager.isClassUnlocked(role.id) && (EquipmentManager.classTickets[role.id] || 0) >= role.ticketsRequired,
                                EquipmentManager.isClassUnlocked(role.id)
                            );
                        }
                    });
                });

                // Master Classes listeners
                document.querySelectorAll('[data-role-type="master_class"]').forEach(card => {
                    card.addEventListener('click', () => {
                        const roleId = card.dataset.roleId;
                        const role = rolesData.masterClasses.find(r => r.id === roleId);
                        if (role) {
                            const isUnlocked = LoadoutManager.unlockedMasterClasses.includes(role.id);
                            if (isUnlocked) {
                                EquipmentManager.equipRole(role);
                                this.showTab('equipped');
                            } else {
                                alert('🔒 Debes completar la misión de maestría para desbloquear esta clase. Ve a la pestaña "Maestrías" para ver los requisitos.');
                            }
                        }
                    });
                });
            },

            attachFruitListeners() {
                document.querySelectorAll('[data-role-type="fruit"]').forEach(card => {
                    card.addEventListener('click', () => {
                        const roleId = card.dataset.roleId;
                        const role = rolesData.fruits.find(r => r.id === roleId);
                        if (role) {
                            EquipmentManager.equipRole(role);
                            this.showTab('equipped');
                        }
                    });
                });
            },

            attachSelectorControls(scope) {
                const shell = document.querySelector(`#loadout-content [data-selector-scope="${scope}"]`);
                if (!shell) return;

                const cards = shell.querySelectorAll('.loadout-role-card');
                const search = shell.querySelector('.loadout-selector-search');
                const pills = shell.querySelectorAll('.loadout-filter-pill');
                let activeFilter = 'all';

                const matchesFilter = (card, filter) => {
                    if (filter === 'all') return true;
                    if (filter === 'equipped') return card.dataset.roleState === 'equipped';
                    if (filter === 'unlocked') return card.dataset.roleState === 'unlocked';
                    if (filter === 'locked') return card.dataset.roleState === 'locked';
                    if (filter === 'ready') return card.dataset.roleState === 'ready';
                    if (filter === 'master') return card.dataset.roleKind === 'master';
                    if (filter === 'frontline' || filter === 'assassin' || filter === 'caster') return card.dataset.roleStyle === filter;
                    if (filter === 'burst' || filter === 'control' || filter === 'sustain') return card.dataset.roleStyle === filter;
                    return true;
                };

                const applyFilters = () => {
                    const term = (search?.value || '').trim().toLowerCase();
                    cards.forEach(card => {
                        const name = card.dataset.roleName || '';
                        const matchName = !term || name.includes(term);
                        const matchPill = matchesFilter(card, activeFilter);
                        card.style.display = (matchName && matchPill) ? '' : 'none';
                    });
                };

                if (search) {
                    search.addEventListener('input', applyFilters);
                }

                pills.forEach(pill => {
                    pill.addEventListener('click', () => {
                        pills.forEach(p => p.classList.remove('active'));
                        pill.classList.add('active');
                        activeFilter = pill.dataset.filter || 'all';
                        applyFilters();
                    });
                });

                applyFilters();
            },

            // Mission Tracker Methods
            toggleMissionTracker() {
                this.missionTrackerVisible = !this.missionTrackerVisible;
                console.log(this.missionTrackerVisible ? '? Mission Tracker: ON' : '? Mission Tracker: OFF');
            },

            showMissionTracker() {
                this.missionTrackerVisible = true;
            },

            hideMissionTracker() {
                this.missionTrackerVisible = false;
            },

        };

        // ===== PLAYER SYSTEM ===== v19.11.2025
        const Player = {

            x: 550,
            y: 350,
            width: 70,
            height: 70,
            speed: 280,
            baseSpeed: 280, // NEW: Store base speed to fix permanent speed reduction bug
            currentImage: null,
            hp: 100,
            maxHp: 100,
            invulnerable: false,
            invulnerableTime: 0,
            damageBoost: 0, // Percentage damage boost
            damageBoostTime: 0,
            counterActive: false,
            counterTime: 0,
            // NEW v19.11.2025: Passive Regeneration System
            lastDamageTime: 0,
            regenDelay: 3000, // 3 seconds without damage to start regen
            regenRate: 2, // HP per second
            regenActive: false,
            // NEW v19.11.2025: Electrified Status (Storm Titan exclusive)
            electrified: false,
            electrifiedTime: 0,
            // NEW: Invisibility System (Ninja Power)
            invisible: false,
            invisibleTime: 0,
            // NEW: Heat System (Cybernetic Warlord)
            heat: 0, // 0-100
            maxHeat: 100,
            heatDecayRate: 2, // Heat per second decay (BALANCED: 5 ? 2 para hacer el sistema alcanzable)
            overheated: false,
            overheatedTime: 0,
            silenced: false,
            silencedTime: 0,
            // NEW: Level System
            level: 1,
            exp: 0,
            expToNextLevel: 100,
            baseDamage: 10, // Base damage at level 1
            damagePerLevel: 2, // Damage increase per level

            move(dx, dy) {
                const canvas = document.getElementById('game-canvas');
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;

                this.x += dx;
                this.y += dy;

                this.x = Math.max(halfWidth, Math.min(canvas.width - halfWidth, this.x));
                this.y = Math.max(halfHeight, Math.min(canvas.height - halfHeight, this.y));

                // Update position display if element exists
                const posDisplay = document.getElementById('pos-display');
                if (posDisplay) {
                    posDisplay.textContent = `${Math.floor(this.x)}, ${Math.floor(this.y)}`;
                }
            },

            render(ctx) {
                // Apply invisibility effect
                if (this.invisible) {
                    ctx.globalAlpha = 0.3;
                }

                // AETHERIS ZENITH - MASSIVE PLAYER MODEL REDESIGN
                ctx.save();
                const time = Date.now();
                const pulse = 1 + Math.sin(time / 400) * 0.1;
                const size = (this.width / 2) * pulse;

                // 1. NEBULA AURA (Background Cloud)
                const nebulaGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size * 2.5);
                nebulaGrad.addColorStop(0, 'rgba(0, 217, 255, 0.4)');
                nebulaGrad.addColorStop(0.5, 'rgba(255, 0, 110, 0.2)');
                nebulaGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');

                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = nebulaGrad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size * 2.5, 0, Math.PI * 2);
                ctx.fill();

                // 2. GEOMETRIC SHELLS (Rotating Polygons)
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00d9ff';

                const drawShell = (sides, radius, rotSpeed, color) => {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(time * rotSpeed);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = 0; i < sides; i++) {
                        const angle = (i * 2 * Math.PI) / sides;
                        const px = Math.cos(angle) * radius;
                        const py = Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                };

                drawShell(6, size * 1.2, 0.001, 'rgba(0, 217, 255, 0.6)'); // Hexagon
                drawShell(3, size * 0.9, -0.002, 'rgba(255, 0, 110, 0.8)'); // Triangle
                drawShell(8, size * 1.5, 0.0005, 'rgba(255, 190, 11, 0.4)'); // Octagon

                // 3. THE ZENITH CORE (Pulsing Star)
                const coreGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size * 0.5);
                coreGrad.addColorStop(0, '#fff');
                coreGrad.addColorStop(0.4, '#00d9ff');
                coreGrad.addColorStop(1, '#0066cc');

                ctx.fillStyle = coreGrad;
                ctx.shadowBlur = 30;
                ctx.shadowColor = '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, size * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // 4. ENERGY SPIKES
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                for (let i = 0; i < 4; i++) {
                    const angle = (time / 200) + (i * Math.PI / 2);
                    ctx.beginPath();
                    ctx.moveTo(this.x + Math.cos(angle) * size * 0.5, this.y + Math.sin(angle) * size * 0.5);
                    ctx.lineTo(this.x + Math.cos(angle) * size * 1.3, this.y + Math.sin(angle) * size * 1.3);
                    ctx.stroke();
                }

                // 5. ORBITING PARTICLES
                for (let i = 0; i < 8; i++) {
                    const orbitAngle = (time / 1000) + (i * Math.PI / 4);
                    const px = this.x + Math.cos(orbitAngle) * size * 1.8;
                    const py = this.y + Math.sin(orbitAngle * 1.5) * size * 1.8;

                    ctx.fillStyle = i % 2 === 0 ? '#00d9ff' : '#ff006e';
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();

                    // Particle trail
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = ctx.fillStyle;
                    ctx.fill();
                }

                ctx.restore();
                // Draw HP bar above player
                const barWidth = 80;
                const barHeight = 8;
                const barX = this.x - barWidth / 2;
                const barY = this.y - this.height / 2 - 20;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                const hpPercent = this.hp / this.maxHp;
                const hpColor = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
                ctx.fillStyle = hpColor;
                ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);

                // HP text (FIXED v19.11.2025: Round to avoid long decimals)
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${Math.round(this.hp)}/${this.maxHp}`, this.x, barY - 5);

                // Heat bar (Cybernetic Warlord)
                if (this.heat > 0) {
                    const heatBarY = barY - 15;
                    const heatBarWidth = 80;
                    const heatBarHeight = 6;
                    const heatBarX = this.x - heatBarWidth / 2;

                    // Background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(heatBarX, heatBarY, heatBarWidth, heatBarHeight);

                    // Heat fill
                    const heatPercent = this.heat / this.maxHeat;
                    let heatColor;
                    if (heatPercent >= 1.0) {
                        heatColor = '#ff0000'; // Red at 100%
                    } else if (heatPercent >= 0.5) {
                        heatColor = '#ff6600'; // Orange at 50%+
                    } else {
                        heatColor = '#00ffff'; // Cyan below 50%
                    }

                    ctx.fillStyle = heatColor;
                    ctx.fillRect(heatBarX, heatBarY, heatBarWidth * heatPercent, heatBarHeight);

                    // Heat text
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`HEAT ${Math.round(this.heat)}%`, this.x, heatBarY - 3);

                    // Warning at high heat
                    if (heatPercent >= 0.8) {
                        ctx.fillStyle = '#ff0000';
                        ctx.font = 'bold 10px Arial';
                        ctx.fillText('??', this.x + heatBarWidth / 2 + 10, heatBarY + 3);
                    }
                }

                // MECH-SUIT visual effect
                if (this.mechSuitActive) {
                    ctx.save();

                    // Armor glow
                    const armorGlow = ctx.createRadialGradient(this.x, this.y, this.width / 2, this.x, this.y, this.width / 2 + 20);
                    armorGlow.addColorStop(0, 'rgba(0, 255, 255, 0)');
                    armorGlow.addColorStop(0.7, 'rgba(0, 255, 255, 0.3)');
                    armorGlow.addColorStop(1, 'rgba(0, 255, 255, 0)');

                    ctx.fillStyle = armorGlow;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width / 2 + 20, 0, Math.PI * 2);
                    ctx.fill();

                    // Armor plates (hexagons around player)
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI / 3) + (Date.now() / 1000);
                        const plateX = this.x + Math.cos(angle) * (this.width / 2 + 15);
                        const plateY = this.y + Math.sin(angle) * (this.width / 2 + 15);

                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#00ffff';
                        ctx.beginPath();
                        ctx.arc(plateX, plateY, 8, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // MECH-SUIT text
                    ctx.font = 'bold 10px Arial';
                    ctx.fillStyle = '#00ffff';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ffff';
                    ctx.fillText('?? MECH-SUIT', this.x, this.y + this.height / 2 + 25);

                    ctx.restore();
                }

                // LEGIO AETERNA visual effect (Roman Legionary Ultimate)
                if (this.legioAeternaAura) {
                    ctx.save();

                    // Aura dorada radiante masiva
                    const megaPulse = 1 + Math.sin(Date.now() * 0.008) * 0.4;
                    const auraGradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.legioAeternaAura.radius * megaPulse
                    );
                    auraGradient.addColorStop(0, 'rgba(255, 215, 0, 0.9)');
                    auraGradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.6)');
                    auraGradient.addColorStop(0.6, 'rgba(220, 20, 60, 0.4)');
                    auraGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');

                    ctx.fillStyle = auraGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.legioAeternaAura.radius * megaPulse, 0, Math.PI * 2);
                    ctx.fill();

                    // Capa carmesí ondeando
                    this.legioAeternaAura.capeWave += 0.1;
                    const capePoints = [];
                    const capeSegments = 12;

                    for (let i = 0; i <= capeSegments; i++) {
                        const t = i / capeSegments;
                        const angle = Math.PI + (t - 0.5) * Math.PI * 0.8;
                        const wave = Math.sin(this.legioAeternaAura.capeWave + t * Math.PI * 2) * 15;
                        const distance = 50 + wave;

                        capePoints.push({
                            x: this.x + Math.cos(angle) * distance,
                            y: this.y + Math.sin(angle) * distance + 20
                        });
                    }

                    // Dibujar capa
                    ctx.fillStyle = '#dc143c';
                    ctx.strokeStyle = '#8b0000';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#dc143c';

                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    capePoints.forEach(point => {
                        ctx.lineTo(point.x, point.y);
                    });
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Símbolos romanos girando alrededor
                    const symbolCount = 12;
                    for (let i = 0; i < symbolCount; i++) {
                        const angle = (Math.PI * 2 / symbolCount) * i + (Date.now() / 600);
                        const symbolX = this.x + Math.cos(angle) * 90;
                        const symbolY = this.y + Math.sin(angle) * 90;

                        ctx.font = 'bold 28px Arial';
                        ctx.fillStyle = '#ffd700';
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#ffd700';
                        ctx.fillText('??', symbolX, symbolY);
                    }

                    // Corona imperial sobre el jugador
                    ctx.font = 'bold 40px Arial';
                    ctx.fillStyle = '#ffd700';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ffd700';
                    ctx.fillText('??', this.x, this.y - this.height / 2 - 40);

                    ctx.restore();
                }

                // THERMOPYLAE visual effect (Spartan Hoplite Ultimate)
                if (this.thermopylaeAura) {
                    ctx.save();

                    // Aura masiva roja y bronce
                    const megaPulse = 1 + Math.sin(Date.now() * 0.009) * 0.45;
                    const auraGradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.thermopylaeAura.radius * megaPulse
                    );
                    auraGradient.addColorStop(0, 'rgba(139, 0, 0, 0.85)');
                    auraGradient.addColorStop(0.3, 'rgba(139, 0, 0, 0.6)');
                    auraGradient.addColorStop(0.6, 'rgba(205, 127, 50, 0.4)');
                    auraGradient.addColorStop(1, 'rgba(139, 0, 0, 0)');

                    ctx.fillStyle = auraGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.thermopylaeAura.radius * megaPulse, 0, Math.PI * 2);
                    ctx.fill();

                    // Capa roja ondeando
                    this.thermopylaeAura.capeWave += 0.12;
                    const capePoints = [];
                    const capeSegments = 10;

                    for (let i = 0; i <= capeSegments; i++) {
                        const t = i / capeSegments;
                        const angle = Math.PI + (t - 0.5) * Math.PI * 0.75;
                        const wave = Math.sin(this.thermopylaeAura.capeWave + t * Math.PI * 2) * 18;
                        const distance = 55 + wave;

                        capePoints.push({
                            x: this.x + Math.cos(angle) * distance,
                            y: this.y + Math.sin(angle) * distance + 25
                        });
                    }

                    // Dibujar capa
                    ctx.fillStyle = '#8B0000';
                    ctx.strokeStyle = '#CD7F32';
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 28;
                    ctx.shadowColor = '#8B0000';

                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    capePoints.forEach(point => {
                        ctx.lineTo(point.x, point.y);
                    });
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Símbolos lambda girando
                    const symbolCount = 14;
                    for (let i = 0; i < symbolCount; i++) {
                        const angle = (Math.PI * 2 / symbolCount) * i + (Date.now() / 550);
                        const symbolX = this.x + Math.cos(angle) * 95;
                        const symbolY = this.y + Math.sin(angle) * 95;

                        ctx.font = 'bold 30px Arial';
                        ctx.fillStyle = '#CD7F32';
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 22;
                        ctx.shadowColor = '#CD7F32';
                        ctx.fillText('?', symbolX, symbolY);
                    }

                    // Casco espartano sobre el jugador
                    ctx.font = 'bold 45px Arial';
                    ctx.fillStyle = '#CD7F32';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 35;
                    ctx.shadowColor = '#CD7F32';
                    ctx.fillText('??', this.x, this.y - this.height / 2 - 45);

                    ctx.restore();
                }

                // ARES BLESSING visual effect (Spartan Hoplite)
                if (this.aresBlessing && this.aresSymbol) {
                    ctx.save();

                    // Aura de fuego rojo intenso
                    const megaPulse = 1 + Math.sin(Date.now() * 0.01) * 0.4;
                    const fireGradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, 90 * megaPulse
                    );
                    fireGradient.addColorStop(0, 'rgba(139, 0, 0, 0.7)');
                    fireGradient.addColorStop(0.4, 'rgba(255, 69, 0, 0.5)');
                    fireGradient.addColorStop(0.7, 'rgba(205, 127, 50, 0.3)');
                    fireGradient.addColorStop(1, 'rgba(139, 0, 0, 0)');

                    ctx.fillStyle = fireGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 90 * megaPulse, 0, Math.PI * 2);
                    ctx.fill();

                    // Símbolo de Ares girando (espadas cruzadas)
                    this.aresSymbol.rotation += 0.02;

                    ctx.save();
                    ctx.translate(this.x, this.y - this.height / 2 - 50);
                    ctx.rotate(this.aresSymbol.rotation);

                    // Espadas cruzadas
                    ctx.font = 'bold 40px Arial';
                    ctx.fillStyle = '#8B0000';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#8B0000';
                    ctx.fillText('??', -15, 0);
                    ctx.fillText('??', 15, 0);

                    ctx.restore();

                    // Llamas alrededor del jugador
                    const flameCount = 12;
                    for (let i = 0; i < flameCount; i++) {
                        const angle = (Math.PI * 2 / flameCount) * i + (Date.now() / 400);
                        const flameX = this.x + Math.cos(angle) * 60;
                        const flameY = this.y + Math.sin(angle) * 60;

                        ctx.font = 'bold 20px Arial';
                        ctx.fillStyle = '#FF4500';
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#FF4500';
                        ctx.fillText('??', flameX, flameY);
                    }

                    // Texto de bendición
                    ctx.font = 'bold 14px Orbitron';
                    ctx.fillStyle = '#8B0000';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#8B0000';
                    ctx.fillText('?? ARES ??', this.x, this.y + this.height / 2 + 30);

                    ctx.font = 'bold 10px Arial';
                    ctx.fillStyle = '#FF4500';
                    ctx.fillText('x2 DMG | 20% LIFESTEAL', this.x, this.y + this.height / 2 + 45);

                    ctx.restore();
                }

                // AROO AURA visual effect (Spartan Hoplite)
                if (this.arooAura && (Date.now() - this.arooAura.startTime < this.arooAura.duration)) {
                    ctx.save();

                    // Aura roja espartana intensa
                    const pulse = 1 + Math.sin(Date.now() * 0.006) * 0.35;
                    const auraGradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.arooAura.radius * pulse
                    );
                    auraGradient.addColorStop(0, 'rgba(139, 0, 0, 0.5)');
                    auraGradient.addColorStop(0.5, 'rgba(205, 127, 50, 0.35)');
                    auraGradient.addColorStop(1, 'rgba(139, 0, 0, 0)');

                    ctx.fillStyle = auraGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.arooAura.radius * pulse, 0, Math.PI * 2);
                    ctx.fill();

                    // Lanzas girando alrededor del jugador
                    const spearCount = 8;
                    for (let i = 0; i < spearCount; i++) {
                        const angle = (Math.PI * 2 / spearCount) * i + (Date.now() / 700);
                        const spearX = this.x + Math.cos(angle) * 55;
                        const spearY = this.y + Math.sin(angle) * 55;

                        ctx.font = 'bold 22px Arial';
                        ctx.fillStyle = '#CD7F32';
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 18;
                        ctx.shadowColor = '#CD7F32';
                        ctx.fillText('???', spearX, spearY);
                    }

                    // Texto de buff
                    ctx.font = 'bold 12px Orbitron';
                    ctx.fillStyle = '#8B0000';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 18;
                    ctx.shadowColor = '#8B0000';
                    ctx.fillText('?? AROO!', this.x, this.y + this.height / 2 + 30);

                    ctx.font = 'bold 10px Arial';
                    ctx.fillStyle = '#CD7F32';
                    ctx.fillText('+60% DMG +40% RES', this.x, this.y + this.height / 2 + 45);

                    ctx.restore();
                } else if (this.arooAura) {
                    this.arooAura = null;
                }

                // CENTURION AURA visual effect (Roman Legionary)
                if (this.centurionAura && (Date.now() - this.centurionAura.startTime < this.centurionAura.duration)) {
                    ctx.save();

                    // Aura carmesí pulsante de poder
                    const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.3;
                    const auraGradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.centurionAura.radius * pulse
                    );
                    auraGradient.addColorStop(0, 'rgba(220, 20, 60, 0.4)');
                    auraGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.3)');
                    auraGradient.addColorStop(1, 'rgba(220, 20, 60, 0)');

                    ctx.fillStyle = auraGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.centurionAura.radius * pulse, 0, Math.PI * 2);
                    ctx.fill();

                    // Espadas girando alrededor del jugador
                    const swordCount = 6;
                    for (let i = 0; i < swordCount; i++) {
                        const angle = (Math.PI * 2 / swordCount) * i + (Date.now() / 800);
                        const swordX = this.x + Math.cos(angle) * 50;
                        const swordY = this.y + Math.sin(angle) * 50;

                        ctx.font = 'bold 20px Arial';
                        ctx.fillStyle = '#ffd700';
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ffd700';
                        ctx.fillText('??', swordX, swordY);
                    }

                    // Texto de buff
                    ctx.font = 'bold 12px Orbitron';
                    ctx.fillStyle = '#dc143c';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#dc143c';
                    ctx.fillText('?? CENTURIÓN', this.x, this.y + this.height / 2 + 30);

                    ctx.font = 'bold 10px Arial';
                    ctx.fillStyle = '#ffd700';
                    ctx.fillText('+50% DMG', this.x, this.y + this.height / 2 + 45);

                    ctx.restore();
                } else if (this.centurionAura) {
                    // Limpiar aura cuando expire
                    this.centurionAura = null;
                }

                // TESTUDO FORMATION visual effect (Roman Legionary)
                if (this.testudoActive && this.testudoShields) {
                    ctx.save();

                    // Aura dorada pulsante
                    const pulse = 1 + Math.sin(Date.now() * this.testudoAura.pulseSpeed) * 0.2;
                    const auraGradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.testudoAura.radius * pulse
                    );
                    auraGradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                    auraGradient.addColorStop(0.5, 'rgba(220, 20, 60, 0.2)');
                    auraGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');

                    ctx.fillStyle = auraGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.testudoAura.radius * pulse, 0, Math.PI * 2);
                    ctx.fill();

                    // Escudos romanos girando alrededor del jugador
                    this.testudoShields.forEach((shield, index) => {
                        const rotationSpeed = 0.002;
                        shield.angle += rotationSpeed;

                        const shieldX = this.x + Math.cos(shield.angle) * shield.distance;
                        const shieldY = this.y + Math.sin(shield.angle) * shield.distance;

                        // Escudo con borde dorado
                        ctx.strokeStyle = '#ffd700';
                        ctx.fillStyle = '#dc143c';
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ffd700';

                        // Forma de escudo (rectángulo redondeado)
                        const shieldWidth = 20;
                        const shieldHeight = 28;
                        ctx.beginPath();
                        ctx.roundRect(
                            shieldX - shieldWidth / 2,
                            shieldY - shieldHeight / 2,
                            shieldWidth,
                            shieldHeight,
                            4
                        );
                        ctx.fill();
                        ctx.stroke();

                        // Símbolo romano en el escudo
                        ctx.font = 'bold 14px Arial';
                        ctx.fillStyle = '#ffd700';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = 5;
                        ctx.fillText('??', shieldX, shieldY);
                    });

                    // Texto TESTUDO
                    ctx.font = 'bold 12px Orbitron';
                    ctx.fillStyle = '#ffd700';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffd700';
                    ctx.fillText('??? TESTUDO', this.x, this.y + this.height / 2 + 30);

                    // Mostrar reducción de daño
                    ctx.font = 'bold 10px Arial';
                    ctx.fillStyle = '#dc143c';
                    ctx.fillText('-70% DMG', this.x, this.y + this.height / 2 + 45);

                    ctx.restore();
                }

                // PHALANX FORMATION visual effect (Spartan Hoplite)
                if (this.phalanxActive && this.phalanxShields) {
                    ctx.save();

                    // Aura roja espartana pulsante
                    const pulse = 1 + Math.sin(Date.now() * this.phalanxAura.pulseSpeed) * 0.25;
                    const auraGradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.phalanxAura.radius * pulse
                    );
                    auraGradient.addColorStop(0, 'rgba(139, 0, 0, 0.4)');
                    auraGradient.addColorStop(0.5, 'rgba(205, 127, 50, 0.25)');
                    auraGradient.addColorStop(1, 'rgba(139, 0, 0, 0)');

                    ctx.fillStyle = auraGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.phalanxAura.radius * pulse, 0, Math.PI * 2);
                    ctx.fill();

                    // Escudos hoplon girando alrededor del jugador
                    this.phalanxShields.forEach((shield, index) => {
                        const rotationSpeed = 0.0025;
                        shield.angle += rotationSpeed;

                        const shieldX = this.x + Math.cos(shield.angle) * shield.distance;
                        const shieldY = this.y + Math.sin(shield.angle) * shield.distance;

                        // Escudo hoplon con borde de bronce
                        ctx.strokeStyle = '#CD7F32';
                        ctx.fillStyle = '#8B0000';
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 18;
                        ctx.shadowColor = '#CD7F32';

                        // Forma de escudo circular (hoplon)
                        ctx.beginPath();
                        ctx.arc(shieldX, shieldY, 15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();

                        // Lambda espartana en el escudo (?)
                        ctx.font = 'bold 16px Arial';
                        ctx.fillStyle = '#CD7F32';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = 8;
                        ctx.fillText('?', shieldX, shieldY);
                    });

                    // Texto FALANGE
                    ctx.font = 'bold 12px Orbitron';
                    ctx.fillStyle = '#8B0000';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 18;
                    ctx.shadowColor = '#8B0000';
                    ctx.fillText('??? FALANGE', this.x, this.y + this.height / 2 + 30);

                    // Mostrar reducción de daño
                    ctx.font = 'bold 10px Arial';
                    ctx.fillStyle = '#CD7F32';
                    ctx.fillText('-75% DMG', this.x, this.y + this.height / 2 + 45);

                    ctx.restore();
                }

                // Silenced effect
                if (this.silenced) {
                    ctx.save();
                    ctx.font = 'bold 20px Arial';
                    ctx.fillStyle = '#ff0000';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff0000';
                    ctx.fillText('??', this.x, this.y - this.height / 2 - 35);
                    ctx.restore();
                }

                // NEW v19.11.2025: Electrified visual effect (sparks around player only)
                if (this.electrified) {
                    // Electric sparks around player
                    const sparkCount = 4;
                    for (let i = 0; i < sparkCount; i++) {
                        const angle = (Date.now() / 100 + i * Math.PI / 2) % (Math.PI * 2);
                        const sparkX = this.x + Math.cos(angle) * 40;
                        const sparkY = this.y + Math.sin(angle) * 40;
                        ctx.font = '24px Arial';
                        ctx.fillStyle = '#ffff00';
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ffff00';
                        ctx.fillText('?', sparkX, sparkY);
                        ctx.shadowBlur = 0;
                    }
                }

                // Invulnerability flash
                if (this.invulnerable && Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }
                ctx.globalAlpha = 1;
            },

            // Level System Functions
            gainExp(amount, isCustomRaid = false) {
                // Reduce EXP in custom raids by 50%
                if (isCustomRaid) {
                    amount = Math.floor(amount * 0.5);
                }

                this.exp += amount;

                // Show EXP gain notification
                this.showExpGain(amount);

                // Check for level up
                while (this.exp >= this.expToNextLevel) {
                    this.levelUp();
                }

                // Save progress
                EquipmentManager.saveProgress();
            },

            levelUp() {
                this.exp -= this.expToNextLevel;
                this.level++;

                // Calculate new stats
                const oldMaxHp = this.maxHp;
                this.maxHp = 100 + (this.level - 1) * 10; // +10 HP per level

                // Heal to full on level up
                this.hp = this.maxHp;

                // Update EXP requirement (exponential growth)
                this.expToNextLevel = Math.floor(100 * Math.pow(1.15, this.level - 1));

                // Show level up notification
                this.showLevelUp();

                console.log(`?? LEVEL UP! Level ${this.level} | HP: ${this.maxHp} | Next: ${this.expToNextLevel} EXP`);
            },

            getCurrentDamage() {
                // Base damage + level scaling
                return this.baseDamage + (this.level - 1) * this.damagePerLevel;
            },

            showExpGain(amount) {
                const popup = document.createElement('div');
                popup.style.cssText = `
                    position: fixed;
                    top: 25%;
                    right: 50px;
                    background: linear-gradient(135deg, #00d9ff, #00ff88);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 700;
                    z-index: 5000;
                    pointer-events: none;
                    animation: slideInRight 0.5s ease-out, fadeOut 0.5s ease-out 1.5s forwards;
                    font-family: 'Orbitron', sans-serif;
                    border: 2px solid #00ff88;
                    box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
                `;
                popup.textContent = `+${amount} EXP`;
                document.body.appendChild(popup);

                setTimeout(() => popup.remove(), 2000);
            },

            showLevelUp() {
                const popup = document.createElement('div');
                popup.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #ffd700, #ffbe0b);
                    color: #000;
                    padding: 20px 40px;
                    border-radius: 15px;
                    font-size: 32px;
                    font-weight: 900;
                    z-index: 6000;
                    pointer-events: none;
                    animation: scaleIn 0.5s ease-out, fadeOut 0.5s ease-out 2s forwards;
                    font-family: 'Orbitron', sans-serif;
                    border: 4px solid #ffd700;
                    box-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
                    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                `;
                popup.innerHTML = `?? LEVEL ${this.level}! ??`;
                document.body.appendChild(popup);

                setTimeout(() => popup.remove(), 2500);
            },
            takeDamage(damage, attackerId = null) {
                if (this.invulnerable) return;

                // Guardian Tablets Interception
                if (this.guardianTablets > 0) {
                    this.guardianTablets--;
                    console.log(`📜 Tablet intercepted damage! ${this.guardianTablets} remaining.`);

                    // Update current effect visuals if exists
                    const effect = EffectRenderer.activeEffects.find(e => e.id === 'guardian_tablets');
                    if (effect && effect.customData && effect.customData.tablets) {
                        // Find first active tablet and disable it
                        for (let i = 0; i < effect.customData.tablets.length; i++) {
                            if (effect.customData.tablets[i]) {
                                effect.customData.tablets[i] = false;
                                break;
                            }
                        }
                    }

                    // Release sand burst (60 damage to nearby enemies)
                    if (MobRaidSystem && (MobRaidSystem.active || PracticeModeManager.active)) {
                        MobRaidSystem.checkAbilityHit(this.x, this.y, 120, 60);
                        if (PracticeModeManager.active) PracticeModeManager.applyDamageToDummies(this.x, this.y, 120, 60);
                    }
                    return; // Intercepted COMPLETELY!
                }

                // Counter attack if active
                if (this.counterActive && attackerId && MobRaidSystem.active) {
                    this.counterActive = false;
                    MobRaidSystem.damageMob(attackerId, damage * 2);
                    console.log('⚡ Counter! Reflected', damage * 2, 'damage!');
                    return;
                }

                // Apply Curse effect (double damage)
                if (this.cursed && Date.now() < this.curseEndTime) {
                    damage *= 2;
                    console.log('💀 ¡MALDICIÓN! Daño duplicado:', damage);
                } else if (this.cursed && Date.now() >= this.curseEndTime) {
                    // Remove curse if expired
                    this.cursed = false;
                    this.curseStacks = 0;
                    console.log('💀 Maldición expirada');
                }

                this.hp = Math.max(0, this.hp - damage);
                this.invulnerable = true;
                this.invulnerableTime = 1000; // 1 second invulnerability

                // Reset regeneration timer
                this.lastDamageTime = Date.now();
                this.regenActive = false;

                console.log('💥 Player took', damage, 'damage! HP:', this.hp);

                if (this.hp <= 0) {
                    // Check for Anubis Resurrection
                    if (this.resurrectionAvailable) {
                        this.resurrectionAvailable = false;
                        this.hp = Math.floor(this.maxHp * 0.4);
                        this.invulnerable = true;
                        this.invulnerableTime = 2000;
                        console.log('☥ RESURRECTED by the Ankh of Life!');
                        EffectRenderer.playEffect('anubis_ankh', this.x, this.y);
                        return;
                    }

                    console.log('💀 Player died!');

                    // Reset Abyssal Shadowlord passive stacks on death
                    if (this.shadowEssenceStacks) {
                        this.shadowEssenceStacks = 0;
                        this.critBoost = 0;
                        console.log('🌑 Abismo Letal stacks reset on death');
                    }

                    MobRaidSystem.stopRaid(true); // Pass true to indicate player died
                }
            },

            update(deltaTime) {
                if (this.invulnerable) {
                    this.invulnerableTime -= deltaTime;
                    if (this.invulnerableTime <= 0) {
                        this.invulnerable = false;
                    }
                }

                // NEW: Invisibility system
                if (this.invisible) {
                    this.invisibleTime -= deltaTime;
                    if (this.invisibleTime <= 0) {
                        this.invisible = false;
                        // Restore normal speed
                        this.speed = this.baseSpeed;
                        console.log('?? Invisibility ended! Speed restored.');
                    }
                }

                // NEW: Heat System decay (Cybernetic Warlord)
                if (this.heat > 0 && !this.overheated) {
                    this.heat = Math.max(0, this.heat - (this.heatDecayRate * deltaTime / 1000));
                }

                // Silenced timer
                if (this.silenced) {
                    this.silencedTime -= deltaTime;
                    if (this.silencedTime <= 0) {
                        this.silenced = false;
                    }
                }

                // Poison status (used by Taurha and other poison sources).
                if (this.poisoned) {
                    if (Date.now() >= (this.poisonEndTime || 0)) {
                        this.poisoned = false;
                        this.poisonDamage = 0;
                        this.poisonTickInterval = 0;
                    } else if (!this.poisonLastTick || Date.now() - this.poisonLastTick >= (this.poisonTickInterval || 500)) {
                        this.poisonLastTick = Date.now();
                        const poisonTickDamage = Math.max(1, Math.floor(this.poisonDamage || 1));
                        this.hp = Math.max(0, this.hp - poisonTickDamage);
                        this.lastDamageTime = Date.now();

                        if (this.hp <= 0) {
                            console.log('💀 Player died by poison!');

                            if (this.shadowEssenceStacks) {
                                this.shadowEssenceStacks = 0;
                                this.critBoost = 0;
                            }

                            MobRaidSystem.stopRaid(true);
                        }
                    }
                }

                if (this.damageBoost > 0) {
                    this.damageBoostTime -= deltaTime;
                    if (this.damageBoostTime <= 0) {
                        this.damageBoost = 0;
                    }
                }

                if (this.counterActive) {
                    this.counterTime -= deltaTime;
                    if (this.counterTime <= 0) {
                        this.counterActive = false;
                        console.log('??? Counter stance expired');
                    }
                }

                // NEW v19.11.2025: Passive Regeneration System
                const timeSinceLastDamage = Date.now() - this.lastDamageTime;
                if (this.hp < this.maxHp && timeSinceLastDamage >= this.regenDelay) {
                    if (!this.regenActive) {
                        this.regenActive = true;
                        console.log('?? Passive regeneration activated!');
                    }

                    const regenAmount = (this.regenRate * deltaTime) / 1000;
                    this.hp = Math.min(this.maxHp, this.hp + regenAmount);
                }

                // NEW v19.11.2025: Electrified Status (stun effect)
                if (this.electrified) {
                    this.electrifiedTime -= deltaTime;
                    if (this.electrifiedTime <= 0) {
                        this.electrified = false;
                        console.log('? Electrified effect ended - movement restored!');
                    }
                }

                // NEW v19.11.2025: Fix permanent speed reduction bug
                // Reset speed to base if no active slow effects
                if (this.speed < this.baseSpeed && !this.hasActiveSlowEffect && !this.electrified) {
                    this.speed = this.baseSpeed;
                }
            },

            applyDamageBoost(percentage, duration) {
                this.damageBoost = percentage;
                this.damageBoostTime = duration;
                console.log(`?? Damage boost: +${percentage}% for ${duration / 1000}s`);
            }
        };

        // ===== INPUT HANDLER =====
        const InputHandler = {
            keysPressed: new Set(),

            handleKeyDown(event) {
                this.keysPressed.add(event.key.toLowerCase());
            },

            handleKeyUp(event) {
                this.keysPressed.delete(event.key.toLowerCase());
            },

            processMovement(deltaTime) {
                // Prevent movement when game is paused
                if (MobRaidSystem.paused) {
                    return; // Cannot move while paused
                }

                // NEW v19.11.2025: Cannot move while electrified (stunned)
                if (Player.electrified) {
                    return; // Stunned, no movement allowed
                }

                let dx = 0, dy = 0;

                if (this.keysPressed.has('w') || this.keysPressed.has('arrowup')) dy -= 1;
                if (this.keysPressed.has('s') || this.keysPressed.has('arrowdown')) dy += 1;
                if (this.keysPressed.has('a') || this.keysPressed.has('arrowleft')) dx -= 1;
                if (this.keysPressed.has('d') || this.keysPressed.has('arrowright')) dx += 1;

                if (dx !== 0 && dy !== 0) {
                    const length = Math.sqrt(dx * dx + dy * dy);
                    dx /= length;
                    dy /= length;
                }

                if (dx !== 0 || dy !== 0) {
                    // Apply class speed multiplier
                    let speed = Player.speed;
                    if (EquipmentManager.equippedRole && EquipmentManager.equippedRole.type === 'class') {
                        const classId = EquipmentManager.equippedRole.id;
                        const speedMultiplier = ClassProgressionSystem.getSpeedMultiplier(classId);
                        speed *= speedMultiplier;
                    }

                    Player.move(dx * speed * deltaTime, dy * speed * deltaTime);
                }
            },

            processAbilityInputs() {
                const abilities = EquipmentManager.getAllAbilities();
                const abilityKeys = ['q', 'w', 'e', 't', 'a', 's', 'r', 'f', 'd'];

                abilityKeys.forEach(key => {
                    if (this.keysPressed.has(key)) {
                        const ability = abilities.find(a => a.keyBinding === key);
                        if (ability) {
                            AbilityManager.activateAbility(ability.id);
                            this.keysPressed.delete(key);
                        }
                    }
                });
            }
        };

        window.addEventListener('keydown', (e) => {
            InputHandler.handleKeyDown(e);

            // Z key to pause/unpause raid
            if (e.key.toLowerCase() === 'z' && MobRaidSystem.active) {
                MobRaidSystem.paused = !MobRaidSystem.paused;
                console.log(MobRaidSystem.paused ? '?? PAUSED' : '?? RESUMED');
            }

            // M key to toggle mission tracker
            if (e.key.toLowerCase() === 'm') {
                LoadoutManager.toggleMissionTracker();
            }

            // P key to toggle practice mode control panel
            if (e.key.toLowerCase() === 'p' && PracticeModeManager.active) {
                PracticeModeManager.controlPanel.collapsed = !PracticeModeManager.controlPanel.collapsed;
                console.log(PracticeModeManager.controlPanel.collapsed ? '?? Panel colapsado' : '?? Panel expandido');
            }
        });
        window.addEventListener('keyup', (e) => InputHandler.handleKeyUp(e));

        // ===== EFFECT RENDERER =====
        const EffectRenderer = {
            activeEffects: [],
            effectDefinitions: {
                // Character effects
                effect_claw: { type: 'particle', duration: 600, color: '#ff6b6b', size: 28, count: 18 },
                effect_roar: { type: 'particle', duration: 800, color: '#ffd700', size: 35, count: 30 },
                effect_apex: { type: 'particle', duration: 2000, color: '#ff0000', size: 65, count: 55 },
                effect_star_beam: { type: 'particle', duration: 700, color: '#00d9ff', size: 25, count: 20 },
                effect_cosmic_shield: { type: 'particle', duration: 1200, color: '#9b59b6', size: 40, count: 35 },
                effect_supernova: { type: 'particle', duration: 2200, color: '#ffbe0b', size: 70, count: 70 },
                effect_shadow_slash: { type: 'particle', duration: 650, color: '#4a4a4a', size: 30, count: 22 },
                effect_dash: { type: 'particle', duration: 500, color: '#00bfff', size: 25, count: 18 },
                effect_blade_storm: { type: 'particle', duration: 1800, color: '#c0c0c0', size: 50, count: 60 },
                effect_flame_wing: { type: 'particle', duration: 750, color: '#ff4500', size: 32, count: 25 },
                effect_rebirth: { type: 'particle', duration: 1500, color: '#00ff88', size: 35, count: 40 },
                effect_phoenix_rise: { type: 'particle', duration: 2500, color: '#ff6600', size: 75, count: 80 },
                effect_smash: { type: 'particle', duration: 800, color: '#8b4513', size: 40, count: 30 },
                effect_wall: { type: 'particle', duration: 1000, color: '#808080', size: 45, count: 35 },
                effect_titan_wrath: { type: 'particle', duration: 2400, color: '#ffd700', size: 70, count: 65 },

                // Class effects
                effect_shuriken: { type: 'particle', duration: 500, color: '#c0c0c0', size: 18, count: 15 },
                effect_smoke: { type: 'particle', duration: 1000, color: '#696969', size: 40, count: 35 },
                effect_clone: { type: 'particle', duration: 1500, color: '#4169e1', size: 50, count: 40 },
                effect_iaido: { type: 'particle', duration: 600, color: '#ff1493', size: 30, count: 20 },
                effect_parry: { type: 'particle', duration: 800, color: '#ffd700', size: 35, count: 25 },
                effect_ninja_power: { type: 'particle', duration: 1200, color: '#93c5fd', size: 40, count: 36 },
                effect_surprise_cut: { type: 'particle', duration: 900, color: '#a5f3fc', size: 30, count: 26 },
                effect_thousand: { type: 'particle', duration: 1800, color: '#ffb6c1', size: 45, count: 65 },
                effect_elem_bolt: { type: 'particle', duration: 700, color: '#00bfff', size: 25, count: 18 },
                effect_barrier: { type: 'particle', duration: 1200, color: '#9370db', size: 40, count: 35 },
                effect_fury: { type: 'particle', duration: 2000, color: '#ff6347', size: 60, count: 55 },
                effect_rage: { type: 'particle', duration: 700, color: '#dc143c', size: 32, count: 22 },
                effect_leap: { type: 'particle', duration: 800, color: '#ff8c00', size: 35, count: 28 },
                effect_frenzy: { type: 'particle', duration: 1700, color: '#8b0000', size: 55, count: 60 },
                effect_orb: { type: 'particle', duration: 650, color: '#4169e1', size: 25, count: 18 },
                effect_heal_aura: { type: 'particle', duration: 1500, color: '#32cd32', size: 38, count: 40 },
                effect_arcane_storm: { type: 'particle', duration: 1900, color: '#9400d3', size: 60, count: 65 },
                effect_rapid: { type: 'particle', duration: 550, color: '#ff4500', size: 20, count: 25 },
                effect_grenade: { type: 'particle', duration: 900, color: '#ff6347', size: 35, count: 30 },
                effect_orbital: { type: 'particle', duration: 1600, color: '#00ced1', size: 65, count: 70 },

                // Living Ruins Effects - Ancient Tech/Earth Theme
                guardian_glyph: { type: 'custom_glyph', duration: 1500, color: '#FFD700', size: 200, count: 40 },
                guardian_hurl: { type: 'custom_hurl', duration: 1500, color: '#8B4513', size: 60, count: 20 },
                guardian_tablets: { type: 'custom_tablets', duration: 10000, color: '#F4A460', size: 80, count: 3 },
                guardian_burrow: { type: 'custom_burrow', duration: 3000, color: '#8B4513', size: 50, count: 50 },
                guardian_construct: { type: 'custom_construct', duration: 15000, color: '#556B2F', size: 90, count: 10 },
                guardian_worldbreaker: { type: 'custom_worldbreaker', duration: 8000, color: '#FF4500', size: 2000, count: 100 },
                guardian_shatter: { type: 'particle', duration: 1000, color: '#8b4513', size: 60, count: 50 },

                // Anubis effects - Custom Egyptian themed implementations
                anubis_judgment: { type: 'custom_judgment', duration: 2400, color: '#FFD700', size: 40, count: 60 },
                anubis_sandstorm: { type: 'custom_sandstorm', duration: 7000, color: '#DEB887', size: 50, count: 80 },
                anubis_jackal: { type: 'custom_jackal', duration: 3200, color: '#FFD700', size: 45, count: 70 },
                anubis_ankh: { type: 'custom_ankh', duration: 10000, color: '#00CED1', size: 55, count: 75 },
                anubis_plague: { type: 'custom_plague', duration: 9000, color: '#228B22', size: 70, count: 100 },
                anubis_underworld: { type: 'custom_underworld', duration: 12000, color: '#000000', size: 90, count: 150 },

                // Fruit effects
                effect_fire_blast: { type: 'particle', duration: 700, color: '#ff4500', size: 30, count: 22 },
                effect_flame_wall: { type: 'particle', duration: 1000, color: '#ff6600', size: 42, count: 38 },
                effect_inferno_nova: { type: 'particle', duration: 1500, color: '#ff0000', size: 65, count: 60 },
                effect_ice_shard: { type: 'particle', duration: 600, color: '#00ffff', size: 22, count: 20 },
                effect_freeze: { type: 'particle', duration: 1100, color: '#87ceeb', size: 38, count: 35 },
                effect_winter: { type: 'particle', duration: 1800, color: '#b0e0e6', size: 60, count: 65 },
                effect_lightning: { type: 'particle', duration: 500, color: '#ffff00', size: 28, count: 18 },
                effect_thunder_field: { type: 'particle', duration: 1000, color: '#ffd700', size: 42, count: 45 },
                effect_tempest: { type: 'particle', duration: 1600, color: '#ffff00', size: 65, count: 70 },
                effect_void_hole: { type: 'particle', duration: 800, color: '#000000', size: 38, count: 30 },
                effect_gravity: { type: 'particle', duration: 900, color: '#4b0082', size: 35, count: 35 },
                effect_singularity: { type: 'particle', duration: 1700, color: '#000000', size: 60, count: 60 },
                effect_light_beam: { type: 'particle', duration: 500, color: '#ffffff', size: 25, count: 20 },
                effect_light_speed: { type: 'particle', duration: 1200, color: '#ffffe0', size: 42, count: 40 },
                effect_solar: { type: 'particle', duration: 1400, color: '#fffacd', size: 55, count: 50 },
                effect_vine: { type: 'particle', duration: 700, color: '#228b22', size: 28, count: 22 },
                effect_growth: { type: 'particle', duration: 1100, color: '#32cd32', size: 40, count: 38 },
                effect_forest: { type: 'particle', duration: 1900, color: '#006400', size: 60, count: 65 }
            },

            playEffect(effectId, x, y) {
                const effectDef = this.effectDefinitions[effectId];
                if (!effectDef) return;

                const effect = {
                    id: effectId,
                    x: x,
                    y: y,
                    startTime: Date.now(),
                    duration: effectDef.duration,
                    type: effectDef.type,
                    color: effectDef.color,
                    size: effectDef.size,
                    particles: [],
                    customData: {}
                };

                if (effectDef.type === 'particle') {
                    for (let i = 0; i < effectDef.count; i++) {
                        const angle = (Math.PI * 2 * i) / effectDef.count;
                        const speed = 90 + Math.random() * 140;
                        effect.particles.push({
                            x: x,
                            y: y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            size: effectDef.size * (0.6 + Math.random() * 0.4),
                            life: 1.0
                        });
                    }
                }
                // Custom Living Ruins Effects
                else if (effectDef.type === 'custom_glyph') {
                    // Geometric pattern for glyph
                    effect.customData.lines = [];
                    effect.customData.runes = [];
                    // Generate a hexagram or complex shape
                    for (let i = 0; i < 6; i++) {
                        const a1 = (Math.PI * 2 / 6) * i;
                        const a2 = (Math.PI * 2 / 6) * ((i + 2) % 6);
                        effect.customData.lines.push({ a1, a2, progress: 0 });
                    }
                }
                else if (effectDef.type === 'custom_hurl') {
                    // Target coordinates for projectile arc
                    effect.customData.targetX = x + (Math.random() - 0.5) * 400; // Default if not provided
                    effect.customData.targetY = y + (Math.random() - 0.5) * 400;
                    effect.customData.height = 0;
                    effect.customData.rotation = 0;
                }
                else if (effectDef.type === 'custom_tablets') {
                    effect.customData.angle = 0;
                    effect.customData.tablets = [true, true, true]; // 3 active tablets
                }
                else if (effectDef.type === 'custom_burrow') {
                    effect.customData.trail = [];
                }
                else if (effectDef.type === 'custom_construct') {
                    effect.customData.pulse = 0;
                }
                else if (effectDef.type === 'custom_worldbreaker') {
                    effect.customData.cracks = []; // Main fissures
                    effect.customData.ruins = []; // Falling ruins
                    effect.customData.magma = []; // Magma pools
                    // Generate initial cracks
                    for (let i = 0; i < 8; i++) {
                        effect.customData.cracks.push({
                            x: Math.random() * window.innerWidth,
                            y: Math.random() * window.innerHeight,
                            angle: Math.random() * Math.PI * 2,
                            length: 0,
                            maxLength: 200 + Math.random() * 300,
                            width: 0
                        });
                    }
                }

                // Custom Anubis effects
                else if (effectDef.type === 'custom_judgment') {
                    // 3 proyectiles de energía dorada que persiguen
                    effect.customData.projectiles = [];
                    for (let i = 0; i < 3; i++) {
                        const angle = (Math.PI * 2 / 3) * i;
                        effect.customData.projectiles.push({
                            x: x,
                            y: y,
                            angle: angle,
                            speed: 200,
                            size: 25,
                            trail: []
                        });
                    }
                    // Balanza sagrada en el centro
                    effect.customData.scale = {
                        rotation: 0,
                        size: 60,
                        glow: 0
                    };
                }
                else if (effectDef.type === 'custom_sandstorm') {
                    // Tormenta de arena circular
                    effect.customData.sandParticles = [];
                    for (let i = 0; i < 100; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 300;
                        effect.customData.sandParticles.push({
                            angle: angle,
                            distance: distance,
                            speed: 0.05 + Math.random() * 0.05,
                            size: 3 + Math.random() * 5,
                            alpha: 0.3 + Math.random() * 0.4
                        });
                    }
                    effect.customData.radius = 0;
                    effect.customData.maxRadius = 300;
                }
                else if (effectDef.type === 'custom_jackal') {
                    // Transformación en chacal dorado
                    effect.customData.aura = {
                        radius: 0,
                        maxRadius: 100,
                        pulsePhase: 0
                    };
                    // Rastro de fuego dorado
                    effect.customData.fireTrail = [];
                    for (let i = 0; i < 20; i++) {
                        effect.customData.fireTrail.push({
                            x: x,
                            y: y,
                            life: 1,
                            size: 15 + Math.random() * 10
                        });
                    }
                    // Silueta de chacal
                    effect.customData.jackalForm = {
                        scale: 0,
                        alpha: 0,
                        rotation: 0
                    };
                }
                else if (effectDef.type === 'custom_ankh') {
                    // Símbolo Ankh sagrado
                    effect.customData.ankhSymbol = {
                        scale: 0,
                        rotation: 0,
                        glow: 0
                    };
                    // Círculo de curación
                    effect.customData.healingCircle = {
                        radius: 0,
                        maxRadius: 200,
                        pulsePhase: 0
                    };
                    // Rayos de luz curativos
                    effect.customData.lightRays = [];
                    for (let i = 0; i < 12; i++) {
                        effect.customData.lightRays.push({
                            angle: (Math.PI * 2 / 12) * i,
                            length: 0,
                            maxLength: 150,
                            width: 8
                        });
                    }
                }
                else if (effectDef.type === 'custom_plague') {
                    // 5 plagas consecutivas
                    effect.customData.plagues = [
                        { type: 'blood', active: false, delay: 0, particles: [] },
                        { type: 'locusts', active: false, delay: 2000, particles: [] },
                        { type: 'darkness', active: false, delay: 4000, particles: [] },
                        { type: 'hail', active: false, delay: 6000, particles: [] },
                        { type: 'death', active: false, delay: 8000, particles: [] }
                    ];
                    // Aura verde-dorada
                    effect.customData.auraRings = [];
                    for (let i = 0; i < 5; i++) {
                        effect.customData.auraRings.push({
                            radius: 50 + i * 30,
                            alpha: 0,
                            rotation: 0
                        });
                    }
                }
                else if (effectDef.type === 'custom_underworld') {
                    // Portal masivo del Duat
                    effect.customData.portal = {
                        radius: 0,
                        maxRadius: 600,
                        rotation: 0
                    };
                    // Jeroglíficos giratorios
                    effect.customData.hieroglyphs = [];
                    for (let i = 0; i < 24; i++) {
                        effect.customData.hieroglyphs.push({
                            angle: (Math.PI * 2 / 24) * i,
                            distance: 550,
                            symbol: ['☥', '𓂀', '𓁹', '𓆣'][Math.floor(Math.random() * 4)],
                            size: 30,
                            glow: Math.random()
                        });
                    }
                    // Guerreros momificados
                    effect.customData.warriors = [];
                    for (let i = 0; i < 12; i++) {
                        const angle = (Math.PI * 2 / 12) * i;
                        effect.customData.warriors.push({
                            angle: angle,
                            distance: 400,
                            height: 0,
                            maxHeight: 80,
                            delay: i * 100
                        });
                    }
                    // Columnas de fuego espectral
                    effect.customData.fireColumns = [];
                    for (let i = 0; i < 8; i++) {
                        effect.customData.fireColumns.push({
                            x: x + (Math.random() - 0.5) * 500,
                            y: y + (Math.random() - 0.5) * 500,
                            height: 0,
                            maxHeight: 200,
                            delay: i * 300,
                            active: false
                        });
                    }
                    // Forma espectral de Anubis
                    effect.customData.anubisForm = {
                        scale: 0,
                        alpha: 0,
                        yOffset: 0
                    };
                }

                this.activeEffects.push(effect);

                // Update effects count if element exists
                const effectsCount = document.getElementById('effects-count');
                if (effectsCount) {
                    effectsCount.textContent = this.activeEffects.length;
                }

                return effect;
            },

            updateEffects(deltaTime) {
                const now = Date.now();

                this.activeEffects = this.activeEffects.filter(effect => {
                    const elapsed = now - effect.startTime;
                    if (elapsed >= effect.duration) return false;

                    const progress = elapsed / effect.duration;
                    effect.particles.forEach(particle => {
                        particle.x += particle.vx * (deltaTime / 1000);
                        particle.y += particle.vy * (deltaTime / 1000);
                        particle.life = 1.0 - progress;
                        particle.size *= 0.96;
                    });

                    return true;
                });

                // Update effects count if element exists
                const effectsCount = document.getElementById('effects-count');
                if (effectsCount) {
                    effectsCount.textContent = this.activeEffects.length;
                }
            },

            renderEffects(ctx) {
                this.activeEffects.forEach(effect => {
                    const elapsed = Date.now() - effect.startTime;
                    const progress = Math.min(elapsed / effect.duration, 1);

                    // Render custom Guardian Ancestral effects
                    // Render Living Ruins Effects
                    if (effect.type === 'custom_glyph') {
                        this.renderGlyphEffect(ctx, effect, progress);
                    }
                    else if (effect.type === 'custom_hurl') {
                        this.renderHurlEffect(ctx, effect, progress);
                    }
                    else if (effect.type === 'custom_tablets') {
                        this.renderTabletsEffect(ctx, effect, progress);
                    }
                    else if (effect.type === 'custom_burrow') {
                        this.renderBurrowEffect(ctx, effect, progress);
                    }
                    else if (effect.type === 'custom_construct') {
                        this.renderConstructEffect(ctx, effect, progress);
                    }
                    else if (effect.type === 'custom_worldbreaker') {
                        this.renderWorldbreakerEffect(ctx, effect, progress);
                    }
                    // Render Anubis effects
                    else if (effect.type === 'custom_judgment') {
                        this.renderJudgmentEffect(ctx, effect, progress);
                    }
                    else if (effect.type === 'custom_sandstorm') {
                        this.renderSandstormEffect(ctx, effect, progress);
                    }
                    else if (effect.type === 'custom_jackal') {
                        this.renderJackalEffect(ctx, effect, progress);
                    }
                    else if (effect.type === 'custom_ankh') {
                        this.renderAnkhEffect(ctx, effect, progress);
                    }
                    else if (effect.type === 'custom_plague') {
                        this.renderPlagueEffect(ctx, effect, progress);
                    }
                    else if (effect.type === 'custom_underworld') {
                        this.renderUnderworldEffect(ctx, effect, progress);
                    }
                    // Render standard particle effects
                    else {
                        effect.particles.forEach(particle => {
                            ctx.save();
                            ctx.globalAlpha = particle.life * 0.85;

                            const gradient = ctx.createRadialGradient(
                                particle.x, particle.y, 0,
                                particle.x, particle.y, particle.size
                            );
                            gradient.addColorStop(0, effect.color);
                            gradient.addColorStop(1, 'transparent');

                            ctx.fillStyle = gradient;
                            ctx.shadowColor = effect.color;
                            ctx.shadowBlur = 15;
                            ctx.beginPath();
                            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        });
                    }
                });
            },

            renderGlyphEffect(ctx, effect, progress) {
                ctx.save();
                const alpha = Math.max(0, 1 - progress);
                ctx.translate(effect.x, effect.y);

                // Rotation increases with progress
                ctx.rotate(progress * Math.PI);

                // Draw Hexagram/Rune Pattern
                ctx.strokeStyle = `rgba(255, 215, 0, ${alpha})`;
                ctx.lineWidth = 4;
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 30 * alpha;

                ctx.beginPath();
                effect.customData.lines.forEach(line => {
                    const r = 180 * (0.5 + 0.5 * Math.sin(progress * Math.PI * 3));
                    const x1 = Math.cos(line.a1) * r;
                    const y1 = Math.sin(line.a1) * r;
                    const x2 = Math.cos(line.a2) * r;
                    const y2 = Math.sin(line.a2) * r;
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                });
                ctx.stroke();

                // Draw Outer Ring
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.arc(0, 0, 200 * progress + 20, 0, Math.PI * 2);
                ctx.stroke();

                // Pulsing inner circle
                ctx.beginPath();
                ctx.arc(0, 0, 150 * (1 - progress), 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            },

            renderHurlEffect(ctx, effect, progress) {
                ctx.save();
                const p = progress;
                const invP = 1 - p;

                // Parabolic arc for projectile
                // Start: effect.x, effect.y
                // End: customData.targetX, customData.targetY
                // Height peak at p=0.5

                const currentX = effect.x + (effect.customData.targetX - effect.x) * p;
                const currentY = effect.y + (effect.customData.targetY - effect.y) * p;
                const height = Math.sin(p * Math.PI) * 200; // Arc height

                const drawY = currentY - height;

                ctx.translate(currentX, drawY);
                ctx.rotate(p * Math.PI * 4); // Spin

                // Draw Rock/Pillar Chunk
                ctx.fillStyle = '#8B4513';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 10;

                // Jagged rock shape
                ctx.beginPath();
                ctx.moveTo(-20, -30);
                ctx.lineTo(20, -20);
                ctx.lineTo(30, 20);
                ctx.lineTo(0, 35);
                ctx.lineTo(-25, 25);
                ctx.closePath();
                ctx.fill();

                // Highlight/Relief
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Shadow on ground
                ctx.restore();
                ctx.save();
                ctx.translate(currentX, currentY);
                ctx.scale(1 + p, 0.5 + p * 0.5);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            },

            renderTabletsEffect(ctx, effect, progress) {
                ctx.save();
                const totalTablets = 3;

                // Orbiting tablets
                // Based on duration, they spin. 
                const angleBase = (Date.now() / 1000) * 2; // Speed of orbit

                effect.customData.tablets.forEach((active, i) => {
                    if (!active) return;

                    const angle = angleBase + (Math.PI * 2 / totalTablets) * i;
                    const r = 80;

                    const x = effect.x + Math.cos(angle) * r;
                    const y = effect.y + Math.sin(angle) * r;

                    ctx.translate(x, y);
                    // Tablet shape
                    ctx.fillStyle = '#F4A460';
                    ctx.shadowColor = '#DAA520';
                    ctx.shadowBlur = 8;

                    ctx.beginPath();
                    ctx.rect(-10, -15, 20, 30);
                    ctx.fill();

                    // Hieroglyph
                    ctx.fillStyle = '#8B0000';
                    ctx.font = '12px Arial';
                    ctx.fillText('?', -5, 5);

                    ctx.translate(-x, -y);
                });

                ctx.restore();
            },

            renderBurrowEffect(ctx, effect, progress) {
                ctx.save();
                ctx.translate(effect.x, effect.y);

                // Mounding earth effect
                const size = 30 + Math.sin(progress * Math.PI * 10) * 5;

                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                gradient.addColorStop(0, '#8B4513');
                gradient.addColorStop(1, 'transparent');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.fill();

                // Particles flying out
                for (let i = 0; i < 5; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const dist = Math.random() * size;
                    const rx = Math.cos(ang) * dist;
                    const ry = Math.sin(ang) * dist;
                    ctx.fillStyle = '#CD853F';
                    ctx.fillRect(rx, ry, 4, 4);
                }

                ctx.restore();
            },

            renderConstructEffect(ctx, effect, progress) {
                // Aura effect for Construct Form
                ctx.save();
                ctx.translate(effect.x, effect.y);

                const alpha = 0.4 + Math.sin(Date.now() / 200) * 0.2;

                // Large Mech Aura
                ctx.strokeStyle = `rgba(85, 107, 47, ${alpha})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, 50, 0, Math.PI * 2);
                ctx.stroke();

                // Techno-magical circles
                ctx.rotate(Date.now() / 1000);
                ctx.strokeStyle = `rgba(218, 165, 32, ${alpha})`;
                ctx.setLineDash([10, 15]);
                ctx.beginPath();
                ctx.arc(0, 0, 60, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            },

            renderWorldbreakerEffect(ctx, effect, progress) {
                ctx.save();
                const p = progress;

                // Screen shake simulation (offset everything slightly?) 
                // Hard to do strictly in effect renderer without global camera access, 
                // but we can draw the shakey elements.

                // Draw cracks
                effect.customData.cracks.forEach(crack => {
                    // Cracks grow
                    const currentLen = crack.maxLength * Math.min(1, p * 3); // Grow fast

                    const ex = crack.x + Math.cos(crack.angle) * currentLen;
                    const ey = crack.y + Math.sin(crack.angle) * currentLen;

                    // Magma Glow
                    ctx.shadowColor = '#FF4500';
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = '#8B0000';
                    ctx.lineWidth = 3 + Math.sin(Date.now() / 100) * 2; // Pulsing width

                    ctx.beginPath();
                    ctx.moveTo(crack.x, crack.y);

                    // Jagged line
                    let cx = crack.x;
                    let cy = crack.y;
                    const segments = 5;
                    for (let i = 1; i <= segments; i++) {
                        const t = i / segments;
                        const tx = crack.x + (ex - crack.x) * t;
                        const ty = crack.y + (ey - crack.y) * t;
                        // Add noise
                        const nx = tx + (Math.random() - 0.5) * 20;
                        const ny = ty + (Math.random() - 0.5) * 20;
                        ctx.lineTo(nx, ny);
                    }

                    ctx.stroke();
                });

                ctx.restore();
            },


            // ===== ANUBIS EFFECT RENDERERS =====
            renderJudgmentEffect(ctx, effect, progress) {
                ctx.save();
                const t = Date.now() * 0.001;
                const alpha = Math.max(0, 1 - progress);
                effect.customData.scale.rotation += 0.022;
                effect.customData.scale.glow = Math.sin(t * 4) * 0.5 + 0.5;

                // Tribunal ring
                ctx.globalAlpha = 0.52 * alpha;
                ctx.strokeStyle = '#e8bf6c';
                ctx.lineWidth = 5;
                ctx.shadowColor = '#e8bf6c';
                ctx.shadowBlur = 24;
                ctx.setLineDash([16, 12]);
                ctx.lineDashOffset = -t * 60;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, 110 + Math.sin(t * 3) * 10, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Sacred scale glyph
                ctx.save();
                ctx.translate(effect.x, effect.y);
                ctx.rotate(effect.customData.scale.rotation);
                ctx.globalAlpha = 0.92 * alpha;
                ctx.strokeStyle = '#ffd166';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(0, -42);
                ctx.lineTo(0, 36);
                ctx.moveTo(-36, -16);
                ctx.lineTo(36, -16);
                ctx.moveTo(-26, -16);
                ctx.lineTo(-16, 8);
                ctx.moveTo(26, -16);
                ctx.lineTo(16, 8);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(-16, 12, 12, 0, Math.PI * 2);
                ctx.arc(16, 12, 12, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();

                // Soul orbs
                effect.customData.projectiles.forEach((proj, index) => {
                    const radius = 72 + index * 16;
                    proj.angle += 0.075 + index * 0.01;
                    proj.x = effect.x + Math.cos(proj.angle) * radius;
                    proj.y = effect.y + Math.sin(proj.angle) * radius;

                    proj.trail.push({ x: proj.x, y: proj.y, life: 1 });
                    if (proj.trail.length > 14) proj.trail.shift();

                    proj.trail.forEach((trail, i) => {
                        trail.life -= 0.08;
                        if (trail.life <= 0) return;
                        ctx.globalAlpha = trail.life * 0.45 * alpha;
                        ctx.fillStyle = '#ffdfa0';
                        ctx.beginPath();
                        ctx.arc(trail.x, trail.y, Math.max(2, (i / proj.trail.length) * 10), 0, Math.PI * 2);
                        ctx.fill();
                    });

                    ctx.globalAlpha = 0.95 * alpha;
                    ctx.fillStyle = '#ffd166';
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 10 + Math.sin(t * 5 + index) * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.globalAlpha = 0.3 * alpha;
                    ctx.strokeStyle = '#ffd166';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(effect.x, effect.y);
                    ctx.lineTo(proj.x, proj.y);
                    ctx.stroke();
                });
                ctx.restore();
            },

            renderSandstormEffect(ctx, effect, progress) {
                ctx.save();
                const alpha = Math.max(0, 1 - progress);
                const time = Date.now() * 0.001;
                effect.customData.radius = Math.min(effect.customData.radius + 7, effect.customData.maxRadius);

                // Dust cyclone
                effect.customData.sandParticles.forEach((particle, idx) => {
                    const spinBoost = 1 + (idx % 5) * 0.03;
                    particle.angle += particle.speed * spinBoost;
                    particle.distance = Math.min(effect.customData.radius, particle.distance + 0.2);
                    const px = effect.x + Math.cos(particle.angle) * particle.distance;
                    const py = effect.y + Math.sin(particle.angle) * particle.distance;

                    ctx.globalAlpha = particle.alpha * alpha * 0.8;
                    ctx.fillStyle = idx % 3 === 0 ? '#f4d7a2' : '#c79f5d';
                    ctx.shadowColor = '#d8b678';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(px, py, Math.max(2, particle.size * 0.7), 0, Math.PI * 2);
                    ctx.fill();
                });

                // Ring + inner mirage
                ctx.globalAlpha = 0.34 * alpha;
                ctx.strokeStyle = '#f0c987';
                ctx.lineWidth = 16;
                ctx.shadowColor = '#f0c987';
                ctx.shadowBlur = 24;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, effect.customData.radius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.globalAlpha = 0.18 * alpha;
                ctx.fillStyle = '#d9ae6b';
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, effect.customData.radius * (0.7 + Math.sin(time * 2.5) * 0.04), 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            },

            renderJackalEffect(ctx, effect, progress) {
                ctx.save();
                const alpha = Math.max(0, 1 - progress);
                effect.customData.aura.pulsePhase += 0.14;
                effect.customData.aura.radius = Math.min(effect.customData.aura.radius + 4.2, effect.customData.aura.maxRadius);
                const pulse = Math.sin(effect.customData.aura.pulsePhase) * 0.35 + 0.65;

                // Cyan-gold transformation ring
                ctx.globalAlpha = 0.52 * pulse * alpha;
                ctx.strokeStyle = '#ffd166';
                ctx.lineWidth = 6;
                ctx.shadowColor = '#00d9ff';
                ctx.shadowBlur = 22;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, effect.customData.aura.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Afterimage trail
                effect.customData.fireTrail.forEach((fire, i) => {
                    fire.life -= 0.06;
                    if (fire.life <= 0) return;
                    ctx.globalAlpha = fire.life * 0.55 * alpha;
                    ctx.fillStyle = i % 2 === 0 ? '#ffd166' : '#00d9ff';
                    ctx.shadowColor = '#ffd166';
                    ctx.shadowBlur = 14;
                    ctx.beginPath();
                    ctx.arc(fire.x, fire.y, Math.max(4, fire.size * 0.55), 0, Math.PI * 2);
                    ctx.fill();
                });

                // Stylized jackal silhouette
                effect.customData.jackalForm.scale = Math.min(effect.customData.jackalForm.scale + 0.045, 1.45);
                effect.customData.jackalForm.alpha = Math.min(effect.customData.jackalForm.alpha + 0.028, 0.85);
                effect.customData.jackalForm.rotation += 0.016;

                ctx.globalAlpha = effect.customData.jackalForm.alpha * alpha;
                ctx.save();
                ctx.translate(effect.x, effect.y);
                ctx.scale(effect.customData.jackalForm.scale, effect.customData.jackalForm.scale);
                ctx.rotate(effect.customData.jackalForm.rotation);
                ctx.fillStyle = '#1f1730';
                ctx.beginPath();
                ctx.moveTo(0, -42);
                ctx.lineTo(26, -8);
                ctx.lineTo(18, 34);
                ctx.lineTo(-18, 34);
                ctx.lineTo(-26, -8);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#ffd166';
                ctx.beginPath();
                ctx.moveTo(-16, -8);
                ctx.lineTo(-28, -34);
                ctx.lineTo(-7, -14);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(16, -8);
                ctx.lineTo(28, -34);
                ctx.lineTo(7, -14);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#00d9ff';
                ctx.beginPath();
                ctx.arc(-8, 6, 3.5, 0, Math.PI * 2);
                ctx.arc(8, 6, 3.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                ctx.restore();
            },

            renderAnkhEffect(ctx, effect, progress) {
                ctx.save();
                const alpha = Math.max(0, 1 - progress);
                const t = Date.now() * 0.001;
                effect.customData.healingCircle.radius = Math.min(effect.customData.healingCircle.radius + 6.5, effect.customData.healingCircle.maxRadius);
                effect.customData.healingCircle.pulsePhase += 0.13;
                const pulse = Math.sin(effect.customData.healingCircle.pulsePhase) * 0.42 + 0.58;

                // Sanctuary field core
                ctx.globalAlpha = 0.38 * pulse * alpha;
                const field = ctx.createRadialGradient(effect.x, effect.y, 0, effect.x, effect.y, effect.customData.healingCircle.radius);
                field.addColorStop(0, 'rgba(0, 210, 255, 0.62)');
                field.addColorStop(0.45, 'rgba(116, 245, 255, 0.34)');
                field.addColorStop(1, 'rgba(0, 210, 255, 0)');
                ctx.fillStyle = field;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, effect.customData.healingCircle.radius, 0, Math.PI * 2);
                ctx.fill();

                // Outer pulse ring
                ctx.globalAlpha = 0.5 * alpha;
                ctx.strokeStyle = '#80ecff';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#00d8ff';
                ctx.shadowBlur = 18;
                ctx.setLineDash([8, 12]);
                ctx.lineDashOffset = -t * 40;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, effect.customData.healingCircle.radius * (0.85 + pulse * 0.12), 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Rays
                effect.customData.lightRays.forEach((ray, idx) => {
                    ray.length = Math.min(ray.length + 6, ray.maxLength);
                    ray.angle += 0.007 * (idx % 2 === 0 ? 1 : -1);
                    const endX = effect.x + Math.cos(ray.angle) * ray.length;
                    const endY = effect.y + Math.sin(ray.angle) * ray.length;
                    ctx.globalAlpha = 0.45 * alpha;
                    ctx.strokeStyle = idx % 2 === 0 ? '#00d8ff' : '#9df9ff';
                    ctx.lineWidth = Math.max(2, ray.width * 0.55);
                    ctx.shadowColor = '#00d8ff';
                    ctx.shadowBlur = 18;
                    ctx.beginPath();
                    ctx.moveTo(effect.x, effect.y);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                });

                // Ankh glyph (vector, not text)
                effect.customData.ankhSymbol.scale = Math.min(effect.customData.ankhSymbol.scale + 0.03, 1.75);
                effect.customData.ankhSymbol.rotation += 0.025;
                effect.customData.ankhSymbol.glow = Math.sin(Date.now() / 150) * 0.5 + 0.5;
                ctx.globalAlpha = 0.9 * alpha;
                ctx.save();
                ctx.translate(effect.x, effect.y);
                ctx.scale(effect.customData.ankhSymbol.scale, effect.customData.ankhSymbol.scale);
                ctx.rotate(effect.customData.ankhSymbol.rotation);
                ctx.strokeStyle = '#ffd166';
                ctx.lineWidth = 5;
                ctx.shadowColor = '#ffd166';
                ctx.shadowBlur = 22 + effect.customData.ankhSymbol.glow * 12;
                ctx.beginPath();
                ctx.arc(0, -16, 14, 0, Math.PI * 2);
                ctx.moveTo(0, -2);
                ctx.lineTo(0, 32);
                ctx.moveTo(-20, 10);
                ctx.lineTo(20, 10);
                ctx.stroke();

                // Inner gem core
                ctx.fillStyle = '#00d8ff';
                ctx.shadowColor = '#00d8ff';
                ctx.shadowBlur = 16;
                ctx.beginPath();
                ctx.arc(0, 8, 4.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                ctx.restore();
            },

            renderPlagueEffect(ctx, effect, progress) {
                ctx.save();
                const elapsed = progress * effect.duration;
                const alpha = Math.max(0, 1 - progress);
                const t = Date.now() * 0.001;
                const paletteByType = {
                    blood: '#f24d4d',
                    locusts: '#9cbf3f',
                    darkness: '#3c2a4d',
                    hail: '#86d1ff',
                    death: '#b57cff'
                };

                // Activate plagues in phases
                effect.customData.plagues.forEach((plague) => {
                    if (elapsed > plague.delay && !plague.active) {
                        plague.active = true;
                        for (let i = 0; i < 34; i++) {
                            plague.particles.push({
                                x: effect.x + (Math.random() - 0.5) * 420,
                                y: effect.y + (Math.random() - 0.5) * 420,
                                vx: (Math.random() - 0.5) * 3,
                                vy: (Math.random() - 0.5) * 3,
                                size: 4 + Math.random() * 9,
                                life: 1
                            });
                        }
                    }

                    if (plague.active) {
                        const tone = paletteByType[plague.type] || '#84cc16';
                        plague.particles.forEach(p => {
                            p.x += p.vx;
                            p.y += p.vy;
                            p.life -= 0.012;

                            if (p.life > 0) {
                                ctx.globalAlpha = p.life * 0.62 * alpha;
                                ctx.fillStyle = tone;
                                ctx.shadowColor = tone;
                                ctx.shadowBlur = 15;
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        });
                    }
                });

                // Aura verde-dorada
                effect.customData.auraRings.forEach((ring, i) => {
                    ring.alpha = Math.min(ring.alpha + 0.02, 0.5);
                    ring.rotation += 0.025 * (i % 2 === 0 ? 1 : -1);

                    ctx.globalAlpha = ring.alpha * alpha;
                    ctx.strokeStyle = i % 2 === 0 ? '#84cc16' : '#ffd166';
                    ctx.lineWidth = 4;
                    ctx.shadowColor = i % 2 === 0 ? '#84cc16' : '#ffd166';
                    ctx.shadowBlur = 20;
                    ctx.setLineDash([12, 14]);
                    ctx.lineDashOffset = ring.rotation * 100;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, ring.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                });

                // Central corruption core
                const coreRadius = 22 + Math.sin(t * 5) * 4;
                const core = ctx.createRadialGradient(effect.x, effect.y, 0, effect.x, effect.y, 90);
                core.addColorStop(0, 'rgba(132, 204, 22, 0.65)');
                core.addColorStop(1, 'rgba(132, 204, 22, 0)');
                ctx.globalAlpha = 0.8 * alpha;
                ctx.fillStyle = core;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, 90, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#b7f35f';
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, coreRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            },

            renderUnderworldEffect(ctx, effect, progress) {
                ctx.save();
                const alpha = Math.max(0, 1 - progress);
                const t = Date.now() * 0.001;

                // Duat portal expansion
                effect.customData.portal.radius = Math.min(effect.customData.portal.radius + 12, effect.customData.portal.maxRadius);
                effect.customData.portal.rotation += 0.02;

                // Dark vortex
                ctx.globalAlpha = 0.78 * alpha;
                const gradient = ctx.createRadialGradient(effect.x, effect.y, 0, effect.x, effect.y, effect.customData.portal.radius);
                gradient.addColorStop(0, '#000000');
                gradient.addColorStop(0.5, '#1a1030');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.shadowColor = '#7a3cff';
                ctx.shadowBlur = 50;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, effect.customData.portal.radius, 0, Math.PI * 2);
                ctx.fill();

                // Main portal ring
                ctx.globalAlpha = 0.86 * alpha;
                ctx.strokeStyle = '#ffd166';
                ctx.lineWidth = 8;
                ctx.shadowColor = '#ffd166';
                ctx.shadowBlur = 34;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, effect.customData.portal.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Rotating glyph fragments
                effect.customData.hieroglyphs.forEach((h, idx) => {
                    h.angle += 0.03;
                    h.glow = Math.sin(Date.now() / 100 + h.angle) * 0.5 + 0.5;
                    const hx = effect.x + Math.cos(h.angle + effect.customData.portal.rotation) * h.distance;
                    const hy = effect.y + Math.sin(h.angle + effect.customData.portal.rotation) * h.distance;

                    ctx.globalAlpha = 0.78 * alpha;
                    ctx.strokeStyle = idx % 2 === 0 ? '#ffd166' : '#8bf2ff';
                    ctx.lineWidth = 2.5;
                    ctx.shadowColor = idx % 2 === 0 ? '#ffd166' : '#8bf2ff';
                    ctx.shadowBlur = 14 + h.glow * 10;
                    ctx.save();
                    ctx.translate(hx, hy);
                    ctx.rotate(h.angle + t * 0.8);
                    ctx.beginPath();
                    ctx.moveTo(0, -h.size * 0.45);
                    ctx.lineTo(h.size * 0.35, 0);
                    ctx.lineTo(0, h.size * 0.45);
                    ctx.lineTo(-h.size * 0.35, 0);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                });

                // Rising sentinels
                effect.customData.warriors.forEach(warrior => {
                    if (progress * effect.duration > warrior.delay) {
                        warrior.height = Math.min(warrior.height + 4, warrior.maxHeight);
                        const wx = effect.x + Math.cos(warrior.angle) * warrior.distance;
                        const wy = effect.y + Math.sin(warrior.angle) * warrior.distance;

                        ctx.globalAlpha = 0.76 * alpha;
                        ctx.fillStyle = '#d8b06a';
                        ctx.shadowColor = '#d8b06a';
                        ctx.shadowBlur = 22;
                        ctx.fillRect(wx - 12, wy - warrior.height, 24, warrior.height);
                        ctx.beginPath();
                        ctx.arc(wx, wy - warrior.height - 8, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Spectral pillars
                effect.customData.fireColumns.forEach(col => {
                    if (progress * effect.duration > col.delay) {
                        col.active = true;
                        col.height = Math.min(col.height + 8, col.maxHeight);

                        ctx.globalAlpha = 0.72 * alpha;
                        const fireGradient = ctx.createLinearGradient(col.x, col.y, col.x, col.y - col.height);
                        fireGradient.addColorStop(0, '#00d8ff');
                        fireGradient.addColorStop(0.45, '#6e46ff');
                        fireGradient.addColorStop(0.75, '#ffd166');
                        fireGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                        ctx.fillStyle = fireGradient;
                        ctx.shadowColor = '#6e46ff';
                        ctx.shadowBlur = 35;
                        ctx.fillRect(col.x - 18, col.y - col.height, 36, col.height);
                    }
                });

                // Spectral Anubis form
                effect.customData.anubisForm.scale = Math.min(effect.customData.anubisForm.scale + 0.03, 3);
                effect.customData.anubisForm.alpha = Math.min(effect.customData.anubisForm.alpha + 0.02, 0.9);
                effect.customData.anubisForm.yOffset = Math.sin(Date.now() / 300) * 20;

                ctx.globalAlpha = effect.customData.anubisForm.alpha * alpha;
                ctx.save();
                ctx.translate(effect.x, effect.y - 100 + effect.customData.anubisForm.yOffset);
                ctx.scale(effect.customData.anubisForm.scale, effect.customData.anubisForm.scale);
                ctx.fillStyle = '#ffd166';
                ctx.shadowColor = '#00d8ff';
                ctx.shadowBlur = 46;
                ctx.beginPath();
                ctx.moveTo(0, -44);
                ctx.lineTo(22, -14);
                ctx.lineTo(16, 36);
                ctx.lineTo(-16, 36);
                ctx.lineTo(-22, -14);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#1a1028';
                ctx.beginPath();
                ctx.moveTo(-14, -12);
                ctx.lineTo(-22, -34);
                ctx.lineTo(-6, -18);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(14, -12);
                ctx.lineTo(22, -34);
                ctx.lineTo(6, -18);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#00d8ff';
                ctx.beginPath();
                ctx.arc(-6, 3, 3, 0, Math.PI * 2);
                ctx.arc(6, 3, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                ctx.restore();
            }
        };

        // ===== ABILITY MANAGER =====
        const AbilityManager = {
            activateAbility(abilityId) {
                // Prevent ability usage when game is paused
                if (MobRaidSystem.paused) {
                    console.log('?? Cannot use abilities while paused!');
                    return false;
                }

                const abilities = EquipmentManager.getAllAbilities();
                const ability = abilities.find(a => a.id === abilityId);

                if (!ability) return false;
                if (!this.isAbilityReady(abilityId)) return false;

                console.log(`? ${ability.name}`);

                // Apply class cooldown multiplier
                let cooldown = ability.cooldown;
                if (EquipmentManager.equippedRole && EquipmentManager.equippedRole.type === 'class') {
                    const classId = EquipmentManager.equippedRole.id;
                    const cooldownMultiplier = ClassProgressionSystem.getCooldownMultiplier(classId);
                    cooldown = Math.floor(cooldown * cooldownMultiplier);
                }
                ability.currentCooldown = cooldown;

                if (typeof SfxManager !== 'undefined') {
                    SfxManager.playAbility(abilityId);
                }

                // Play generic effect at player position for non-ground abilities that don't handle it themselves
                if (!abilityId.includes('glyph') && !abilityId.includes('hurl') && !abilityId.startsWith('anubis_')) {
                    EffectRenderer.playEffect(ability.effectId, Player.x, Player.y);
                }

                this.showAbilityPopup(ability.name, ability.type === 'ultimate');

                if (ability.type === 'ultimate') {
                    this.screenShake();
                }

                // Special class abilities
                if (MobRaidSystem.active || PracticeModeManager.active) {
                    // Dragonhunter
                    if (abilityId === 'dragon_arrow') {
                        MobRaidSystem.dragonFlameArrow(ability);
                    } else if (abilityId === 'dragon_breath') {
                        MobRaidSystem.dragonBreathBomb();
                    } else if (abilityId === 'triple_arrow') {
                        MobRaidSystem.tripleArrowUse();
                    } else if (abilityId === 'nature_rise') {
                        MobRaidSystem.natureRising();
                    } else if (abilityId === 'dragon_madness') {
                        MobRaidSystem.draconicMadness();
                    } else if (abilityId === 'dragon_ultimate') {
                        MobRaidSystem.draconicExplosion();
                    }
                    // Elementalist
                    else if (abilityId === 'elem_storm') {
                        MobRaidSystem.elementalStorm();
                    } else if (abilityId === 'elem_ice') {
                        MobRaidSystem.iceBarrier();
                    } else if (abilityId === 'elem_ultimate') {
                        MobRaidSystem.elementalCataclysm();
                    }
                    // Ronin Samurai
                    else if (abilityId === 'samurai_dash') {
                        MobRaidSystem.swiftCut();
                    } else if (abilityId === 'samurai_counter') {
                        MobRaidSystem.counterAttack();
                    } else if (abilityId === 'samurai_ninja_power') {
                        MobRaidSystem.ninjaPower();
                    } else if (abilityId === 'samurai_surprise_cut') {
                        MobRaidSystem.surpriseCut();
                    } else if (abilityId === 'samurai_ultimate') {
                        MobRaidSystem.thousandLeavesDance();
                    }
                    // Wild Berserker
                    else if (abilityId === 'berserker_rage') {
                        MobRaidSystem.wildRage();
                    } else if (abilityId === 'berserker_whirlwind' || abilityId === 'berserker_leap') {
                        MobRaidSystem.berserkerWhirlwind();
                    } else if (abilityId === 'berserker_axes') {
                        MobRaidSystem.doubleAxes();
                    } else if (abilityId === 'berserker_bloodlust' || abilityId === 'berserker_surprise') {
                        MobRaidSystem.berserkerBloodmark();
                    } else if (abilityId === 'berserker_transform') {
                        MobRaidSystem.berserkerTransform();
                    } else if (abilityId === 'berserker_ultimate') {
                        MobRaidSystem.bloodlust();
                    }
                    // Shadow Ninja
                    else if (abilityId === 'ninja_shadow_strike') {
                        MobRaidSystem.shadowStrike();
                    } else if (abilityId === 'ninja_shuriken') {
                        MobRaidSystem.shurikenRain();
                    } else if (abilityId === 'ninja_smoke') {
                        MobRaidSystem.shadowVeil();
                    } else if (abilityId === 'ninja_clone') {
                        MobRaidSystem.shadowClone();
                    } else if (abilityId === 'ninja_ultimate') {
                        LoadoutManager.trackAbilityUsage('ninja_ultimate');
                        MobRaidSystem.silentExecution();
                    }
                    // Wind Master
                    else if (abilityId === 'wind_radioactive') {
                        MobRaidSystem.radioactiveWind();
                    } else if (abilityId === 'wind_bubbles') {
                        MobRaidSystem.toxicAirBubbles();
                    } else if (abilityId === 'wind_ventoso') {
                        MobRaidSystem.ventoso();
                    } else if (abilityId === 'wind_ciclon') {
                        MobRaidSystem.ciclon();
                    } else if (abilityId === 'wind_ultimate') {
                        MobRaidSystem.strongWindAttraction();
                    }
                    // Tornado Overlord (Master Class)
                    else if (abilityId === 'master_singularity') {
                        MobRaidSystem.windSingularity();
                    } else if (abilityId === 'master_pressure') {
                        MobRaidSystem.atmosphericPressure();
                    } else if (abilityId === 'master_tornado_barrage') {
                        MobRaidSystem.tornadoBarrage();
                    } else if (abilityId === 'master_storm_shield') {
                        MobRaidSystem.stormShield();
                    } else if (abilityId === 'master_enemy_tornado') {
                        MobRaidSystem.enemyTornado();
                    } else if (abilityId === 'master_apocalyptic_storm') {
                        MobRaidSystem.apocalypticStorm();
                    }
                    // Abyssal Shadowlord (Master Class - Shadow Ninja)
                    else if (abilityId === 'abyssal_blade_storm') {
                        MobRaidSystem.abyssalBladeStorm();
                    } else if (abilityId === 'abyssal_death_chain') {
                        MobRaidSystem.abyssalDeathChain();
                    } else if (abilityId === 'abyssal_void_leap') {
                        MobRaidSystem.abyssalVoidLeap();
                    } else if (abilityId === 'abyssal_shadow_legion') {
                        MobRaidSystem.abyssalShadowLegion();
                    } else if (abilityId === 'abyssal_shadow_emperor') {
                        MobRaidSystem.abyssalShadowEmperor();
                    } else if (abilityId === 'abyssal_eternal_night') {
                        MobRaidSystem.abyssalEternalNight();
                    }
                    // Roman Legionary
                    else if (abilityId === 'roman_gladius') {
                        MobRaidSystem.gladiusFulminante();
                    } else if (abilityId === 'roman_testudo') {
                        MobRaidSystem.formacionTestudo();
                    } else if (abilityId === 'roman_pilum') {
                        MobRaidSystem.lanzamientoPilum();
                    } else if (abilityId === 'roman_centurion') {
                        MobRaidSystem.gritoCenturion();
                    } else if (abilityId === 'roman_aquila') {
                        MobRaidSystem.aguilaImperial();
                    } else if (abilityId === 'roman_legio') {
                        MobRaidSystem.legioAeterna();
                    }
                    // Spartan Hoplite
                    else if (abilityId === 'spartan_dory') {
                        MobRaidSystem.doruPenetrante();
                    } else if (abilityId === 'spartan_phalanx') {
                        MobRaidSystem.falangeEspartana();
                    } else if (abilityId === 'spartan_charge') {
                        MobRaidSystem.cargaEspartana();
                    } else if (abilityId === 'spartan_aroo') {
                        MobRaidSystem.gritoAroo();
                    } else if (abilityId === 'spartan_ares') {
                        MobRaidSystem.bendicionAres();
                    } else if (abilityId === 'spartan_thermopylae') {
                        MobRaidSystem.lasTermopilas();
                    }
                    // Cyber Gunslinger (Base Class)
                    else if (abilityId === 'gun_ultimate') {
                        MobRaidSystem.orbitalStrike();
                    }
                    // Cybernetic Warlord (Master Class)
                    else if (abilityId === 'cyber_plasma_cannon') {
                        MobRaidSystem.plasmaCannon();
                    } else if (abilityId === 'cyber_singularity_grenade') {
                        MobRaidSystem.singularityGrenade();
                    } else if (abilityId === 'cyber_drone_swarm') {
                        MobRaidSystem.droneSwarm();
                    } else if (abilityId === 'cyber_photon_barrier') {
                        MobRaidSystem.photonBarrier();
                    } else if (abilityId === 'cyber_mech_suit') {
                        MobRaidSystem.mechSuit();
                    } else if (abilityId === 'cyber_orbital_ragnarok') {
                        MobRaidSystem.orbitalRagnarok();
                    }
                    // Guardian Ancestral (SSS)
                    else if (abilityId === 'guardian_glyph') {
                        MobRaidSystem.guardianGlyph();
                    } else if (abilityId === 'guardian_hurl') {
                        MobRaidSystem.guardianHurl();
                    } else if (abilityId === 'guardian_tablets') {
                        MobRaidSystem.guardianTablets();
                    } else if (abilityId === 'guardian_burrow') {
                        MobRaidSystem.guardianBurrow();
                    } else if (abilityId === 'guardian_construct') {
                        MobRaidSystem.guardianConstruct();
                    } else if (abilityId === 'guardian_worldbreaker') {
                        MobRaidSystem.guardianWorldbreaker();
                    }
                    // Anubis (SSS)
                    else if (abilityId === 'anubis_judgment') {
                        MobRaidSystem.anubisJudgment();
                    } else if (abilityId === 'anubis_sandstorm') {
                        MobRaidSystem.anubisSandstorm();
                    } else if (abilityId === 'anubis_jackal') {
                        MobRaidSystem.anubisJackal();
                    } else if (abilityId === 'anubis_ankh') {
                        MobRaidSystem.anubisAnkh();
                    } else if (abilityId === 'anubis_plague') {
                        MobRaidSystem.anubisPlague();
                    } else if (abilityId === 'anubis_underworld') {
                        MobRaidSystem.anubisUnderworld();
                    }
                    // Regular abilities
                    else {
                        const damage = ability.type === 'ultimate' ? 50 : 25;
                        if (MobRaidSystem.active) {
                            MobRaidSystem.checkAbilityHit(Player.x, Player.y, 150, damage);
                        }
                        if (PracticeModeManager.active) {
                            PracticeModeManager.applyDamageToDummies(Player.x, Player.y, 150, damage);
                        }
                    }
                }

                this.updateAbilityUI();
                return true;
            },

            updateCooldowns(deltaTime) {
                // Don't update cooldowns when game is paused
                if (MobRaidSystem.paused) return;

                const abilities = EquipmentManager.getAllAbilities();
                abilities.forEach(ability => {
                    if (ability.currentCooldown > 0) {
                        ability.currentCooldown = Math.max(0, ability.currentCooldown - deltaTime);
                    }
                });
                this.updateAbilityUI();
            },

            isAbilityReady(abilityId) {
                const abilities = EquipmentManager.getAllAbilities();
                const ability = abilities.find(a => a.id === abilityId);
                return ability && ability.currentCooldown === 0;
            },

            updateAbilityUI() {
                const abilities = EquipmentManager.getAllAbilities();
                const abilitySlots = document.querySelectorAll('.ability-slot');

                abilitySlots.forEach((slot, index) => {
                    const ability = abilities[index];
                    if (!ability) return;

                    const cooldownDiv = slot.querySelector('.ability-cooldown');

                    if (ability.currentCooldown > 0) {
                        slot.classList.add('on-cooldown');
                        const seconds = Math.ceil(ability.currentCooldown / 1000);
                        cooldownDiv.textContent = seconds;
                    } else {
                        slot.classList.remove('on-cooldown');
                        cooldownDiv.textContent = '';
                    }
                });
            },

            showAbilityPopup(name, isUltimate) {
                const popup = document.createElement('div');
                popup.style.cssText = `
                    position: fixed;
                    top: 20%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: ${isUltimate ? 'linear-gradient(135deg, #ffbe0b, #ff006e)' : 'linear-gradient(135deg, #00d9ff, #ff006e)'};
                    color: white;
                    padding: ${isUltimate ? '15px 30px' : '12px 25px'};
                    border-radius: 12px;
                    font-size: ${isUltimate ? '20px' : '16px'};
                    font-weight: 700;
                    z-index: 6000;
                    pointer-events: none;
                    animation: popupFade 0.8s ease-out forwards;
                    border: 2px solid ${isUltimate ? '#ffbe0b' : '#00d9ff'};
                    box-shadow: 0 0 20px ${isUltimate ? 'rgba(255, 190, 11, 0.6)' : 'rgba(0, 217, 255, 0.5)'};
                    font-family: 'Orbitron', sans-serif;
                    letter-spacing: 1px;
                    text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
                `;
                popup.textContent = name;
                document.body.appendChild(popup);

                setTimeout(() => popup.remove(), 800);
            },

            screenShake() {
                const container = document.querySelector('.main-canvas');
                container.style.animation = 'shake 0.7s ease-in-out';
                setTimeout(() => {
                    container.style.animation = '';
                }, 700);
            }
        };

        // ===== UI MANAGER =====
        const UIManager = {
            currentTab: 'characters',

            showRoleSelection(type = 'characters') {
                this.currentTab = type;
                document.getElementById('role-selection-modal').classList.remove('hidden');
                this.renderRoleGrid(type);
            },

            hideRoleSelection() {
                document.getElementById('role-selection-modal').classList.add('hidden');
            },

            renderRoleGrid(type) {
                const grid = document.getElementById('role-grid');
                grid.innerHTML = '';

                let roles = [...(rolesData[type] || [])]; // Create a copy to avoid mutating original

                // Sort roles by tier (SSS > S+ > S > A > B > C, then by name)
                const tierOrder = { 'SSS': 0, 'S+': 1, 'S': 2, 'A': 3, 'B': 4, 'C': 5 };

                roles.sort((a, b) => {
                    const aTier = a.tier || 'Z'; // Put items without tier at the end
                    const bTier = b.tier || 'Z';

                    const aTierValue = tierOrder[aTier] !== undefined ? tierOrder[aTier] : 999;
                    const bTierValue = tierOrder[bTier] !== undefined ? tierOrder[bTier] : 999;

                    // Sort by tier first
                    if (aTierValue !== bTierValue) {
                        return aTierValue - bTierValue;
                    }

                    // If same tier, sort alphabetically by name
                    return a.name.localeCompare(b.name);
                });

                console.log('Sorted roles:', roles.map(r => `${r.name} (${r.tier || 'No tier'})`));

                roles.forEach(role => {
                    const card = document.createElement('div');
                    card.className = 'role-card';

                    // Get current tickets for this class
                    const currentTickets = role.type === 'class' ? (EquipmentManager.classTickets[role.id] || 0) : 0;

                    // Check if class is locked (not unlocked AND doesn't have enough tickets)
                    const isUnlocked = EquipmentManager.isClassUnlocked(role.id);
                    const hasEnoughTickets = currentTickets >= (role.ticketsRequired || 0);
                    const isLocked = role.type === 'class' && role.ticketsRequired && !isUnlocked && !hasEnoughTickets;
                    const canUnlock = role.type === 'class' && role.ticketsRequired && !isUnlocked && hasEnoughTickets;

                    // Add tier styling for classes
                    if (role.tier) {
                        card.style.borderColor = role.tierColor;
                        card.style.boxShadow = `0 0 20px ${role.tierColor}40`;
                    }

                    // Add locked styling
                    if (isLocked) {
                        card.style.opacity = '0.6';
                        card.style.filter = 'grayscale(50%)';
                    }

                    // Add "can unlock" styling
                    if (canUnlock) {
                        card.style.borderColor = '#ffd700';
                        card.style.boxShadow = '0 0 30px rgba(255, 215, 0, 0.6)';
                        card.style.animation = 'pulse 2s ease-in-out infinite';
                    }

                    card.innerHTML = `
                        <div class="role-card-icon">${IconRenderer.icons[role.id] ? IconRenderer.getIconHTML(role.id, 48) : role.icon}</div>
                        <div class="role-card-name">${role.name}</div>
                        <div class="role-card-type">${role.type}</div>
                        ${role.tier ? `<div style="color: ${role.tierColor}; font-weight: 900; font-size: 16px; margin-top: 5px;">Tier ${role.tier}</div>` : ''}
                        ${role.ticketsRequired ? `<div style="color: ${isUnlocked ? '#00ff00' : canUnlock ? '#ffd700' : '#999'}; font-size: 12px; margin-top: 3px;">${isUnlocked ? '?' : canUnlock ? '?' : '??'} ${currentTickets}/${role.ticketsRequired} Tickets ${isUnlocked ? 'Unlocked' : canUnlock ? 'Ready!' : 'to Unlock'}</div>` : ''}
                    `;

                    card.addEventListener('click', () => {
                        // Show info panel
                        this.showRoleInfoPanel(role, isLocked, currentTickets, canUnlock, isUnlocked);
                    });

                    grid.appendChild(card);
                });
            },

            showRoleInfoPanel(role, isLocked, currentTickets, canUnlock, isUnlocked) {
                // Remove existing panel if any
                const existingPanel = document.getElementById('role-info-panel');
                if (existingPanel) existingPanel.remove();

                // Create info panel
                const panel = document.createElement('div');
                panel.id = 'role-info-panel';
                panel.style.cssText = `
                    position: fixed;
                    right: 0;
                    top: 0;
                    width: 450px;
                    height: 100%;
                    background: linear-gradient(135deg, rgba(10, 14, 39, 0.98), rgba(5, 8, 20, 0.98));
                    border-left: 3px solid ${role.tierColor || '#00d9ff'};
                    z-index: 11000;
                    padding: 30px;
                    overflow-y: auto;
                    box-shadow: -10px 0 50px rgba(0, 0, 0, 0.8);
                    animation: slideInRight 0.3s ease-out;
                `;

                // Build abilities HTML
                let abilitiesHTML = '';
                if (role.abilities) {
                    role.abilities.forEach((ability, index) => {
                        // Generate image path from ability name (without extension for fallback)
                        const imageName = normalizeImageName(ability.name);
                        const abilityIconId = ability.id || ability.effectId || IconRenderer.getIconFor(ability) || 'default';
                        const abilityIconHTML = `<div style="width: 60px; height: 60px; border-radius: 10px; overflow: hidden; border: 2px solid rgba(0, 217, 255, 0.5); box-shadow: 0 0 15px rgba(0, 217, 255, 0.3); display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.3);">
                            ${IconRenderer.getIconHTML(abilityIconId, 50)}
                           </div>`;

                        abilitiesHTML += `
                            <div style="background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(255, 0, 110, 0.1)); border: 2px solid rgba(0, 217, 255, 0.3); border-radius: 12px; padding: 15px; margin-bottom: 15px;">
                                <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                                    ${abilityIconHTML}
                                    <div style="flex: 1;">
                                        <div style="color: #00d9ff; font-weight: 800; font-size: 16px; margin-bottom: 3px;">${ability.name}</div>
                                        <div style="color: rgba(224, 231, 255, 0.7); font-size: 12px;">Recarga: ${ability.cooldown / 1000}s | Tecla: ${ability.keyBinding.toUpperCase()}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                }

                // Ultimate ability
                if (role.ultimateAbility) {
                    // Generate image path from ability name (without extension for fallback)
                    const imageName = normalizeImageName(role.ultimateAbility.name);
                    const ultimateIconId = role.ultimateAbility.effectId || IconRenderer.getIconFor(role.ultimateAbility) || role.ultimateAbility.id;
                    const ultimateIconHTML = `<div style="width: 70px; height: 70px; border-radius: 12px; overflow: hidden; border: 3px solid rgba(255, 190, 11, 0.7); box-shadow: 0 0 20px rgba(255, 190, 11, 0.5); display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.3);">
                        ${IconRenderer.getIconHTML(ultimateIconId, 60)}
                       </div>`;

                    abilitiesHTML += `
                        <div style="background: linear-gradient(135deg, rgba(255, 190, 11, 0.15), rgba(255, 0, 110, 0.15)); border: 3px solid rgba(255, 190, 11, 0.6); border-radius: 12px; padding: 15px; margin-bottom: 15px; box-shadow: 0 0 20px rgba(255, 190, 11, 0.3);">
                            <div style="color: #ffbe0b; font-weight: 900; font-size: 12px; margin-bottom: 10px; letter-spacing: 2px;">? HABILIDAD DEFINITIVA</div>
                            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                                ${ultimateIconHTML}
                                <div style="flex: 1;">
                                    <div style="color: #ffbe0b; font-weight: 800; font-size: 18px; margin-bottom: 3px;">${role.ultimateAbility.name}</div>
                                    <div style="color: rgba(224, 231, 255, 0.7); font-size: 12px;">Recarga: ${role.ultimateAbility.cooldown / 1000}s | Tecla: ${role.ultimateAbility.keyBinding.toUpperCase()}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }

                panel.innerHTML = `
                    <button id="close-info-panel" style="
                        position: absolute;
                        top: 20px;
                        right: 20px;
                        background: rgba(255, 0, 110, 0.2);
                        border: 2px solid #ff006e;
                        color: #ff006e;
                        width: 40px;
                        height: 40px;
                        border-radius: 50%;
                        font-size: 20px;
                        cursor: pointer;
                        transition: all 0.3s;
                        z-index: 10;
                    " onmouseover="this.style.background='#ff006e'; this.style.color='#fff'" onmouseout="this.style.background='rgba(255, 0, 110, 0.2)'; this.style.color='#ff006e'">?</button>

                    <div style="text-align: center; margin-bottom: 30px;">
                        <!-- Class Image -->
                        <div style="width: 100%; height: 220px; margin-bottom: 20px; border-radius: 15px; overflow: hidden; position: relative; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6); border: 3px solid ${role.tierColor || '#00d9ff'}; display: flex; align-items: center; justify-content: center; background: radial-gradient(circle at center, ${role.tierColor || '#00d9ff'}22, transparent);">
                            <div style="filter: drop-shadow(0 0 20px ${role.tierColor || '#00d9ff'}); transform: scale(1.5);">
                                ${IconRenderer.getIconHTML(role.id, 140)}
                            </div>
                        </div>
                        
                        <h2 style="font-size: 32px; color: ${role.tierColor || '#00d9ff'}; margin-bottom: 10px; font-weight: 900; text-shadow: 0 0 20px ${role.tierColor || '#00d9ff'};">${role.name}</h2>
                        <div style="color: rgba(224, 231, 255, 0.8); font-size: 14px; margin-bottom: 15px; line-height: 1.6;">${role.description}</div>
                        ${role.tier ? `<div style="display: inline-block; background: linear-gradient(135deg, ${role.tierColor}, rgba(${role.tierColor.replace('#', '').match(/.{2}/g).map(x => parseInt(x, 16)).join(',')}, 0.5)); padding: 8px 20px; border-radius: 20px; font-weight: 900; font-size: 16px; color: #fff; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);">TIER ${role.tier}</div>` : ''}
                    </div>

                    ${role.ticketsRequired ? `
                        <div style="background: ${isUnlocked ? 'rgba(0, 255, 0, 0.1)' : canUnlock ? 'rgba(255, 215, 0, 0.1)' : 'rgba(255, 0, 0, 0.1)'}; border: 2px solid ${isUnlocked ? '#00ff00' : canUnlock ? '#ffd700' : '#ff0000'}; border-radius: 12px; padding: 15px; margin-bottom: 25px; text-align: center;">
                            <div style="font-size: 14px; color: rgba(224, 231, 255, 0.9); margin-bottom: 8px;">
                                ${isUnlocked ? '? DESBLOQUEADO' : canUnlock ? '? LISTO PARA DESBLOQUEAR' : '?? BLOQUEADO'}
                            </div>
                            <div style="font-size: 24px; color: ${isUnlocked ? '#00ff00' : canUnlock ? '#ffd700' : '#ff0000'}; font-weight: 900;">
                                ${currentTickets} / ${role.ticketsRequired} Tickets
                            </div>
                            ${isLocked ? `<div style="color: rgba(224, 231, 255, 0.7); font-size: 12px; margin-top: 8px;">Necesitas ${role.ticketsRequired - currentTickets} tickets más</div>` : ''}
                            ${canUnlock ? `<div style="color: rgba(255, 215, 0, 0.9); font-size: 12px; margin-top: 8px;">?? ¡Haz clic en "Desbloquear" para usar esta clase!</div>` : ''}
                            ${isUnlocked ? `<div style="color: rgba(0, 255, 0, 0.8); font-size: 12px; margin-top: 8px;">? Clase desbloqueada y lista para usar</div>` : ''}
                        </div>
                    ` : ''}

                    <div style="margin-bottom: 25px;">
                        <h3 style="color: #00d9ff; font-size: 20px; margin-bottom: 15px; font-weight: 800; text-transform: uppercase; letter-spacing: 2px;">?? Habilidades</h3>
                        ${abilitiesHTML}
                    </div>

                    <button id="equip-role-btn" style="
                        width: 100%;
                        padding: 18px;
                        font-size: 20px;
                        font-weight: 900;
                        background: ${isLocked ? 'linear-gradient(135deg, #666, #444)' : canUnlock ? 'linear-gradient(135deg, #ffd700, #ff8c00)' : 'linear-gradient(135deg, #00d9ff, #ff006e)'};
                        border: none;
                        border-radius: 12px;
                        color: white;
                        cursor: pointer;
                        font-family: 'Orbitron', sans-serif;
                        box-shadow: ${isLocked ? '0 8px 25px rgba(0, 0, 0, 0.5)' : canUnlock ? '0 8px 25px rgba(255, 215, 0, 0.5)' : '0 8px 25px rgba(0, 217, 255, 0.5)'};
                        transition: all 0.3s;
                        letter-spacing: 2px;
                        text-transform: uppercase;
                        ${isLocked ? 'opacity: 0.5; cursor: not-allowed;' : ''}
                    " ${isLocked ? 'disabled' : ''} onmouseover="if(!this.disabled) { this.style.transform='translateY(-3px)'; this.style.boxShadow='0 12px 35px ${canUnlock ? 'rgba(255, 215, 0, 0.7)' : 'rgba(0, 217, 255, 0.7)'}'; }" onmouseout="if(!this.disabled) { this.style.transform='translateY(0)'; this.style.boxShadow='0 8px 25px ${canUnlock ? 'rgba(255, 215, 0, 0.5)' : 'rgba(0, 217, 255, 0.5)'}'; }">
                        ${isLocked ? '?? Bloqueado' : canUnlock ? '?? Desbloquear' : '? Equipar'}
                    </button>
                `;

                // Add CSS animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes slideInRight {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                `;
                document.head.appendChild(style);

                document.body.appendChild(panel);

                // Close button
                document.getElementById('close-info-panel').addEventListener('click', () => {
                    panel.remove();
                });

                // Equip button
                if (!isLocked) {
                    document.getElementById('equip-role-btn').addEventListener('click', () => {
                        // Check if class needs to be unlocked
                        if (role.type === 'class' && role.ticketsRequired) {
                            // Check if already unlocked
                            if (!EquipmentManager.isClassUnlocked(role.id)) {
                                // Check specific class tickets
                                const currentTickets = EquipmentManager.classTickets[role.id] || 0;

                                if (currentTickets < role.ticketsRequired) {
                                    alert(`? Not enough ${role.name} tickets! You need ${role.ticketsRequired} but only have ${currentTickets}.`);
                                    return;
                                }
                                // Unlock the class
                                EquipmentManager.classTickets[role.id] -= role.ticketsRequired;
                                EquipmentManager.unlockClass(role.id);

                                // Update total counter
                                const totalTickets = Object.values(EquipmentManager.classTickets).reduce((a, b) => a + b, 0);
                                document.getElementById('ticket-counter').textContent = totalTickets;

                                EquipmentManager.saveProgress();
                                EquipmentManager.updateStatsDisplay();
                                console.log(`?? Unlocked ${role.name}! Used ${role.ticketsRequired} tickets. Remaining:`, EquipmentManager.classTickets[role.id]);
                                alert(`?? ${role.name} unlocked! You can now equip it anytime.`);
                            }
                        }
                        EquipmentManager.equipRole(role);
                        this.hideRoleSelection();
                        panel.remove();
                    });
                }
            }
        };

        // Event listeners
        // Hamburger Menu Toggle
        const menuToggle = document.getElementById('menu-toggle');
        const sideMenu = document.getElementById('side-menu');
        const menuOverlay = document.getElementById('menu-overlay');

        function openMenu() {
            sideMenu.classList.add('open');
            menuOverlay.classList.add('active');
            menuToggle.classList.add('active');
        }

        function closeMenu() {
            sideMenu.classList.remove('open');
            menuOverlay.classList.remove('active');
            menuToggle.classList.remove('active');
        }

        menuToggle.addEventListener('click', () => {
            if (sideMenu.classList.contains('open')) {
                closeMenu();
            } else {
                openMenu();
            }
        });

        menuOverlay.addEventListener('click', closeMenu);

        // Menu Items
        document.getElementById('menu-raid-btn').addEventListener('click', () => {
            closeMenu();
            if (!MobRaidSystem.active) {
                RaidManager.showRaidSelect();
            }
        });

        document.getElementById('menu-dungeon-btn').addEventListener('click', () => {
            closeMenu();
            DungeonManager.showDungeonSelect();
        });

        document.getElementById('menu-custom-raid-btn').addEventListener('click', () => {
            closeMenu();
            customRaidSelectedMobs.clear();
            customRaidSelectedBosses.clear();
            populateCustomRaidOptions();
            document.getElementById('custom-raid-modal').classList.remove('hidden');
        });

        document.getElementById('menu-practice-btn').addEventListener('click', () => {
            closeMenu();
            PracticeModeManager.enterPracticeMode();
        });

        document.getElementById('menu-loadout-btn').addEventListener('click', () => {
            closeMenu();
            LoadoutManager.openLoadoutModal();
        });

        document.getElementById('menu-class-upgrades-btn').addEventListener('click', () => {
            closeMenu();
            ClassProgressionSystem.showUpgradesModal();
        });

        document.getElementById('menu-update-log-btn').addEventListener('click', () => {
            closeMenu();
            document.getElementById('update-log-modal').classList.remove('hidden');
        });

        document.querySelector('.close-button').addEventListener('click', () => {
            UIManager.hideRoleSelection();
        });

        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                button.classList.add('active');
                UIManager.renderRoleGrid(button.dataset.tab);
            });
        });

        // Update Log Modal - Close button
        document.getElementById('close-update-log').addEventListener('click', () => {
            document.getElementById('update-log-modal').classList.add('hidden');
        });

        // Update Log Navigation
        document.querySelectorAll('.update-item').forEach(item => {
            item.addEventListener('click', () => {
                // Remove active from all items
                document.querySelectorAll('.update-item').forEach(i => {
                    i.classList.remove('active');
                    i.style.background = 'rgba(0, 217, 255, 0.1)';
                    i.style.borderLeftColor = 'transparent';
                });

                // Add active to clicked item
                item.classList.add('active');
                item.style.background = 'rgba(0, 217, 255, 0.2)';
                item.style.borderLeftColor = 'var(--primary)';

                // Hide all content
                document.querySelectorAll('.update-content').forEach(content => {
                    content.style.display = 'none';
                });

                // Show selected content
                const updateId = item.dataset.update;
                const content = document.querySelector(`.update-content[data-update="${updateId}"]`);
                if (content) {
                    content.style.display = 'block';
                }
            });
        });

        // News Slider removed

        // Custom Raid Modal
        const customRaidSelectedMobs = new Set();
        const customRaidSelectedBosses = new Set();

        function populateCustomRaidOptions() {
            const mobsGrid = document.getElementById('custom-mobs-grid');
            const bossesGrid = document.getElementById('custom-bosses-grid');

            mobsGrid.innerHTML = '';
            bossesGrid.innerHTML = '';

            // Regular mobs
            const regularMobs = [
                { type: 'tornado_apprentice', ...MobRaidSystem.mobTypes.tornado_apprentice },
                { type: 'necromancer', ...MobRaidSystem.mobTypes.necromancer },
                { type: 'fire_drake', ...MobRaidSystem.mobTypes.fire_drake },
                { type: 'water_elemental', ...MobRaidSystem.mobTypes.water_elemental },
                { type: 'ronin_warrior', ...MobRaidSystem.mobTypes.ronin_warrior },
                { type: 'combat_drone', ...MobRaidSystem.mobTypes.combat_drone },
                { type: 'arcane_wisp', ...MobRaidSystem.mobTypes.arcane_wisp },
                { type: 'toxic_zephyr', ...MobRaidSystem.mobTypes.toxic_zephyr },
                { type: 'radioactive_cyclone', ...MobRaidSystem.mobTypes.radioactive_cyclone },
                { type: 'blood_reaver', ...MobRaidSystem.mobTypes.blood_reaver },
                { type: 'axe_thrower', ...MobRaidSystem.mobTypes.axe_thrower },
                { type: 'shadow_assassin', ...MobRaidSystem.mobTypes.shadow_assassin },
                { type: 'smoke_phantom', ...MobRaidSystem.mobTypes.smoke_phantom },
                { type: 'roman_soldier', ...MobRaidSystem.mobTypes.roman_soldier },
                { type: 'praetorian_guard', ...MobRaidSystem.mobTypes.praetorian_guard },
                { type: 'spartan_warrior', ...MobRaidSystem.mobTypes.spartan_warrior },
                { type: 'athenian_hoplite', ...MobRaidSystem.mobTypes.athenian_hoplite },
                { type: 'stone_golem', ...MobRaidSystem.mobTypes.stone_golem },
                { type: 'ancient_sentinel', ...MobRaidSystem.mobTypes.ancient_sentinel },
                { type: 'anubis_jackal', ...MobRaidSystem.mobTypes.anubis_jackal },
                { type: 'anubis_mummy', ...MobRaidSystem.mobTypes.anubis_mummy },
                { type: 'anubis_sphinx', ...MobRaidSystem.mobTypes.anubis_sphinx }
            ];

            regularMobs.forEach(mob => {
                const card = document.createElement('div');
                card.style.cssText = `
                    background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(255, 0, 110, 0.1));
                    border: 2px solid rgba(0, 217, 255, 0.3);
                    border-radius: 10px;
                    padding: 15px;
                    cursor: pointer;
                    transition: all 0.3s;
                    text-align: center;
                `;
                card.innerHTML = `
                    <div style="font-size: 40px; margin-bottom: 10px;">${mob.icon}</div>
                    <div style="font-weight: bold; color: var(--light); margin-bottom: 5px;">${mob.name}</div>
                    <div style="font-size: 12px; color: var(--primary);">HP: ${mob.hp} | DMG: ${mob.damage}</div>
                    ${mob.dropsTicketFor ? `<div style="font-size: 11px; color: #ffd700; margin-top: 5px;">?? ${mob.dropsTicketFor.replace('class_', '').toUpperCase()}</div>` : ''}
                `;

                card.addEventListener('click', () => {
                    if (customRaidSelectedMobs.has(mob.type)) {
                        customRaidSelectedMobs.delete(mob.type);
                        card.style.border = '2px solid rgba(0, 217, 255, 0.3)';
                        card.style.background = 'linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(255, 0, 110, 0.1))';
                    } else {
                        customRaidSelectedMobs.add(mob.type);
                        card.style.border = '2px solid #00ff00';
                        card.style.background = 'linear-gradient(135deg, rgba(0, 255, 0, 0.2), rgba(0, 217, 255, 0.2))';
                    }
                });

                mobsGrid.appendChild(card);
            });

            // Bosses
            const bosses = [
                { type: 'tornado_master', ...MobRaidSystem.mobTypes.tornado_master },
                { type: 'king_of_skeletons', ...MobRaidSystem.mobTypes.king_of_skeletons },
                { type: 'ancient_dragon', ...MobRaidSystem.mobTypes.ancient_dragon },
                { type: 'storm_titan', ...MobRaidSystem.mobTypes.storm_titan },
                { type: 'shogun_lord', ...MobRaidSystem.mobTypes.shogun_lord },
                { type: 'mech_titan', ...MobRaidSystem.mobTypes.mech_titan },
                { type: 'elder_sorcerer', ...MobRaidSystem.mobTypes.elder_sorcerer },
                { type: 'tempest_lord', ...MobRaidSystem.mobTypes.tempest_lord },
                { type: 'warlord_colossus', ...MobRaidSystem.mobTypes.warlord_colossus },
                { type: 'shadow_emperor', ...MobRaidSystem.mobTypes.shadow_emperor },
                { type: 'caesar_imperator', ...MobRaidSystem.mobTypes.caesar_imperator },
                { type: 'leonidas_king', ...MobRaidSystem.mobTypes.leonidas_king },
                { type: 'aether_dragon', ...MobRaidSystem.mobTypes.aether_dragon },
                { type: 'taurha_giant', ...MobRaidSystem.mobTypes.taurha_giant },
                { type: 'anubis_pharaoh', ...MobRaidSystem.mobTypes.anubis_pharaoh },
                { type: 'anubis_colossus', ...MobRaidSystem.mobTypes.anubis_colossus },
                { type: 'anubis_avatar', ...MobRaidSystem.mobTypes.anubis_avatar }
            ];

            bosses.forEach(boss => {
                const card = document.createElement('div');
                card.style.cssText = `
                    background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 0, 110, 0.1));
                    border: 2px solid rgba(255, 215, 0, 0.3);
                    border-radius: 10px;
                    padding: 15px;
                    cursor: pointer;
                    transition: all 0.3s;
                    text-align: center;
                `;
                card.innerHTML = `
                    <div style="font-size: 40px; margin-bottom: 10px;">${boss.icon}</div>
                    <div style="font-weight: bold; color: #ffd700; margin-bottom: 5px;">${boss.name}</div>
                    <div style="font-size: 12px; color: var(--accent);">HP: ${boss.hp} | DMG: ${boss.damage}</div>
                    ${boss.dropsTicketFor ? `<div style="font-size: 11px; color: #ffd700; margin-top: 5px;">?? ${boss.dropsTicketFor.replace('class_', '').toUpperCase()}</div>` : ''}
                `;

                card.addEventListener('click', () => {
                    if (customRaidSelectedBosses.has(boss.type)) {
                        customRaidSelectedBosses.delete(boss.type);
                        card.style.border = '2px solid rgba(255, 215, 0, 0.3)';
                        card.style.background = 'linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 0, 110, 0.1))';
                    } else {
                        customRaidSelectedBosses.add(boss.type);
                        card.style.border = '2px solid #00ff00';
                        card.style.background = 'linear-gradient(135deg, rgba(0, 255, 0, 0.2), rgba(255, 215, 0, 0.2))';
                    }
                });

                bossesGrid.appendChild(card);
            });
        }

        document.getElementById('close-custom-raid').addEventListener('click', () => {
            document.getElementById('custom-raid-modal').classList.add('hidden');
        });

        document.getElementById('cancel-custom-raid-btn').addEventListener('click', () => {
            document.getElementById('custom-raid-modal').classList.add('hidden');
        });

        document.getElementById('start-custom-raid-btn').addEventListener('click', () => {
            if (customRaidSelectedMobs.size === 0 && customRaidSelectedBosses.size === 0) {
                alert('?? Debes seleccionar al menos un mob o jefe!');
                return;
            }

            // Set custom raid configuration
            MobRaidSystem.isCustomRaid = true;
            MobRaidSystem.customMobTypes = Array.from(customRaidSelectedMobs);
            MobRaidSystem.customBossTypes = Array.from(customRaidSelectedBosses);

            // Close modal and start raid directly (no info screen for custom raids)
            document.getElementById('custom-raid-modal').classList.add('hidden');

            // Start raid directly without info screen
            MobRaidSystem.actuallyStartRaid();

            console.log('?? Custom Raid configured:', {
                mobs: MobRaidSystem.customMobTypes,
                bosses: MobRaidSystem.customBossTypes,
                penalty: `${MobRaidSystem.customDropPenalty * 100}%`
            });
        });

        // ===== PLAYER STATUS EFFECTS RENDERER =====
        function renderPlayerStatusEffects(ctx) {
            const canvas = ctx.canvas;
            const effects = [];

            // Collect active positive effects
            if (Player.damageBoost > 0) {
                effects.push({
                    icon: '??',
                    name: 'Daño Aumentado',
                    value: `+${Player.damageBoost}%`,
                    color: '#ffbe0b',
                    time: Math.ceil(Player.damageBoostTime / 1000)
                });
            }

            if (Player.invisible) {
                effects.push({
                    icon: '?',
                    name: 'Invisible',
                    value: 'Invulnerable',
                    color: '#9d4edd',
                    time: Math.ceil(Player.invisibleTime / 1000)
                });
            } else if (Player.invulnerable) {
                effects.push({
                    icon: '???',
                    name: 'Invulnerable',
                    value: '',
                    color: '#00d9ff',
                    time: Math.ceil(Player.invulnerableTime / 1000)
                });
            }

            if (Player.counterActive) {
                effects.push({
                    icon: '??',
                    name: 'Contraataque',
                    value: '',
                    color: '#ff006e',
                    time: Math.ceil(Player.counterTime / 1000)
                });
            }

            if (Player.regenActive) {
                effects.push({
                    icon: '??',
                    name: 'Regeneración',
                    value: `+${Player.regenRate}/s`,
                    color: '#00ff88',
                    time: '8'
                });
            }

            // Collect active negative effects
            if (Player.electrified) {
                effects.push({
                    icon: '?',
                    name: 'Electrificado',
                    value: 'Aturdido',
                    color: '#ffff00',
                    time: Math.ceil(Player.electrifiedTime / 1000),
                    isNegative: true
                });
            }

            if (Player.hasActiveSlowEffect) {
                effects.push({
                    icon: '??',
                    name: 'Ralentizado',
                    value: '-30% Vel',
                    color: '#87ceeb',
                    time: '?',
                    isNegative: true
                });
            }

            if (Player.cursed && Date.now() < Player.curseEndTime) {
                const timeLeft = Math.ceil((Player.curseEndTime - Date.now()) / 1000);
                effects.push({
                    icon: '??',
                    name: 'MALDICIÓN',
                    value: 'x2 Daño',
                    color: '#9370DB',
                    time: timeLeft,
                    isNegative: true,
                    stacks: Player.curseStacks > 1 ? Player.curseStacks : null
                });
            }

            // Render effects at top center of screen
            if (effects.length > 0) {
                const effectWidth = 140;
                const effectHeight = 70;
                const effectSpacing = 10;
                const totalWidth = (effects.length * effectWidth) + ((effects.length - 1) * effectSpacing);
                const startX = (canvas.width - totalWidth) / 2;
                const startY = 100;

                effects.forEach((effect, index) => {
                    const x = startX + (index * (effectWidth + effectSpacing));
                    const y = startY;

                    // Background with pulsing animation
                    const pulse = 1 + Math.sin(Date.now() / 300) * 0.05;
                    ctx.save();
                    ctx.globalAlpha = 0.95;

                    // Background
                    const gradient = ctx.createLinearGradient(x, y, x, y + effectHeight);
                    if (effect.isNegative) {
                        gradient.addColorStop(0, 'rgba(255, 0, 0, 0.3)');
                        gradient.addColorStop(1, 'rgba(139, 0, 0, 0.3)');
                    } else {
                        gradient.addColorStop(0, 'rgba(0, 217, 255, 0.2)');
                        gradient.addColorStop(1, 'rgba(255, 0, 110, 0.2)');
                    }
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, effectWidth, effectHeight);

                    // Border with glow
                    ctx.strokeStyle = effect.color;
                    ctx.lineWidth = 2 * pulse;
                    ctx.shadowColor = effect.color;
                    ctx.shadowBlur = 15 * pulse;
                    ctx.strokeRect(x, y, effectWidth, effectHeight);
                    ctx.shadowBlur = 0;

                    // Icon
                    ctx.font = '32px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(effect.icon, x + effectWidth / 2, y + 8);

                    // Stacks (if applicable)
                    if (effect.stacks) {
                        ctx.font = 'bold 14px Arial';
                        ctx.fillStyle = '#ffffff';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 3;
                        ctx.textAlign = 'right';
                        ctx.strokeText(`x${effect.stacks}`, x + effectWidth - 8, y + 35);
                        ctx.fillText(`x${effect.stacks}`, x + effectWidth - 8, y + 35);
                    }

                    // Name
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = effect.color;
                    ctx.fillText(effect.name, x + effectWidth / 2, y + 42);

                    // Value and time
                    ctx.font = 'bold 10px Arial';
                    ctx.fillStyle = '#ffffff';
                    if (effect.value) {
                        ctx.fillText(effect.value, x + effectWidth / 2, y + 56);
                    }

                    // Time remaining (top right corner)
                    if (effect.time !== '8') {
                        ctx.font = 'bold 14px Arial';
                        ctx.fillStyle = effect.color;
                        ctx.textAlign = 'right';
                        ctx.fillText(`${effect.time}s`, x + effectWidth - 8, y + 8);
                    }

                    ctx.restore();
                });
            }
        }

        // ===== MINIMAP =====
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        function renderMinimap() {
            const mainCanvas = document.getElementById('game-canvas');
            const scaleX = minimapCanvas.width / mainCanvas.width;
            const scaleY = minimapCanvas.height / mainCanvas.height;

            minimapCtx.fillStyle = 'rgba(10, 14, 39, 0.8)';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            minimapCtx.strokeStyle = 'rgba(0, 217, 255, 0.3)';
            minimapCtx.strokeRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            // Player position
            const playerX = Player.x * scaleX;
            const playerY = Player.y * scaleY;

            const gradient = minimapCtx.createRadialGradient(playerX, playerY, 0, playerX, playerY, 8);
            gradient.addColorStop(0, '#00d9ff');
            gradient.addColorStop(1, '#ff006e');

            minimapCtx.fillStyle = gradient;
            minimapCtx.beginPath();
            minimapCtx.arc(playerX, playerY, 5, 0, Math.PI * 2);
            minimapCtx.fill();

            minimapCtx.strokeStyle = '#fff';
            minimapCtx.lineWidth = 2;
            minimapCtx.stroke();
        }

        // ===== GAME LOOP =====
        let lastTime = 0;
        let frameCount = 0;
        let fpsTime = 0;
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // Canvas click handler for practice mode controls
        canvas.addEventListener('click', (e) => {
            if (!PracticeModeManager.active) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            PracticeModeManager.handleCanvasClick(x, y);
        });

        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // FPS Counter
            frameCount++;
            fpsTime += deltaTime;
            if (fpsTime >= 1000) {
                document.getElementById('fps-counter').textContent = frameCount;
                frameCount = 0;
                fpsTime = 0;
            }

            // Update
            InputHandler.processMovement(deltaTime / 1000);
            InputHandler.processAbilityInputs();
            AbilityManager.updateCooldowns(deltaTime);
            EffectRenderer.updateEffects(deltaTime);
            Player.update(deltaTime);
            MobRaidSystem.update(deltaTime);
            PracticeModeManager.update(deltaTime);

            // Update mobile controls
            if (typeof MobileControlsSystem !== 'undefined') {
                MobileControlsSystem.update(deltaTime);
            }

            // Render
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Animated hexagonal grid
            ctx.strokeStyle = 'rgba(0, 217, 255, 0.08)';
            ctx.lineWidth = 1;
            const gridSize = 60;
            const offset = (currentTime / 60) % gridSize;

            for (let x = -offset; x < canvas.width + gridSize; x += gridSize) {
                for (let y = -offset; y < canvas.height + gridSize; y += gridSize) {
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const px = x + Math.cos(angle) * 20;
                        const py = y + Math.sin(angle) * 20;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
            }

            // Render game objects
            MobRaidSystem.render(ctx);
            Player.render(ctx);
            EffectRenderer.renderEffects(ctx);
            PracticeModeManager.render(ctx);

            // Render player status effects at top of screen
            renderPlayerStatusEffects(ctx);

            // Update minimap
            renderMinimap();

            requestAnimationFrame(gameLoop);
        }

        // ===== INITIALIZATION =====
        async function initGame() {
            const loadingScreen = document.getElementById('loading-screen');
            const loadingProgress = document.querySelector('.loading-progress');
            const loadingPercentage = document.querySelector('.loading-percentage');
            const loadingStatus = document.querySelector('.loading-status');
            // loadingParticles and loadingVideo are removed in new design

            // Generate Guardian Ancestral Icons immediately
            if (typeof IconGenerator !== 'undefined' && IconGenerator.generateAll) {
                IconGenerator.generateAll();
            }

            const loadingSteps = [
                { progress: 20, status: 'Inicializando...' },
                { progress: 40, status: 'Cargando perfiles...' },
                { progress: 60, status: 'Sincronizando habilidades...' },
                { progress: 80, status: 'Aplicando configuración...' },
                { progress: 100, status: 'Completado' }
            ];

            // Load saved progress
            ClassProgressionSystem.init();
            EquipmentManager.loadProgress();
            LoadoutManager.init();
            PracticeModeManager.loadPracticeSettings();

            // Update stats display after both systems have loaded
            EquipmentManager.updateStatsDisplay();

            // Track if loading is complete
            let loadingComplete = false;
            let videoEnded = false;

            // Animate loading with steps
            for (const step of loadingSteps) {
                const currentProgress = parseInt(loadingProgress.style.width) || 0;
                for (let i = currentProgress; i <= step.progress; i++) {
                    loadingProgress.style.width = `${i}%`;
                    loadingPercentage.textContent = `${i}%`;
                    await new Promise(resolve => setTimeout(resolve, 20));
                }
                loadingStatus.textContent = step.status;
                await new Promise(resolve => setTimeout(resolve, 300));
            }

            loadingComplete = true;

            // Video logic removed


            // Close loading screen
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
                requestAnimationFrame(gameLoop);
                console.log('⚔️ Wild Destiny - Ready!');
                console.log('✨ All characters are ORIGINAL - No copyright issues!');
                console.log('🏆 Loadout & Masteries System - Active!');
            }, 400);
        }

        // ===== RAID MANAGER =====
        const RaidManager = {
            raids: {
                'Dragonhunter': {
                    color: '#ff4400',
                    mobs: ['fire_drake', 'arcane_wisp', 'shadow_assassin'],
                    bosses: ['ancient_dragon'],
                    recommendedClasses: ['?? Dragonhunter', '?? Elemental Master'],
                    rewardTarget: 'class_dragonhunter'
                },
                'Elementalist': {
                    color: '#00d9ff',
                    mobs: ['water_elemental'],
                    bosses: ['storm_titan'],
                    recommendedClasses: ['?? Elementalist', '?? Aquamancer'],
                    rewardTarget: 'class_elementalist'
                },
                'Samurai': {
                    color: '#ff006e',
                    mobs: ['ronin_warrior'],
                    bosses: ['shogun_lord'],
                    recommendedClasses: ['?? Samurai', '?? Shadow Ninja'],
                    rewardTarget: 'class_samurai'
                },
                'Gunslinger': {
                    color: '#00ffff',
                    mobs: ['combat_drone'],
                    bosses: ['mech_titan'],
                    recommendedClasses: ['?? Cyber Gunslinger'],
                    rewardTarget: 'class_gunslinger'
                },
                'Mystic': {
                    color: '#9370db',
                    mobs: ['arcane_wisp'],
                    bosses: ['elder_sorcerer'],
                    recommendedClasses: ['? Mystic'],
                    rewardTarget: 'class_mystic'
                },
                'Wind Master': {
                    color: '#39ff14',
                    mobs: ['toxic_zephyr', 'radioactive_cyclone'],
                    bosses: ['tempest_lord'],
                    recommendedClasses: ['?? Wind Master'],
                    rewardTarget: 'class_wind_master'
                },
                'Wild Berserker': {
                    color: '#8b0000',
                    mobs: ['blood_reaver', 'axe_thrower'],
                    bosses: ['warlord_colossus'],
                    recommendedClasses: ['?? Wild Berserker'],
                    rewardTarget: 'class_berserker'
                },
                'Shadow Ninja': {
                    color: '#2f2f2f',
                    mobs: ['shadow_assassin', 'smoke_phantom'],
                    bosses: ['shadow_emperor'],
                    recommendedClasses: ['?? Shadow Ninja'],
                    rewardTarget: 'class_ninja'
                }
            },

            showRaidSelect() {
                // Determine if fonts are loaded (reuse logic from DungeonManager or just do it)
                const fontLink = document.createElement('link');
                fontLink.href = 'https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@300;400;500;600;700&family=Rajdhani:wght@300;400;500;600;700&display=swap';
                fontLink.rel = 'stylesheet';
                document.head.appendChild(fontLink);

                const infoScreen = document.createElement('div');
                infoScreen.id = 'raid-select-screen';

                // Reuse styles but change ID
                const style = document.createElement('style');
                style.textContent = `
                    #raid-select-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #050810; z-index: 10000; display: flex; font-family: 'Rajdhani', sans-serif; overflow: hidden; opacity: 0; transition: opacity 0.3s; }
                    #raid-select-screen.visible { opacity: 1; }
                    /* Use same classes as DungeonManager for consistency */
                `;
                // Since we are not actually reusing the css classes from DungeonManager globally (they are inside shadow dom or scoped?),
                // we should probably just use the same styles. I will copy the styles from DungeonManager but scope them to #raid-select-screen
                // For simplicity in this edit, I will assume the CSS from DungeonManager was added globally or I will add it again here.
                // Wait, styles in DungeonManager were added to the element, so they are effectively global if not shadow DOM.
                // Let's add the FULL style block again to be safe and independent.

                style.textContent = DungeonManager.getStyles().replace('#dungeon-select-screen', '#raid-select-screen');

                infoScreen.appendChild(style);

                const sidebar = document.createElement('div');
                sidebar.className = 'raid-sidebar';
                sidebar.innerHTML = `
                    <div class="raid-header-logo">
                        <h1>CLASS RAIDS</h1>
                        <p>Specialized Training</p>
                    </div>
                    <div class="raid-menu" id="raid-menu-list"></div>
                `;

                const mainArea = document.createElement('div');
                mainArea.className = 'raid-main';
                mainArea.innerHTML = `
                    <div class="close-btn" id="close-raid-ui">×</div>
                    <div class="mob-content-area" id="raid-content-area"></div>
                    <div class="raid-footer">
                        <div class="raid-info-text">
                            <span style="display:inline-block; width:8px; height:8px; background:#00d9ff; border-radius:50%; box-shadow:0 0 5px #00d9ff"></span>
                            SELECT A RAID
                        </div>
                        <button class="start-btn" id="start-raid-btn">
                            🚀 DEPLOY
                        </button>
                    </div>
                `;

                infoScreen.appendChild(sidebar);
                infoScreen.appendChild(mainArea);
                document.body.appendChild(infoScreen);

                setTimeout(() => infoScreen.classList.add('visible'), 10);

                // --- Logic --- //
                const menuList = sidebar.querySelector('#raid-menu-list');
                const contentArea = mainArea.querySelector('#raid-content-area');
                let currentCategory = Object.keys(this.raids)[0];

                const renderMenu = () => {
                    menuList.innerHTML = Object.keys(this.raids).map(raidName => {
                        const data = this.raids[raidName];
                        const firstMob = data.mobs[0];
                        const isActive = raidName === currentCategory;

                        return `
                            <div class="raid-menu-item ${isActive ? 'active' : ''}" data-category="${raidName}" style="color: ${data.color}">
                                <div class="raid-menu-icon" style="${isActive ? `background: ${data.color}; color: white;` : `color: ${data.color}; background: rgba(0,0,0,0.3);`}">
                                    <div>${IconRenderer.getIconHTML('mob_' + firstMob, 32)}</div>
                                </div>
                                <div class="raid-menu-info">
                                    <h3>${raidName}</h3>
                                    <p>${data.mobs.length} Types | ${data.bosses.length} Bosses</p>
                                </div>
                            </div>
                        `;
                    }).join('');

                    menuList.querySelectorAll('.raid-menu-item').forEach(item => {
                        item.addEventListener('click', () => {
                            currentCategory = item.getAttribute('data-category');
                            renderMenu();
                            renderContent();
                        });
                    });
                };

                const renderContent = () => {
                    const data = this.raids[currentCategory];
                    DungeonManager.renderSharedContent(contentArea, currentCategory, data);
                };

                // Helper to start
                const startBtn = mainArea.querySelector('#start-raid-btn');
                startBtn.addEventListener('click', () => {
                    // Fullscreen on canvas
                    const canvas = document.getElementById('game-canvas');
                    if (canvas && canvas.requestFullscreen) {
                        canvas.requestFullscreen().catch(e => console.log(e));
                    }

                    const data = this.raids[currentCategory];
                    const rewardMeta = DungeonManager.resolveRewardMeta(data);
                    infoScreen.classList.remove('visible');
                    setTimeout(() => infoScreen.remove(), 300);
                    MobRaidSystem.startDungeonRaid(currentCategory, data.mobs, data.bosses, {
                        rewardTarget: rewardMeta.targetId || null,
                        rewardName: rewardMeta.displayName || null,
                        rewardType: rewardMeta.typeLabel || null
                    }); // Reuse startDungeonRaid for now as logic is same
                });

                // Close
                const closeBtn = mainArea.querySelector('#close-raid-ui');
                closeBtn.addEventListener('click', () => {
                    infoScreen.classList.remove('visible');
                    setTimeout(() => infoScreen.remove(), 300);
                });

                renderMenu();
                renderContent();
            }
        };

        // ===== MOB RAID SYSTEM =====
        // NEW v2026: Dungeon Manager - Separated from MobRaidSystem
        const DungeonManager = {
            active: false,
            currentDungeon: null,

            // Shared styles helper
            getStyles() {
                return `
                    #dungeon-select-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #050810; z-index: 10000; display: flex; font-family: 'Rajdhani', sans-serif; overflow: hidden; opacity: 0; transition: opacity 0.3s; }
                    #dungeon-select-screen.visible { opacity: 1; }
                    .raid-sidebar { width: 300px; background: rgba(10, 15, 30, 0.95); border-right: 1px solid rgba(255, 255, 255, 0.1); display: flex; flex-direction: column; overflow-y: auto; backdrop-filter: blur(10px); }
                    .raid-header-logo { padding: 30px; border-bottom: 1px solid rgba(255, 255, 255, 0.05); text-align: center; }
                    .raid-header-logo h1 { font-family: 'Chakra Petch', sans-serif; font-size: 32px; margin: 0; background: linear-gradient(45deg, #00d9ff, #0056b3); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 700; letter-spacing: 2px; }
                    .raid-header-logo p { font-size: 10px; text-transform: uppercase; letter-spacing: 4px; color: rgba(255, 255, 255, 0.4); margin-top: 5px; }
                    .raid-menu { padding: 20px; flex: 1; }
                    .raid-menu-item { display: flex; align-items: center; padding: 15px; margin-bottom: 10px; border-radius: 8px; cursor: pointer; transition: all 0.2s; border: 1px solid transparent; }
                    .raid-menu-item:hover { background: rgba(255, 255, 255, 0.03); transform: translateX(5px); }
                    .raid-menu-item.active { background: linear-gradient(90deg, rgba(0, 217, 255, 0.1), transparent); border-left: 3px solid currentColor; }
                    .raid-menu-icon { width: 40px; height: 40px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 20px; margin-right: 15px; background: rgba(255, 255, 255, 0.05); }
                    .raid-menu-info h3 { margin: 0; font-size: 16px; font-weight: 600; text-transform: uppercase; }
                    .raid-menu-info p { margin: 3px 0 0; font-size: 11px; color: rgba(255, 255, 255, 0.4); }
                    .raid-main { flex: 1; display: flex; flex-direction: column; position: relative; background: radial-gradient(ellipse at top right, rgba(0, 217, 255, 0.05), transparent 70%); }
                    .close-btn { position: absolute; top: 20px; right: 20px; width: 40px; height: 40px; border-radius: 50%; background: rgba(255, 255, 255, 0.05); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; z-index: 10; border: 1px solid rgba(255, 255, 255, 0.1); }
                    .close-btn:hover { background: rgba(255, 0, 0, 0.2); border-color: rgba(255, 0, 0, 0.5); transform: rotate(90deg); }
                    .mob-content-area { flex: 1; padding: 40px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #00d9ff rgba(0,0,0,0.3); }
                    .raid-banner { padding: 40px; border-radius: 20px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.03), transparent); border: 1px solid rgba(255, 255, 255, 0.05); margin-bottom: 40px; position: relative; overflow: hidden; }
                    .raid-banner::before { content: ''; position: absolute; top: 0; left: 0; width: 4px; height: 100%; background: currentColor; box-shadow: 0 0 20px currentColor; }
                    .raid-banner h2 { font-family: 'Chakra Petch', sans-serif; font-size: 48px; margin: 0 0 20px; text-transform: uppercase; font-weight: 700; letter-spacing: 2px; text-shadow: 0 0 30px rgba(0,0,0,0.5); }
                    .raid-controls { display: flex; gap: 30px; padding-top: 20px; border-top: 1px solid; }
                    .raid-stat { display: flex; flex-direction: column; gap: 5px; }
                    .raid-stat span:first-child { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: rgba(255, 255, 255, 0.4); }
                    .raid-stat span:last-child { font-size: 16px; font-weight: 600; }
                    .section-divider { display: flex; align-items: center; gap: 20px; margin: 40px 0 20px; }
                    .section-line { flex: 1; height: 1px; background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent); }
                    .section-title { font-size: 14px; font-weight: 600; letter-spacing: 2px; color: #00d9ff; padding: 5px 15px; border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 20px; background: rgba(0, 217, 255, 0.05); }
                    .mobs-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px; }
                    .mob-card { background: rgba(255, 255, 255, 0.02); border: 1px solid rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 20px; transition: all 0.3s; position: relative; overflow: hidden; }
                    .mob-card:hover { transform: translateY(-5px); background: rgba(255, 255, 255, 0.05); border-color: currentColor; box-shadow: 0 10px 30px -10px rgba(0,0,0,0.5); }
                    .mob-card-icon { font-size: 48px; text-align: center; margin-bottom: 15px; filter: drop-shadow(0 0 10px currentColor); }
                    .mob-card h3 { text-align: center; margin: 0 0 15px; font-size: 18px; font-weight: 600; color: white; }
                    .mob-stats { background: rgba(0, 0, 0, 0.3); border-radius: 8px; padding: 10px; font-size: 12px; }
                    .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
                    .stat-row:last-child { margin-bottom: 0; }
                    .stat-label { color: rgba(255, 255, 255, 0.5); }
                    .ticket-badge { margin-top: 15px; padding: 8px; text-align: center; border: 1px solid; border-radius: 6px; font-size: 10px; font-weight: 700; letter-spacing: 1px; }
                    .boss-highlight { grid-column: span 2; display: grid; grid-template-columns: auto 1fr; gap: 20px; align-items: center; background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), transparent); border: 1px solid rgba(255, 215, 0, 0.2); }
                    .boss-highlight .mob-card-icon { font-size: 80px; margin: 0; }
                    .boss-highlight h3 { text-align: left; font-size: 24px; margin-bottom: 10px; }
                    .boss-highlight .mob-stats { grid-column: 2; }
                    .boss-highlight .ticket-badge { grid-column: 1 / -1; margin-top: 0; }
                    .boss-tag { position: absolute; top: 10px; right: 10px; background: #ffd700; color: black; font-size: 9px; font-weight: 900; padding: 2px 6px; border-radius: 4px; }
                    .raid-footer { padding: 20px 40px; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; justify-content: space-between; align-items: center; background: rgba(10, 15, 30, 0.9); }
                    .start-btn { padding: 15px 40px; background: linear-gradient(135deg, #00d9ff, #0056b3); border: none; border-radius: 8px; color: white; font-family: 'Chakra Petch', sans-serif; font-weight: 700; font-size: 18px; letter-spacing: 2px; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; gap: 10px; text-transform: uppercase; box-shadow: 0 0 20px rgba(0, 217, 255, 0.3); }
                    .start-btn:hover { transform: scale(1.05); box-shadow: 0 0 40px rgba(0, 217, 255, 0.5); }
                    .start-btn svg { width: 24px; height: 24px; }
                    .raid-info-text { font-size: 12px; color: rgba(255, 255, 255, 0.5); letter-spacing: 2px; display: flex; align-items: center; gap: 10px; }
                    .rec-classes { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 20px; }
                    .rec-tag { font-size: 10px; padding: 4px 8px; border: 1px solid; border-radius: 4px; font-weight: 600; }
                `;
            },

            dungeons: {
                'Ancient Ruins': {
                    color: '#8B7355',
                    mobs: ['stone_golem', 'ancient_sentinel'],
                    bosses: ['taurha_giant'],
                    recommendedClasses: ['⛏️ Ancient Guardian'],
                    rewardTarget: 'ancient-guardian',
                    rewardName: 'Taurha'
                },
                'Dragon\'s Cave': {
                    color: '#ff4400',
                    mobs: ['fire_drake'],
                    bosses: ['ancient_dragon'],
                    recommendedClasses: ['🐲 Dragonhunter'],
                    rewardTarget: 'class_dragonhunter'
                },
                'Elemental Crucible': {
                    color: '#00c2ff',
                    mobs: ['water_elemental', 'prism_wisp', 'frostbound_sentinel', 'magma_golem'],
                    bosses: ['storm_archon', 'crystal_hydra'],
                    recommendedClasses: ['🌊 Elementalist', '🔮 Mystic Sage'],
                    rewardTarget: 'class_elementalist',
                    isMultiBossDungeon: true,
                    bossCount: 2,
                    bossOrder: ['storm_archon', 'crystal_hydra']
                },
                'Anubis Tomb': {
                    color: '#FFD700',
                    mobs: ['anubis_jackal', 'anubis_mummy', 'anubis_sphinx'],
                    bosses: ['anubis_pharaoh', 'anubis_colossus', 'anubis_avatar'],
                    recommendedClasses: ['☥ Anubis'],
                    rewardTarget: 'class_anubis',
                    // Multi-boss dungeon: Must defeat ALL 3 bosses to complete
                    isMultiBossDungeon: true,
                    bossCount: 3,
                    bossOrder: ['anubis_pharaoh', 'anubis_colossus', 'anubis_avatar']
                },
                'Mystic Sanctum': {
                    color: '#9370DB',
                    mobs: ['arcane_wisp', 'elder_sorcerer'],
                    bosses: ['aether_dragon'],
                    recommendedClasses: ['🔮 Mystic Sage', '✨ Elementalist'],
                    rewardTarget: 'class_mystic'
                },
                'Shadow Realm': {
                    color: '#2F2F2F',
                    mobs: ['shadow_assassin', 'smoke_phantom'],
                    bosses: ['shadow_emperor'],
                    recommendedClasses: ['🥷 Shadow Ninja', '🌑 Abyssal Shadowlord'],
                    rewardTarget: 'class_ninja'
                },
                'Storm Citadel': {
                    color: '#00BFFF',
                    mobs: ['toxic_zephyr', 'radioactive_cyclone'],
                    bosses: ['tempest_lord', 'storm_titan'],
                    recommendedClasses: ['🌪️ Wind Master', '⚡ Tornado Overlord'],
                    rewardTarget: 'class_wind_master',
                    isMultiBossDungeon: true,
                    bossCount: 2,
                    bossOrder: ['tempest_lord', 'storm_titan']
                },
                'Berserker Pit': {
                    color: '#8B0000',
                    mobs: ['blood_reaver', 'axe_thrower'],
                    bosses: ['warlord_colossus'],
                    recommendedClasses: ['👹 Wild Berserker', '🪓 Titan Crusher'],
                    rewardTarget: 'class_berserker'
                },
                'Samurai Fortress': {
                    color: '#DC143C',
                    mobs: ['ronin_warrior'],
                    bosses: ['shogun_lord'],
                    recommendedClasses: ['⚔️ Ronin Samurai', '🏯 Shogun Master'],
                    rewardTarget: 'class_samurai'
                }
            },

            resolveRewardMeta(data) {
                const targetId = data?.rewardTarget || null;
                const explicitName = data?.rewardName || null;
                if (!targetId) {
                    return { targetId: null, displayName: 'Tickets Aleatorios', typeLabel: 'General' };
                }

                const role = [...(rolesData.classes || []), ...(rolesData.characters || []), ...(rolesData.fruits || [])]
                    .find(r => r.id === targetId);
                if (role) {
                    const typeLabel = role.type === 'fruit'
                        ? 'Fruta'
                        : ((role.type === 'class' || role.type === 'master_class') ? 'Clase' : 'Personaje');
                    return { targetId, displayName: explicitName || role.name, typeLabel };
                }

                const fallback = explicitName || targetId
                    .replace(/^class_/, '')
                    .replace(/[-_]+/g, ' ')
                    .replace(/\b\w/g, c => c.toUpperCase());
                return { targetId, displayName: fallback, typeLabel: 'Objetivo' };
            },

            // Shared content renderer for both Raids and Dungeons
            renderSharedContent(contentArea, categoryName, data) {
                const bannerColor = data.color;
                const rewardMeta = this.resolveRewardMeta(data);
                const recClassesHTML = data.recommendedClasses ? `
                     <div class="rec-classes">
                         ${data.recommendedClasses.map(cls => `<span class="rec-tag" style="color:${bannerColor}; border-color:${bannerColor}; background:rgba(0,0,0,0.2)">${cls}</span>`).join('')}
                     </div>
                ` : '';

                let html = `
                     <div class="class-raid-section">
                         <div class="raid-banner" style="color: ${bannerColor}">
                             <h2>${categoryName}</h2>
                             <div class="raid-controls" style="border-color: ${bannerColor}">
                                 <div class="raid-stat">
                                     <span>Difficulty</span>
                                     <span style="color: #ffbe0b">★★★★★</span>
                                 </div>
                                 <div class="raid-stat">
                                     <span>Target Drops</span>
                                     <span style="color: ${bannerColor}">${rewardMeta.displayName} (${rewardMeta.typeLabel})</span>
                                 </div>
                                 <div class="raid-stat">
                                     <span>Structure</span>
                                     <span>Waves + Boss</span>
                                 </div>
                             </div>
                             ${recClassesHTML}
                         </div>
                `;

                // Add Mobs Section
                if (data.mobs && data.mobs.length > 0) {
                    html += `
                        <div class="section-divider">
                            <span class="section-line"></span>
                            <span class="section-title">HOSTILES</span>
                            <span class="section-line"></span>
                        </div>
                        <div class="mobs-grid">
                            ${data.mobs.map(mob => `
                                <div class="mob-card" style="color: ${bannerColor}">
                                    <div class="mob-card-icon">${IconRenderer.getIconHTML('mob_' + mob, 48)}</div>
                                    <h3>${mob.replace(/_/g, ' ').toUpperCase()}</h3>
                                    <div class="mob-stats">
                                        <div class="stat-row"><span class="stat-label">HP</span> <span>High</span></div>
                                        <div class="stat-row"><span class="stat-label">DMG</span> <span>Mod</span></div>
                                    </div>
                                    <div class="ticket-badge" style="border-color:${bannerColor}">DROPS: ${rewardMeta.displayName}</div>
                                </div>
                            `).join('')}
                        </div>
                     `;
                }

                // Add Bosses Section
                if (data.bosses && data.bosses.length > 0) {
                    html += `
                        <div class="section-divider">
                            <span class="section-line"></span>
                            <span class="section-title">BOSS THREATS</span>
                            <span class="section-line"></span>
                        </div>
                        <div class="mobs-grid">
                            ${data.bosses.map(boss => `
                                <div class="mob-card boss-highlight" style="color: #ffd700">
                                    <div class="boss-tag">BOSS</div>
                                    <div class="mob-card-icon">${IconRenderer.getIconHTML('mob_' + boss, 64)}</div>
                                    <div>
                                        <h3>${boss.replace(/_/g, ' ').toUpperCase()}</h3>
                                        <div class="mob-stats">
                                            <div class="stat-row"><span class="stat-label">HP</span> <span>Extreme</span></div>
                                            <div class="stat-row"><span class="stat-label">Ability</span> <span>Lethal</span></div>
                                        </div>
                                    </div>
                                    <div class="ticket-badge" style="border-color:#ffd700; color:#ffd700">OBJECTIVE DROP: ${rewardMeta.displayName}</div>
                                </div>
                            `).join('')}
                        </div>
                     `;
                }

                html += `</div>`; // Close class-raid-section
                contentArea.innerHTML = html;
            },

            showDungeonSelect() {
                const fontLink = document.createElement('link');
                fontLink.href = 'https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@300;400;500;600;700&family=Rajdhani:wght@300;400;500;600;700&display=swap';
                fontLink.rel = 'stylesheet';
                document.head.appendChild(fontLink);

                const infoScreen = document.createElement('div');
                infoScreen.id = 'dungeon-select-screen';

                // Fix ReferenceError: create style element first
                const style = document.createElement('style');
                style.textContent = this.getStyles();
                infoScreen.appendChild(style);

                const sidebar = document.createElement('div');
                sidebar.className = 'raid-sidebar';
                sidebar.innerHTML = `
                    <div class="raid-header-logo">
                        <h1>DUNGEON OPS</h1>
                        <p>Specific Threats</p>
                    </div>
                    <div class="raid-menu" id="dungeon-menu-list"></div>
                `;

                const mainArea = document.createElement('div');
                mainArea.className = 'raid-main';
                mainArea.innerHTML = `
                    <div class="close-btn" id="close-dungeon-ui">×</div>
                    <div class="mob-content-area" id="dungeon-content-area"></div>
                    <div class="raid-footer">
                        <div class="raid-info-text">
                            <span style="display:inline-block; width:8px; height:8px; background:#00ff00; border-radius:50%; box-shadow:0 0 5px #00ff00"></span>
                            SELECT A DUNGEON
                        </div>
                        <button class="start-btn" id="start-dungeon-btn">
                            🚀 START MISSION
                        </button>
                    </div>
                `;

                infoScreen.appendChild(sidebar);
                infoScreen.appendChild(mainArea);
                document.body.appendChild(infoScreen);

                setTimeout(() => infoScreen.classList.add('visible'), 10);

                // --- Logic --- //
                const menuList = sidebar.querySelector('#dungeon-menu-list');
                const contentArea = mainArea.querySelector('#dungeon-content-area');
                let currentCategory = Object.keys(this.dungeons)[0];

                const renderMenu = () => {
                    menuList.innerHTML = Object.keys(this.dungeons).map(dungeonName => {
                        const data = this.dungeons[dungeonName];
                        const firstMob = data.mobs[0];
                        const isActive = dungeonName === currentCategory;

                        return `
                            <div class="raid-menu-item ${isActive ? 'active' : ''}" data-category="${dungeonName}" style="color: ${data.color}">
                                <div class="raid-menu-icon" style="${isActive ? `background: ${data.color}; color: white;` : `color: ${data.color}; background: rgba(0,0,0,0.3);`}">
                                    <div>${IconRenderer.getIconHTML('mob_' + firstMob, 32)}</div>
                                </div>
                                <div class="raid-menu-info">
                                    <h3>${dungeonName}</h3>
                                    <p>${data.mobs.length} Hostiles | ${data.bosses.length} Bosses</p>
                                </div>
                            </div>
                        `;
                    }).join('');

                    menuList.querySelectorAll('.raid-menu-item').forEach(item => {
                        item.addEventListener('click', () => {
                            currentCategory = item.getAttribute('data-category');
                            renderMenu();
                            renderContent();
                        });
                    });
                };

                const renderContent = () => {
                    const data = this.dungeons[currentCategory];
                    this.renderSharedContent(contentArea, currentCategory, data);
                };

                // Helper to start
                const startBtn = mainArea.querySelector('#start-dungeon-btn');
                startBtn.addEventListener('click', () => {
                    // Start logic
                    infoScreen.classList.remove('visible');
                    setTimeout(() => infoScreen.remove(), 300);

                    // Fullscreen on canvas
                    const canvas = document.getElementById('game-canvas');
                    if (canvas && canvas.requestFullscreen) {
                        canvas.requestFullscreen().catch(e => console.log(e));
                    }

                    const data = this.dungeons[currentCategory];
                    MobRaidSystem.isCustomRaid = true;
                    MobRaidSystem.customMobTypes = data.mobs || [];
                    MobRaidSystem.customBossTypes = data.bosses || [];
                    MobRaidSystem.selectedRaidName = currentCategory;
                    const rewardMeta = this.resolveRewardMeta(data);
                    MobRaidSystem.selectedDropTarget = rewardMeta.targetId;
                    MobRaidSystem.selectedRewardName = rewardMeta.displayName;
                    MobRaidSystem.selectedRewardType = rewardMeta.typeLabel;

                    // Initialize multi-boss tracking
                    MobRaidSystem.defeatedBosses = [];

                    // Check if this is a multi-boss dungeon
                    if (data.isMultiBossDungeon) {
                        MobRaidSystem.isMultiBossDungeon = true;
                        MobRaidSystem.multiBossOrder = data.bossOrder || [];
                        MobRaidSystem.totalBossCount = data.bossCount || data.bosses.length;
                        console.log(`🏰 Starting Multi-Boss Dungeon: ${currentCategory} (${data.bossCount} bosses)`);
                    } else {
                        MobRaidSystem.isMultiBossDungeon = false;
                    }

                    MobRaidSystem.actuallyStartRaid();
                });

                // Close
                const closeBtn = mainArea.querySelector('#close-dungeon-ui');
                closeBtn.addEventListener('click', () => {
                    infoScreen.classList.remove('visible');
                    setTimeout(() => infoScreen.remove(), 300);
                });

                renderMenu();
                renderContent();
            }
        };


        // ==========================================
        // ICON GENERATOR SYSTEM
        // ==========================================
        const IconGenerator = {
            createIcon: function (type) {
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');

                // Background
                const grad = ctx.createRadialGradient(50, 50, 0, 50, 50, 70);
                grad.addColorStop(0, '#2a2a2a');
                grad.addColorStop(1, '#000000');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 100, 100);

                // Border
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, 100, 100);

                ctx.translate(50, 50);

                if (type === 'guardian_glyph') {
                    // Golden Hexagram
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#DAA520';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 / 6) * i;
                        const x = Math.cos(angle) * 30;
                        const y = Math.sin(angle) * 30;
                        const x2 = Math.cos(angle + Math.PI * 2 / 3) * 30;
                        const y2 = Math.sin(angle + Math.PI * 2 / 3) * 30;
                        ctx.moveTo(x, y);
                        ctx.lineTo(x2, y2);
                    }
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(0, 0, 35, 0, Math.PI * 2);
                    ctx.stroke();
                }
                else if (type === 'guardian_hurl') {
                    // Flying Stone
                    ctx.rotate(Math.PI / 4);
                    ctx.fillStyle = '#8B4513';
                    ctx.shadowColor = '#000';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.moveTo(-15, -20);
                    ctx.lineTo(15, -15);
                    ctx.lineTo(20, 20);
                    ctx.lineTo(-20, 15);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#DAA520';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    // Trail
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.beginPath();
                    ctx.moveTo(-20, 15);
                    ctx.lineTo(-40, 40);
                    ctx.lineTo(-10, 25);
                    ctx.fill();
                }
                else if (type === 'guardian_tablets') {
                    // 3 Orbiting Tablets
                    ctx.shadowColor = '#F4A460';
                    ctx.shadowBlur = 8;
                    for (let i = 0; i < 3; i++) {
                        ctx.save();
                        ctx.rotate((Math.PI * 2 / 3) * i - Math.PI / 6);
                        ctx.translate(0, -25);
                        ctx.fillStyle = '#F4A460';
                        ctx.fillRect(-8, -12, 16, 24);
                        ctx.fillStyle = '#8B0000';
                        ctx.fillText('?', -3, 3);
                        ctx.restore();
                    }
                    ctx.strokeStyle = 'rgba(244, 164, 96, 0.3)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 25, 0, Math.PI * 2);
                    ctx.stroke();
                }
                else if (type === 'guardian_burrow') {
                    // Mound
                    ctx.translate(0, 10);
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, Math.PI, 0);
                    ctx.fill();
                    // Particles
                    ctx.fillStyle = '#DAA520';
                    for (let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        ctx.arc((Math.random() - 0.5) * 50, -10 - Math.random() * 20, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                else if (type === 'guardian_construct') {
                    // Mech Head/Icon
                    ctx.fillStyle = '#556B2F'; // Mossy Green
                    ctx.beginPath();
                    ctx.moveTo(-20, -10);
                    ctx.lineTo(20, -10);
                    ctx.lineTo(15, 20);
                    ctx.lineTo(0, 30);
                    ctx.lineTo(-15, 20);
                    ctx.closePath();
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#00FF00';
                    ctx.shadowColor = '#00FF00';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(-10, 0, 6, 6);
                    ctx.fillRect(4, 0, 6, 6);
                }
                else if (type === 'guardian_worldbreaker') {
                    // Cracked Earth
                    ctx.fillStyle = '#2a1a10';
                    ctx.fillRect(-45, -45, 90, 90);
                    // Magma cracks
                    ctx.strokeStyle = '#FF4500';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#FF0000';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(-30, -30);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(30, -20);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-10, 30);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(25, 25);
                    ctx.stroke();
                }

                return canvas.toDataURL('image/png');
            },

            generateAll: function () {
                console.log('Starting Guardian Ancestral Icon Generation...');

                // 1. Define Drawing Functions Locally (Self-Contained Source of Truth)
                const renderers = {
                    'guardian_glyph': (ctx, s) => {
                        const c = s / 2;
                        ctx.strokeStyle = '#FFD700';
                        ctx.lineWidth = s * 0.06;
                        // Manual Glow implementation since helpers might be unavailable depending on scope
                        ctx.shadowColor = '#DAA520';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        const r = s * 0.35;
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI * 2 / 6) * i;
                            const x = c + Math.cos(angle) * r;
                            const y = c + Math.sin(angle) * r;
                            const x2 = c + Math.cos(angle + Math.PI * 2 / 3) * r;
                            const y2 = c + Math.sin(angle + Math.PI * 2 / 3) * r;
                            ctx.moveTo(x, y);
                            ctx.lineTo(x2, y2);
                        }
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(c, c, r * 1.2, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0; // Clear glow
                    },
                    'guardian_hurl': (ctx, s) => {
                        const c = s / 2;
                        ctx.save();
                        ctx.translate(c, c);
                        ctx.rotate(Math.PI / 4);
                        // Stone projectile
                        ctx.fillStyle = '#8B4513';
                        ctx.shadowColor = '#000';
                        ctx.shadowBlur = 5;
                        ctx.beginPath();
                        ctx.moveTo(-s * 0.15, -s * 0.2);
                        ctx.lineTo(s * 0.15, -s * 0.15);
                        ctx.lineTo(s * 0.2, s * 0.2);
                        ctx.lineTo(-s * 0.2, s * 0.15);
                        ctx.closePath();
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        // Gold cracks
                        ctx.strokeStyle = '#DAA520';
                        ctx.lineWidth = s * 0.04;
                        ctx.stroke();
                        // Trail
                        ctx.fillStyle = 'rgba(255,255,255,0.2)';
                        ctx.beginPath();
                        ctx.moveTo(-s * 0.2, s * 0.15);
                        ctx.lineTo(-s * 0.4, s * 0.4);
                        ctx.lineTo(-s * 0.1, s * 0.25);
                        ctx.fill();
                        ctx.restore();
                    },
                    'guardian_tablets': (ctx, s) => {
                        const c = s / 2;
                        ctx.shadowColor = '#F4A460';
                        ctx.shadowBlur = 8;
                        for (let i = 0; i < 3; i++) {
                            ctx.save();
                            ctx.translate(c, c);
                            ctx.rotate((Math.PI * 2 / 3) * i - Math.PI / 6);
                            ctx.translate(0, -s * 0.25);
                            // Tablet
                            ctx.fillStyle = '#F4A460';
                            ctx.fillRect(-s * 0.08, -s * 0.12, s * 0.16, s * 0.24);
                            // Rune
                            ctx.fillStyle = '#8B0000';
                            ctx.font = 'bold ' + (s * 0.15) + 'px serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('?', 0, 0);
                            ctx.restore();
                        }
                        // Center aura
                        ctx.strokeStyle = 'rgba(244, 164, 96, 0.5)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(c, c, s * 0.35, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    },
                    'guardian_burrow': (ctx, s) => {
                        const c = s / 2;
                        // Mound
                        ctx.fillStyle = '#8B4513';
                        ctx.beginPath();
                        ctx.arc(c, c + s * 0.1, s * 0.3, Math.PI, 0);
                        ctx.fill();
                        // Particles
                        ctx.fillStyle = '#DAA520';
                        for (let i = 0; i < 5; i++) {
                            ctx.beginPath();
                            ctx.arc(c + (Math.random() - 0.5) * s * 0.5, c - s * 0.1 - Math.random() * s * 0.2, s * 0.02, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    },
                    'guardian_construct': (ctx, s) => {
                        const c = s / 2;
                        // Mech Head/Helmet
                        ctx.fillStyle = '#556B2F';
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.2, c - s * 0.1);
                        ctx.lineTo(c + s * 0.2, c - s * 0.1);
                        ctx.lineTo(c + s * 0.15, c + s * 0.2);
                        ctx.lineTo(c, c + s * 0.3);
                        ctx.lineTo(c - s * 0.15, c + s * 0.2);
                        ctx.closePath();
                        ctx.fill();
                        // Eyes
                        ctx.shadowColor = '#00FF00';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#00FF00';
                        ctx.fillRect(c - s * 0.1, c, s * 0.06, s * 0.06);
                        ctx.fillRect(c + s * 0.04, c, s * 0.06, s * 0.06);
                        ctx.shadowBlur = 0;
                    },
                    'guardian_worldbreaker': (ctx, s) => {
                        const c = s / 2;
                        // Cracked Earth Background
                        ctx.fillStyle = '#2a1a10';
                        ctx.fillRect(0, 0, s, s);
                        // Magma cracks
                        ctx.shadowColor = '#FF0000';
                        ctx.shadowBlur = 10;
                        ctx.strokeStyle = '#FF4500';
                        ctx.lineWidth = s * 0.05;
                        ctx.beginPath();
                        ctx.moveTo(s * 0.2, s * 0.2);
                        ctx.lineTo(c, c);
                        ctx.lineTo(s * 0.8, s * 0.3);
                        ctx.moveTo(c, c);
                        ctx.lineTo(s * 0.4, s * 0.8);
                        ctx.moveTo(c, c);
                        ctx.lineTo(s * 0.75, s * 0.75);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    },
                    'anubis_judgment': (ctx, s) => {
                        const c = s / 2;
                        ctx.fillStyle = '#09070f';
                        ctx.fillRect(0, 0, s, s);
                        ctx.strokeStyle = '#ffd166';
                        ctx.lineWidth = s * 0.05;
                        ctx.shadowColor = '#ffd166';
                        ctx.shadowBlur = 14;
                        ctx.beginPath();
                        ctx.moveTo(c, s * 0.2);
                        ctx.lineTo(c, s * 0.75);
                        ctx.moveTo(s * 0.26, s * 0.36);
                        ctx.lineTo(s * 0.74, s * 0.36);
                        ctx.stroke();
                        for (let i = -1; i <= 1; i += 2) {
                            ctx.beginPath();
                            ctx.arc(c + i * s * 0.17, s * 0.5, s * 0.08, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        ctx.shadowBlur = 0;
                    },
                    'anubis_sandstorm': (ctx, s) => {
                        const c = s / 2;
                        const g = ctx.createRadialGradient(c, c, 0, c, c, s * 0.55);
                        g.addColorStop(0, '#f7d08a');
                        g.addColorStop(1, '#3b2a1d');
                        ctx.fillStyle = '#0b0a12';
                        ctx.fillRect(0, 0, s, s);
                        ctx.strokeStyle = g;
                        ctx.lineWidth = s * 0.08;
                        ctx.shadowColor = '#f7d08a';
                        ctx.shadowBlur = 16;
                        ctx.beginPath();
                        ctx.arc(c, c, s * 0.28, 0, Math.PI * 2);
                        ctx.stroke();
                        for (let i = 0; i < 18; i++) {
                            const a = (Math.PI * 2 / 18) * i;
                            const r = s * (0.14 + (i % 3) * 0.07);
                            ctx.beginPath();
                            ctx.arc(c + Math.cos(a) * r, c + Math.sin(a) * r, s * 0.02, 0, Math.PI * 2);
                            ctx.fillStyle = '#d9b06d';
                            ctx.fill();
                        }
                        ctx.shadowBlur = 0;
                    },
                    'anubis_jackal': (ctx, s) => {
                        const c = s / 2;
                        ctx.fillStyle = '#0a0710';
                        ctx.fillRect(0, 0, s, s);
                        ctx.fillStyle = '#20162e';
                        ctx.beginPath();
                        ctx.moveTo(c, s * 0.14);
                        ctx.lineTo(c + s * 0.24, s * 0.34);
                        ctx.lineTo(c + s * 0.18, s * 0.78);
                        ctx.lineTo(c - s * 0.18, s * 0.78);
                        ctx.lineTo(c - s * 0.24, s * 0.34);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#f7d08a';
                        ctx.beginPath();
                        ctx.moveTo(c - s * 0.16, s * 0.34);
                        ctx.lineTo(c - s * 0.26, s * 0.1);
                        ctx.lineTo(c - s * 0.07, s * 0.28);
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(c + s * 0.16, s * 0.34);
                        ctx.lineTo(c + s * 0.26, s * 0.1);
                        ctx.lineTo(c + s * 0.07, s * 0.28);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#00e5ff';
                        ctx.shadowColor = '#00e5ff';
                        ctx.shadowBlur = 12;
                        ctx.beginPath();
                        ctx.arc(c - s * 0.08, s * 0.46, s * 0.035, 0, Math.PI * 2);
                        ctx.arc(c + s * 0.08, s * 0.46, s * 0.035, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    },
                    'anubis_ankh': (ctx, s) => {
                        const c = s / 2;
                        ctx.fillStyle = '#0a0c12';
                        ctx.fillRect(0, 0, s, s);
                        ctx.strokeStyle = '#00d3d9';
                        ctx.lineWidth = s * 0.06;
                        ctx.shadowColor = '#00d3d9';
                        ctx.shadowBlur = 18;
                        ctx.beginPath();
                        ctx.arc(c, s * 0.28, s * 0.14, 0, Math.PI * 2);
                        ctx.moveTo(c, s * 0.42);
                        ctx.lineTo(c, s * 0.78);
                        ctx.moveTo(c - s * 0.18, s * 0.58);
                        ctx.lineTo(c + s * 0.18, s * 0.58);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    },
                    'anubis_plague': (ctx, s) => {
                        const c = s / 2;
                        ctx.fillStyle = '#080b07';
                        ctx.fillRect(0, 0, s, s);
                        ctx.strokeStyle = '#84cc16';
                        ctx.lineWidth = s * 0.04;
                        ctx.shadowColor = '#84cc16';
                        ctx.shadowBlur = 12;
                        ctx.beginPath();
                        for (let i = 0; i < 8; i++) {
                            const a = (Math.PI * 2 / 8) * i;
                            const r1 = s * 0.18;
                            const r2 = s * 0.33;
                            ctx.moveTo(c + Math.cos(a) * r1, c + Math.sin(a) * r1);
                            ctx.lineTo(c + Math.cos(a) * r2, c + Math.sin(a) * r2);
                        }
                        ctx.stroke();
                        ctx.fillStyle = '#a3e635';
                        ctx.beginPath();
                        ctx.arc(c, c, s * 0.09, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    },
                    'anubis_underworld': (ctx, s) => {
                        const c = s / 2;
                        ctx.fillStyle = '#06040d';
                        ctx.fillRect(0, 0, s, s);
                        const portal = ctx.createRadialGradient(c, c, s * 0.04, c, c, s * 0.45);
                        portal.addColorStop(0, '#1b0f2e');
                        portal.addColorStop(0.5, '#0f0a1d');
                        portal.addColorStop(1, '#000000');
                        ctx.fillStyle = portal;
                        ctx.beginPath();
                        ctx.arc(c, c, s * 0.36, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#ffd166';
                        ctx.lineWidth = s * 0.05;
                        ctx.shadowColor = '#ffd166';
                        ctx.shadowBlur = 18;
                        ctx.beginPath();
                        ctx.arc(c, c, s * 0.36, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.fillStyle = '#ffd166';
                        ctx.font = `bold ${Math.floor(s * 0.2)}px serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('D', c, c);
                        ctx.shadowBlur = 0;
                    }
                };

                // 2. Inject into IconRenderer (Runtime Fix for Placeholders)
                if (typeof IconRenderer !== 'undefined' && IconRenderer.icons) {
                    Object.assign(IconRenderer.icons, renderers);
                    // Clear cache to force redraw
                    if (IconRenderer.cache) IconRenderer.cache = {};
                    console.log('Injected Guardian Renderers into IconRenderer directly.');
                }

                // 3. Generate Data URLs for strict image requirements (Shop/Loadout)
                const generatedIcons = {};
                const size = 128;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');

                Object.keys(renderers).forEach(key => {
                    ctx.clearRect(0, 0, size, size);
                    renderers[key](ctx, size);
                    generatedIcons[key] = canvas.toDataURL('image/png');
                });

                // 4. Update role data (Guardian + Anubis)
                const applyGuardianIcons = (role) => {
                    if (!role || role.id !== 'ancient-guardian') return;
                    if (role.abilities) {
                        role.abilities[0].iconImage = generatedIcons['guardian_glyph'];
                        role.abilities[0].effectId = 'guardian_glyph';
                        role.abilities[1].iconImage = generatedIcons['guardian_hurl'];
                        role.abilities[1].effectId = 'guardian_hurl';
                        role.abilities[2].iconImage = generatedIcons['guardian_tablets'];
                        role.abilities[2].effectId = 'guardian_tablets';
                        role.abilities[3].iconImage = generatedIcons['guardian_burrow'];
                        role.abilities[3].effectId = 'guardian_burrow';
                    }
                    if (role.semiUltimate) {
                        role.semiUltimate.iconImage = generatedIcons['guardian_construct'];
                        role.semiUltimate.effectId = 'guardian_construct';
                    }
                    if (role.ultimateAbility) {
                        role.ultimateAbility.iconImage = generatedIcons['guardian_worldbreaker'];
                        role.ultimateAbility.effectId = 'guardian_worldbreaker';
                    }
                };

                const applyAnubisIcons = (role) => {
                    if (!role || role.id !== 'class_anubis') return;
                    if (role.abilities) {
                        role.abilities[0].iconImage = generatedIcons['anubis_judgment'];
                        role.abilities[0].effectId = 'anubis_judgment';
                        role.abilities[1].iconImage = generatedIcons['anubis_sandstorm'];
                        role.abilities[1].effectId = 'anubis_sandstorm';
                        role.abilities[2].iconImage = generatedIcons['anubis_jackal'];
                        role.abilities[2].effectId = 'anubis_jackal';
                        role.abilities[3].iconImage = generatedIcons['anubis_ankh'];
                        role.abilities[3].effectId = 'anubis_ankh';
                    }
                    if (role.semiUltimate) {
                        role.semiUltimate.iconImage = generatedIcons['anubis_plague'];
                        role.semiUltimate.effectId = 'anubis_plague';
                    }
                    if (role.ultimateAbility) {
                        role.ultimateAbility.iconImage = generatedIcons['anubis_underworld'];
                        role.ultimateAbility.effectId = 'anubis_underworld';
                    }
                };

                const patchAllRoleSources = () => {
                    if (typeof rolesData !== 'undefined') {
                        const guardianRole = (rolesData.classes || []).find(c => c.id === 'ancient-guardian');
                        const anubisRole = (rolesData.classes || []).find(c => c.id === 'class_anubis');
                        applyGuardianIcons(guardianRole);
                        applyAnubisIcons(anubisRole);
                    }
                    if (typeof Game !== 'undefined' && Game.characters) {
                        applyGuardianIcons(Game.characters.find(c => c.id === 'ancient-guardian'));
                        applyAnubisIcons(Game.characters.find(c => c.id === 'class_anubis'));
                    }
                    if (typeof Player !== 'undefined' && Player.equippedRole) {
                        applyGuardianIcons(Player.equippedRole);
                        applyAnubisIcons(Player.equippedRole);
                        if (Player.updateAbilityBar) Player.updateAbilityBar();
                        if (Player.updateEquipmentUI) Player.updateEquipmentUI();
                    }
                };

                patchAllRoleSources();
                console.log('Guardian + Anubis icons regenerated and injected.');
            }
        };

        var MobRaidSystem = {
            active: false,
            paused: false,
            mobs: [],
            bosses: [],
            projectiles: [],
            wave: 0,
            score: 0,
            isCustomRaid: false,
            customMobTypes: [],
            customBossTypes: [],
            customDropPenalty: 0.05, // 5% penalty (reduced from 10%)
            selectedDropTarget: null,
            selectedRewardName: null,
            selectedRewardType: null,
            // Multi-boss dungeon properties
            isMultiBossDungeon: false,
            multiBossOrder: [],
            totalBossCount: 0,
            defeatedBosses: [],
            isSpawningNextBoss: false,
            // NEW v19.11.2025: Attack Indicators System (Telegraphing)
            attackIndicators: [],

            mobTypes: {
                tornado_apprentice: {
                    name: 'Tornado Apprentice',
                    icon: '🌪️',
                    hp: 55, // Buffed +5
                    maxHp: 55,
                    speed: 85, // Slightly faster
                    damage: 12, // Buffed +2
                    color: '#00BFFF', // Deep Sky Blue
                    size: 30,
                    isBoss: false,
                    ability: 'tornado',
                    abilityCooldown: 2800,
                    abilityRange: 320
                },
                necromancer: {
                    name: 'Necromancer',
                    icon: '🧙‍♂️',
                    hp: 70, // Buffed +10
                    maxHp: 70,
                    speed: 75,
                    damage: 18, // Buffed +3
                    color: '#9400D3', // Dark Violet
                    size: 32,
                    isBoss: false,
                    ability: 'summon',
                    abilityCooldown: 4500,
                    abilityRange: 250
                },
                tornado_master: {
                    name: 'Tornado Master',
                    icon: '⚡',
                    hp: 250, // Buffed +50
                    maxHp: 250,
                    speed: 65,
                    damage: 35, // Buffed +5
                    color: '#1E90FF', // Dodger Blue
                    size: 50,
                    isBoss: true,
                    ability: 'tornado',
                    abilityCooldown: 1800,
                    abilityRange: 450
                },
                king_of_skeletons: {
                    name: 'King of Skeletons',
                    icon: '👑',
                    hp: 300, // Buffed +50
                    maxHp: 300,
                    speed: 55,
                    damage: 40, // Buffed +5
                    color: '#FFD700', // Gold
                    size: 60,
                    isBoss: true,
                    ability: 'summon',
                    abilityCooldown: 2500,
                    abilityRange: 300
                },
                fire_drake: {
                    name: 'Fire Drake',
                    icon: '🦎',
                    hp: 90, // Buffed +10
                    maxHp: 90,
                    speed: 70,
                    damage: 25, // Buffed +5
                    color: '#FF4500', // Orange Red
                    size: 35,
                    isBoss: false,
                    ability: 'fireball',
                    abilityCooldown: 3500,
                    abilityRange: 380,
                    dropsTicketFor: 'class_dragonhunter'
                },
                ancient_dragon: {
                    name: 'Ancient Dragon',
                    icon: '🐉',
                    hp: 500, // Buffed +100
                    maxHp: 500,
                    speed: 50,
                    damage: 60, // Buffed +10
                    color: '#8B0000', // Dark Red
                    size: 80, // Larger
                    isBoss: true,
                    ability: 'dragon_rage',
                    abilityCooldown: 4000,
                    abilityRange: 550,
                    dropsTicketFor: 'class_dragonhunter'
                },
                skeleton: {
                    name: 'Skeleton',
                    icon: '💀',
                    hp: 35, // Buffed +15
                    maxHp: 35,
                    speed: 90, // Slightly slower (was 100)
                    damage: 8, // Buffed +3
                    color: '#C0C0C0', // Silver
                    size: 25,
                    isBoss: false,
                    ability: null
                },
                // ELEMENTALIST MOBS
                water_elemental: {
                    name: 'Water Elemental',
                    icon: '💧',
                    hp: 80, // Buffed +10
                    maxHp: 80,
                    speed: 75,
                    damage: 20, // Buffed +2
                    color: '#00FFFF', // Aqua
                    size: 33,
                    isBoss: false,
                    ability: 'water_blast',
                    abilityCooldown: 4000,
                    abilityRange: 320,
                    dropsTicketFor: 'class_elementalist'
                },
                storm_titan: {
                    name: 'Storm Titan',
                    icon: '🌩️',
                    hp: 400, // Buffed +50
                    maxHp: 400,
                    speed: 55,
                    damage: 55, // Buffed +3
                    color: '#FFD700', // Gold
                    size: 70, // Larger
                    isBoss: true,
                    ability: 'lightning_storm',
                    abilityCooldown: 3000,
                    abilityRange: 500,
                    dropsTicketFor: 'class_elementalist',
                    // NEW v19.11.2025: Stationary Boss System
                    isStationaryBoss: true, // This boss stays in center and attacks from there
                    stationaryPosition: 'center-bottom' // 'center' or 'center-bottom'
                },
                prism_wisp: {
                    name: 'Prism Wisp',
                    icon: '🔮',
                    hp: 72,
                    maxHp: 72,
                    speed: 95,
                    damage: 20,
                    color: '#a78bfa',
                    size: 29,
                    isBoss: false,
                    ability: 'magic_bolt',
                    abilityCooldown: 2200,
                    abilityRange: 370,
                    dropsTicketFor: 'class_elementalist'
                },
                frostbound_sentinel: {
                    name: 'Frostbound Sentinel',
                    icon: '❄️',
                    hp: 110,
                    maxHp: 110,
                    speed: 68,
                    damage: 24,
                    color: '#60a5fa',
                    size: 36,
                    isBoss: false,
                    ability: 'water_blast',
                    abilityCooldown: 2900,
                    abilityRange: 330,
                    dropsTicketFor: 'class_elementalist'
                },
                magma_golem: {
                    name: 'Magma Golem',
                    icon: '🪨',
                    hp: 126,
                    maxHp: 126,
                    speed: 58,
                    damage: 30,
                    color: '#f97316',
                    size: 39,
                    isBoss: false,
                    ability: 'arcane_explosion',
                    abilityCooldown: 4200,
                    abilityRange: 290,
                    dropsTicketFor: 'class_elementalist'
                },
                storm_archon: {
                    name: 'Storm Archon',
                    icon: '⚡',
                    hp: 460,
                    maxHp: 460,
                    speed: 56,
                    damage: 52,
                    color: '#38bdf8',
                    size: 72,
                    isBoss: true,
                    ability: 'lightning_storm',
                    abilityCooldown: 2900,
                    abilityRange: 520,
                    dropsTicketFor: 'class_elementalist',
                    isStationaryBoss: true,
                    stationaryPosition: 'center'
                },
                crystal_hydra: {
                    name: 'Crystal Hydra',
                    icon: '🐉',
                    hp: 520,
                    maxHp: 520,
                    speed: 52,
                    damage: 58,
                    color: '#c084fc',
                    size: 78,
                    isBoss: true,
                    ability: 'arcane_explosion',
                    abilityCooldown: 2600,
                    abilityRange: 480,
                    dropsTicketFor: 'class_elementalist'
                },
                // SAMURAI MOBS
                ronin_warrior: {
                    name: 'Ronin Warrior',
                    icon: '👺',
                    hp: 75, // Buffed +10
                    maxHp: 75,
                    speed: 90, // Faster
                    damage: 25, // Buffed +3
                    color: '#DC143C', // Crimson
                    size: 32,
                    isBoss: false,
                    ability: 'quick_slash',
                    abilityCooldown: 3000,
                    abilityRange: 280,
                    dropsTicketFor: 'class_samurai'
                },
                shogun_lord: {
                    name: 'Shogun Lord',
                    icon: '🏯',
                    hp: 350, // Buffed +30
                    maxHp: 350,
                    speed: 65, // Faster
                    damage: 45, // Buffed +3
                    color: '#8B0000', // Dark Red
                    size: 65,
                    isBoss: true,
                    ability: 'blade_dance',
                    abilityCooldown: 3500,
                    abilityRange: 400,
                    dropsTicketFor: 'class_samurai'
                },
                // CYBER GUNSLINGER MOBS
                combat_drone: {
                    name: 'Combat Drone',
                    icon: '🛸',
                    hp: 60, // Buffed +5
                    maxHp: 60,
                    speed: 95, // Faster
                    damage: 20, // Buffed +2
                    color: '#00FFFF', // Cyan
                    size: 30,
                    isBoss: false,
                    ability: 'laser_burst',
                    abilityCooldown: 2800,
                    abilityRange: 350,
                    dropsTicketFor: 'class_gunslinger'
                },
                mech_titan: {
                    name: 'Mech Titan',
                    icon: '🦾',
                    hp: 450, // Buffed +70
                    maxHp: 450,
                    speed: 50,
                    damage: 55, // Buffed +7
                    color: '#32CD32', // Lime Green
                    size: 75,
                    isBoss: true,
                    ability: 'missile_barrage',
                    abilityCooldown: 4000,
                    abilityRange: 500,
                    dropsTicketFor: 'class_gunslinger'
                },
                // MYSTIC SAGE MOBS
                arcane_wisp: {
                    name: 'Arcane Wisp',
                    icon: '✨',
                    hp: 50, // Buffed +5
                    maxHp: 50,
                    speed: 100, // Faster
                    damage: 18, // Buffed +2
                    color: '#9370DB', // Medium Purple
                    size: 28,
                    isBoss: false,
                    ability: 'magic_bolt',
                    abilityCooldown: 2500, // Faster cooldown
                    abilityRange: 350,
                    dropsTicketFor: 'class_mystic'
                },
                elder_sorcerer: {
                    name: 'Elder Sorcerer',
                    icon: '🔮',
                    hp: 360, // Buffed +20
                    maxHp: 360,
                    speed: 60,
                    damage: 48, // Buffed +4
                    color: '#4B0082', // Indigo
                    size: 64,
                    isBoss: true,
                    ability: 'arcane_explosion',
                    abilityCooldown: 3800,
                    abilityRange: 450,
                    dropsTicketFor: 'class_mystic'
                },
                // WIND MASTER MOBS - EXTREMELY ANNOYING AND CHALLENGING
                toxic_zephyr: {
                    name: 'Toxic Zephyr',
                    icon: '🍃',
                    hp: 55, // Buffed +5
                    maxHp: 55,
                    speed: 90, // Buffed speed
                    damage: 12,
                    color: '#32CD32', // Lime Green
                    size: 32,
                    isBoss: false,
                    ability: 'toxic_dash',
                    abilityCooldown: 3500,
                    abilityRange: 380,
                    dropsTicketFor: 'class_wind_master',
                    // Special traits
                    dashSpeed: 220,
                    evasionChance: 0.15, // Buffed evasion
                    pullStrength: 0.35
                },
                radioactive_cyclone: {
                    name: 'Radioactive Cyclone',
                    icon: '☢️',
                    hp: 70, // Buffed +10
                    maxHp: 70,
                    speed: 80, // Buffed speed
                    damage: 15, // Buffed +3
                    color: '#7FFF00', // Chartreuse
                    size: 34,
                    isBoss: false,
                    ability: 'radiation_pulse',
                    abilityCooldown: 4500,
                    abilityRange: 350,
                    dropsTicketFor: 'class_wind_master',
                    // Special traits
                    constantRadiation: true,
                    pullEffect: true,
                    pullStrength: 0.45
                },
                tempest_lord: {
                    name: 'Tempest Lord',
                    icon: '🌪️',
                    hp: 300, // Buffed +30
                    maxHp: 300,
                    speed: 55, // Buffed speed
                    damage: 32, // Buffed +4
                    color: '#2E8B57', // Sea Green
                    size: 75,
                    isBoss: true,
                    ability: 'tempest_fury',
                    abilityCooldown: 6000,
                    abilityRange: 480,
                    dropsTicketFor: 'class_wind_master',
                    // Special boss traits
                    phaseShift: true,
                    windBarrier: true, // Reflects damage
                    summonMinions: false,
                    enrageThreshold: 0.15,
                    // NEW v19.11.2025: Stationary Boss System
                    isStationaryBoss: true, // This boss stays in center and attacks from there
                    stationaryPosition: 'center' // 'center' or 'center-bottom'
                },
                // WILD BERSERKER MOBS - BRUTAL AND AGGRESSIVE
                blood_reaver: {
                    name: 'Blood Reaver',
                    icon: '🩸',
                    hp: 85, // Buffed +10
                    maxHp: 85,
                    speed: 75, // Faster
                    damage: 28, // Buffed +4
                    color: '#B22222', // Firebrick
                    size: 34,
                    isBoss: false,
                    ability: 'blood_frenzy',
                    abilityCooldown: 3800,
                    abilityRange: 250,
                    dropsTicketFor: 'class_berserker',
                    // Special traits
                    enrageOnLowHp: true,
                    lifeSteal: 0.20 // Buffed lifesteal
                },
                axe_thrower: {
                    name: 'Axe Thrower',
                    icon: '🪓',
                    hp: 65, // Buffed +5
                    maxHp: 65,
                    speed: 70, // Faster
                    damage: 22, // Buffed +2
                    color: '#D2691E', // Chocolate
                    size: 32,
                    isBoss: false,
                    ability: 'axe_throw',
                    abilityCooldown: 3200,
                    abilityRange: 420,
                    dropsTicketFor: 'class_berserker',
                    // Special traits
                    rangedAttacker: true,
                    axeCount: 3
                },
                warlord_colossus: {
                    name: 'Warlord Colossus',
                    icon: '👹',
                    hp: 480, // Buffed +60
                    maxHp: 480,
                    speed: 0, // STATIONARY BOSS
                    damage: 65, // Buffed +10
                    color: '#800000', // Maroon
                    size: 85,
                    isBoss: true,
                    ability: 'ground_slam',
                    abilityCooldown: 4500,
                    abilityRange: 650,
                    dropsTicketFor: 'class_berserker',
                    // Special boss traits
                    isStationaryBoss: true,
                    stationaryPosition: 'center',
                    intimidating: true,
                    armorPlating: 0.25, // Buffed armor
                    rageMeter: 0,
                    summonMinions: true
                },
                // SHADOW NINJA MOBS - STEALTHY AND DECEPTIVE
                shadow_assassin: {
                    name: 'Shadow Assassin',
                    icon: '🥷',
                    hp: 60, // Buffed +10
                    maxHp: 60,
                    speed: 105, // Faster
                    damage: 32, // Buffed +4
                    color: '#1A1A1A', // Very Dark Grey
                    size: 30,
                    isBoss: false,
                    ability: 'shadow_strike',
                    abilityCooldown: 4000,
                    abilityRange: 280,
                    dropsTicketFor: 'class_ninja',
                    // Special traits
                    stealthMode: true,
                    criticalStrike: 0.35, // Buffed crit
                    evasionChance: 0.30 // Buffed evasion
                },
                smoke_phantom: {
                    name: 'Smoke Phantom',
                    icon: '🌫️',
                    hp: 65, // Buffed +10
                    maxHp: 65,
                    speed: 90, // Faster
                    damage: 25, // Buffed +3
                    color: '#696969', // Dim Grey
                    size: 32,
                    isBoss: false,
                    ability: 'smoke_bomb',
                    abilityCooldown: 4500,
                    abilityRange: 400,
                    dropsTicketFor: 'class_ninja',
                    // Special traits
                    leavesSmoke: true,
                    teleportChance: 0.25 // Buffed teleport
                },
                shadow_emperor: {
                    name: 'Shadow Emperor',
                    icon: '🌑',
                    hp: 420, // Buffed +40
                    maxHp: 420,
                    speed: 0, // STATIONARY BOSS
                    damage: 55, // Buffed +5
                    color: '#000000', // Black
                    size: 80,
                    isBoss: true,
                    ability: 'shadow_realm',
                    abilityCooldown: 5500,
                    abilityRange: 600,
                    dropsTicketFor: 'class_ninja',
                    // Special boss traits
                    isStationaryBoss: true,
                    stationaryPosition: 'center',
                    intimidating: true,
                    shadowClones: true,
                    phaseShift: true,
                    darkAura: true,
                    summonMinions: true
                },
                // ROMAN LEGIONARY MOBS - EVENTO ESPECIAL: CIVILIZACIONES HISTÓRICAS
                roman_soldier: {
                    name: 'Soldado Romano',
                    icon: '🛡️',
                    hp: 100, // Buffed +15
                    maxHp: 100,
                    speed: 80, // Faster
                    damage: 25, // Buffed +3
                    color: '#DC143C', // Crimson
                    size: 34,
                    isBoss: false,
                    ability: 'gladius_strike',
                    abilityCooldown: 3500,
                    abilityRange: 220,
                    dropsTicketFor: 'class_roman_legionary',
                    // Special traits
                    shieldBlock: true, // 25% chance to block attacks
                    formationBonus: true
                },
                praetorian_guard: {
                    name: 'Guardia Pretoriana',
                    icon: '💂',
                    hp: 140, // Buffed +20
                    maxHp: 140,
                    speed: 75, // Faster
                    damage: 32, // Buffed +4
                    color: '#800080', // Purple
                    size: 38,
                    isBoss: false,
                    ability: 'testudo_defense',
                    abilityCooldown: 4500,
                    abilityRange: 280,
                    dropsTicketFor: 'class_roman_legionary',
                    // Special traits
                    eliteGuard: true,
                    shieldWall: true,
                    counterAttack: true
                },
                caesar_imperator: {
                    name: 'César Imperator',
                    icon: '👑',
                    hp: 500, // Buffed +50
                    maxHp: 500,
                    speed: 70, // Faster
                    damage: 65, // Buffed +10
                    color: '#FFD700', // Gold
                    size: 85,
                    isBoss: true,
                    ability: 'imperial_command',
                    abilityCooldown: 4000,
                    abilityRange: 550,
                    dropsTicketFor: 'class_roman_legionary',
                    // Special boss traits
                    isStationaryBoss: false,
                    commandAura: true,
                    summonLegions: true,
                    imperialShield: true,
                    goldenAura: true,
                    tacticalGenius: true
                },
                // SPARTAN HOPLITE MOBS - EVENTO ESPECIAL: CIVILIZACIONES HISTÓRICAS - GRECIA
                spartan_warrior: {
                    name: 'Guerrero Espartano',
                    icon: '???',
                    hp: 85,
                    maxHp: 85,
                    speed: 75,
                    damage: 28,
                    color: '#8B0000', // Rojo espartano
                    size: 38,
                    isBoss: false,
                    ability: 'shield_bash',
                    abilityCooldown: 4000,
                    abilityRange: 250,
                    dropsTicketFor: 'class_spartan_hoplite',
                    // Special traits
                    spartanDiscipline: true, // Never retreats, fights to the death
                    phalanxFormation: true // Gets stronger when near other Spartans
                },
                athenian_hoplite: {
                    name: 'Hoplita Ateniense',
                    icon: '??',
                    hp: 95,
                    maxHp: 95,
                    speed: 70,
                    damage: 32,
                    color: '#4169E1', // Azul ateniense
                    size: 42,
                    isBoss: false,
                    ability: 'spear_thrust',
                    abilityCooldown: 3500,
                    abilityRange: 300,
                    dropsTicketFor: 'class_spartan_hoplite',
                    // Special traits
                    tacticalMind: true, // Uses strategic positioning
                    hoplonDefense: true // Strong shield defense
                },
                leonidas_king: {
                    name: 'Rey Leónidas',
                    icon: '??',
                    hp: 500,
                    maxHp: 500,
                    speed: 70,
                    damage: 60,
                    color: '#8B0000', // Rojo espartano
                    size: 85,
                    isBoss: true,
                    ability: 'spartan_rage',
                    abilityCooldown: 4000,
                    abilityRange: 450,
                    dropsTicketFor: 'class_spartan_hoplite',
                    // Special boss traits
                    isStationaryBoss: false,
                    kingOfSparta: true, // Inspires all nearby Greek mobs (+30% damage)
                    thermopylaeStand: true, // Gets stronger as HP decreases
                    spartanFury: true, // Enrages at 30% HP
                    legendaryLeader: true, // Summons Spartan Warriors periodically
                    unyielding: true // Cannot be stunned or slowed
                },

                // ===== LEGENDARY BOSSES =====
                aether_dragon: {
                    name: 'Dragón del Éter',
                    icon: '??',
                    hp: 650,
                    maxHp: 650,
                    speed: 55,
                    damage: 70,
                    color: '#9370DB', // Púrpura místico
                    size: 90,
                    isBoss: true,
                    ability: 'aether_abilities',
                    abilityCooldown: 3500,
                    abilityRange: 500,
                    dropsTicketFor: 'class_mystic', // Drops Mystic ticket
                    // Special Aether Dragon traits
                    isLegendaryBoss: true,
                    deathRayCharging: false,
                    deathRayCharged: false,
                    deathRayTarget: null,
                    etherExplosionCharging: false,
                    cursedBarrierActive: false,
                    cursedBarrierAngle: 0,
                    destructionPhaseActive: false,
                    destructionShieldActive: false,
                    summonedMinions: [],
                    lastAbilityUsed: null,
                    abilityRotation: 0
                },

                // ===== ANCIENT RUINS MOBS =====
                stone_golem: {
                    name: 'Gólem de Piedra',
                    icon: '??',
                    hp: 100,
                    maxHp: 100,
                    speed: 60,
                    damage: 30,
                    color: '#A0826D',
                    size: 40,
                    isBoss: false,
                    ability: 'rock_throw',
                    abilityCooldown: 4500,
                    abilityRange: 300,
                    dropsTicketFor: 'ancient-guardian',
                    // Special traits
                    stoneArmor: true, // Reduces damage taken by 20%
                    earthquakeStep: true // Causes small tremors when moving
                },
                ancient_sentinel: {
                    name: 'Centinela Ancestral',
                    icon: '??',
                    hp: 110,
                    maxHp: 110,
                    speed: 70,
                    damage: 35,
                    color: '#CD853F',
                    size: 42,
                    isBoss: false,
                    ability: 'ancient_curse',
                    abilityCooldown: 5000,
                    abilityRange: 250,
                    dropsTicketFor: 'ancient-guardian',
                    // Special traits
                    ancientWisdom: true, // Predicts player movement
                    runicShield: true // Periodic shield that blocks one attack
                },

                taurha_giant: {
                    name: 'Taurha',
                    icon: '???',
                    hp: 1250,
                    maxHp: 1250,
                    speed: 40,
                    damage: 80,
                    color: '#8B7355', // Color piedra/ruinas
                    size: 95,
                    isBoss: true,
                    ability: 'taurha_abilities',
                    abilityCooldown: 1100,
                    abilityRange: 600,
                    dropsTicketFor: 'ancient-guardian',
                    // Special Taurha traits
                    isLegendaryBoss: true,
                    level: 20, // Fixed level 20
                    columnWeapon: true,
                    lastAbilityUsed: null,
                    abilityRotation: 0,
                    acidCracks: [],
                    swingCount: 0,
                    phaseTwoTriggered: false,
                    phaseTwoVisual: false,
                    taurhaAbilityTimers: null
                },
                // ANUBIS GUARDIAN MOBS - Egyptian themed
                anubis_jackal: {
                    name: 'Chacal del Duat',
                    icon: '🐺',
                    color: '#FFD700',
                    hp: 180,
                    maxHp: 180,
                    speed: 65, // Fast mob
                    damage: 35,
                    size: 35,
                    isBoss: false,
                    ability: 'sand_dash',
                    abilityCooldown: 3800,
                    abilityRange: 300,
                    dropsTicketFor: 'class_anubis',
                    // Special traits
                    sandDash: true, // Dashes through sand leaving trail
                    goldAura: true // Leaves golden particles
                },
                anubis_mummy: {
                    name: 'Momia Guardiana',
                    icon: '🧟',
                    color: '#DEB887',
                    hp: 220,
                    maxHp: 220,
                    speed: 35, // Slow mob
                    damage: 45,
                    size: 40,
                    isBoss: false,
                    ability: 'curse_touch',
                    abilityCooldown: 4500,
                    abilityRange: 250,
                    dropsTicketFor: 'class_anubis',
                    // Special traits
                    cursedTouch: true, // Slows player on hit
                    regenerates: true // Slowly regenerates HP
                },
                anubis_sphinx: {
                    name: 'Esfinge Menor',
                    icon: '🦁',
                    color: '#CD853F',
                    hp: 280,
                    maxHp: 280,
                    speed: 50, // Medium speed
                    damage: 50,
                    size: 50,
                    isBoss: false,
                    ability: 'riddle_blast',
                    abilityCooldown: 5000,
                    abilityRange: 400,
                    dropsTicketFor: 'class_anubis',
                    // Special traits
                    riddleAttack: true, // Confuses player controls briefly
                    stoneGaze: true // Slows enemies in cone
                },
                // ANUBIS BOSSES
                anubis_pharaoh: {
                    name: 'Faraón Maldito',
                    icon: '👑',
                    color: '#FFD700',
                    hp: 1200,
                    maxHp: 1200,
                    speed: 45, // Medium boss speed
                    damage: 70,
                    size: 65,
                    isBoss: true,
                    ability: 'pharaoh_curse',
                    abilityCooldown: 4000,
                    abilityRange: 450,
                    dropsTicketFor: 'class_anubis',
                    // Special boss traits
                    isStationaryBoss: false,
                    summonsMummies: true, // Summons 2 mummies every 15s
                    plagueCurse: true, // Applies stacking curse debuff
                    goldShield: true // 30% damage reduction
                },
                anubis_colossus: {
                    name: 'Coloso de Anubis',
                    icon: '🗿',
                    color: '#8B7355',
                    hp: 1800,
                    maxHp: 1800,
                    speed: 30, // Slow but stationary
                    damage: 90,
                    size: 80,
                    isBoss: true,
                    ability: 'anubis_judgment',
                    abilityCooldown: 5000,
                    abilityRange: 500,
                    dropsTicketFor: 'class_anubis',
                    // Special boss traits
                    isStationaryBoss: true,
                    stationaryPosition: 'center',
                    massiveSize: true, // Larger hitbox
                    earthquakeStomps: true, // Creates shockwaves when moving
                    ancientPower: true // Increases damage over time
                },
                anubis_avatar: {
                    name: 'Avatar de Anubis',
                    icon: '☥',
                    color: '#00CED1',
                    hp: 2500,
                    maxHp: 2500,
                    speed: 55, // Fast legendary boss
                    damage: 100,
                    size: 90,
                    isBoss: true,
                    ability: 'divine_wrath',
                    abilityCooldown: 3500,
                    abilityRange: 600,
                    dropsTicketFor: 'class_anubis',
                    // Special legendary boss traits
                    isLegendaryBoss: true,
                    level: 22, // Fixed level 22
                    portalSummon: true, // Opens portals that spawn enemies
                    soulWeighing: true, // Executes low HP enemies instantly
                    divineForm: true, // Transforms at 50% HP
                    lastAbilityUsed: null,
                    abilityRotation: 0
                }
            },

            startRaid() {
                // START SURVIVAL MODE (General)
                this.isCustomRaid = false;
                this.selectedRaidName = 'Survival Protocol';
                this.selectedDropTarget = null;
                this.selectedRewardName = null;
                this.selectedRewardType = null;
                this.actuallyStartRaid();

                // Show notification
                if (!this.specialWaveNotifications) this.specialWaveNotifications = [];
                this.specialWaveNotifications.push({
                    text: `⚔️ SURVIVAL MODE INITIATED ⚔️`,
                    startTime: Date.now(),
                    duration: 4000,
                    color: '#ff0000'
                });
            },

            startDungeonRaid(dungeonName, mobs, bosses, options = {}) {
                this.isCustomRaid = true;
                this.selectedRaidName = dungeonName;
                this.customMobTypes = mobs;
                this.customBossTypes = bosses;
                this.selectedDropTarget = options.rewardTarget || null;
                this.selectedRewardName = options.rewardName || null;
                this.selectedRewardType = options.rewardType || null;

                console.log(`🏰 Starting Dungeon: ${dungeonName}`);
                this.actuallyStartRaid();

                // Show notification
                if (!this.specialWaveNotifications) this.specialWaveNotifications = [];
                this.specialWaveNotifications.push({
                    text: `🏰 DUNGEON: ${dungeonName.toUpperCase()} 🏰`,
                    startTime: Date.now(),
                    duration: 4000,
                    color: '#00d9ff'
                });
            },

            stopRaid(playerDied = false) {
                // If player died, show Game Over screen first instead of immediate clear
                if (playerDied) {
                    this.showGameOverScreen(false);
                    return;
                }

                this.active = false;
                this.mobs = [];
                this.bosses = [];
                this.projectiles = [];
                this.paused = false;

                // Reset custom raid settings
                this.isCustomRaid = false;
                this.customMobTypes = [];
                this.customBossTypes = [];
                this.selectedDropTarget = null;
                this.selectedRewardName = null;
                this.selectedRewardType = null;

                // Reset multi-boss dungeon settings
                this.isMultiBossDungeon = false;
                this.multiBossOrder = [];
                this.totalBossCount = 0;
                this.defeatedBosses = [];
                this.isSpawningNextBoss = false;

                // NEW v19.11.2025: Complete scene cleanup
                // Clear all toxic bubbles
                if (this.toxicBubbles) {
                    this.toxicBubbles = [];
                }

                // Clear all floating texts
                if (this.floatingTexts) {
                    this.floatingTexts = [];
                }

                // Reset Player state completely
                Player.speed = Player.baseSpeed;
                Player.hasActiveSlowEffect = false;
                Player.radioactiveDamageBuff = 0;
                Player.damageBoost = 0;
                Player.invulnerable = false;
                Player.counterActive = false;
                Player.regenActive = false;

                // Clear any lingering visual effects from canvas
                const canvas = document.getElementById('game-canvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen().catch(err => console.log('Exit fullscreen failed:', err));
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }

                // Raid stopped - no button to update anymore (using menu now)

                console.log('?? Raid Stopped - Scene cleaned for next raid.');
            },

            showGameOverScreen(isVictory) {
                if (document.querySelector('.game-over-screen')) return;

                const title = isVictory ? "MISSION ACCOMPLISHED" : "CRITICAL FAILURE";
                const color = isVictory ? "#ffd700" : "#ff0044";
                const subColor = isVictory ? "#00ff88" : "#888";

                const showOverlay = () => {
                    const existing = document.querySelector('.game-over-screen');
                    if (existing) existing.remove();

                    // Freeze gameplay logic without rendering PAUSED text.
                    this.active = false;
                    this.paused = false;

                    const overlay = document.createElement('div');
                    overlay.className = 'game-over-screen';
                    overlay.style.cssText = `
                        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                        background: rgba(5, 10, 20, 0.9); z-index: 20000;
                        display: flex; flex-direction: column; align-items: center; justify-content: center;
                        font-family: 'Orbitron', sans-serif; color: white; opacity: 0; transition: opacity 0.5s;
                        backdrop-filter: blur(8px);
                    `;

                    overlay.innerHTML = `
                        <h1 style="font-size: 72px; color: ${color}; text-shadow: 0 0 30px ${color}; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 4px;">${title}</h1>
                        <div style="width: 60%; height: 2px; background: linear-gradient(90deg, transparent, ${color}, transparent); margin-bottom: 40px;"></div>
                        
                        <div style="font-size: 28px; margin-bottom: 50px; text-align: center; display: grid; grid-template-columns: 1fr 1fr; gap: 40px;">
                            <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid ${color}44;">
                                <div style="font-size: 16px; color: #888; margin-bottom: 5px;">WAVES SURVIVED</div>
                                <div style="font-size: 42px; color: ${subColor}; font-weight: bold;">${this.wave}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid ${color}44;">
                                <div style="font-size: 16px; color: #888; margin-bottom: 5px;">TOTAL SCORE</div>
                                <div style="font-size: 42px; color: #ffd700; font-weight: bold;">${this.score}</div>
                            </div>
                        </div>

                        <div style="display: flex; gap: 30px;">
                            <button id="retry-btn" style="
                                padding: 18px 50px; font-size: 22px; background: ${color}; border: none; 
                                color: #000; font-weight: 900; cursor: pointer; 
                                clip-path: polygon(15% 0, 100% 0, 100% 70%, 85% 100%, 0 100%, 0 30%); 
                                transition: all 0.2s; box-shadow: 0 0 20px ${color}66;
                            ">RETRY MISSION</button>
                            
                            <button id="menu-btn" style="
                                padding: 18px 50px; font-size: 22px; background: transparent; 
                                border: 2px solid ${color}; color: ${color}; font-weight: 900; cursor: pointer; 
                                clip-path: polygon(15% 0, 100% 0, 100% 70%, 85% 100%, 0 100%, 0 30%); 
                                transition: all 0.2s;
                            ">RETURN TO BASE</button>
                        </div>
                    `;

                    document.body.appendChild(overlay);
                    setTimeout(() => overlay.style.opacity = '1', 50);

                    const btnHover = (e) => { e.target.style.transform = 'scale(1.05) translateY(-2px)'; };
                    const btnOut = (e) => { e.target.style.transform = 'scale(1) translateY(0)'; };

                    const retry = document.getElementById('retry-btn');
                    const menu = document.getElementById('menu-btn');
                    [retry, menu].forEach(b => {
                        b.onmouseover = btnHover;
                        b.onmouseout = btnOut;
                    });

                    retry.onclick = () => {
                        overlay.style.opacity = '0';
                        setTimeout(() => {
                            overlay.remove();
                            this.stopRaid(false); // Reset

                            // Fullscreen check for retry
                            const canvas = document.getElementById('game-canvas');
                            if (canvas && !document.fullscreenElement) {
                                canvas.requestFullscreen().catch(e => { });
                            }

                            this.actuallyStartRaid();
                        }, 400);
                    };

                    menu.onclick = () => {
                        overlay.style.opacity = '0';
                        setTimeout(() => {
                            overlay.remove();
                            this.stopRaid(false); // Reset and exit fullscreen
                        }, 400);
                    };
                };

                const fsElement = document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
                if (!fsElement) {
                    showOverlay();
                    return;
                }

                let finalized = false;
                const finalizeAfterExit = () => {
                    if (finalized) return;
                    finalized = true;
                    document.removeEventListener('fullscreenchange', finalizeAfterExit);
                    document.removeEventListener('webkitfullscreenchange', finalizeAfterExit);
                    document.removeEventListener('MSFullscreenChange', finalizeAfterExit);
                    setTimeout(showOverlay, 30);
                };

                document.addEventListener('fullscreenchange', finalizeAfterExit);
                document.addEventListener('webkitfullscreenchange', finalizeAfterExit);
                document.addEventListener('MSFullscreenChange', finalizeAfterExit);

                const timeout = setTimeout(finalizeAfterExit, 700);
                const wrapFinalize = () => {
                    clearTimeout(timeout);
                    finalizeAfterExit();
                };

                if (document.exitFullscreen) {
                    document.exitFullscreen().then(wrapFinalize).catch(wrapFinalize);
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                    wrapFinalize();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                    wrapFinalize();
                } else {
                    wrapFinalize();
                }
            },


            actuallyStartRaid() {
                this.wave = 0;
                this.score = 0;
                this.mobs = [];
                this.bosses = [];
                this.projectiles = [];
                this.active = true;
                this.paused = false;

                // Reset Player
                const gameCanvas = document.getElementById('game-canvas');
                if (typeof Player !== 'undefined' && gameCanvas) {
                    Player.hp = Player.maxHp;
                    Player.x = gameCanvas.width / 2;
                    Player.y = gameCanvas.height / 2;
                }

                // Start
                this.startWave();

                // Show notification
                if (!this.specialWaveNotifications) this.specialWaveNotifications = [];
                const targetSuffix = this.selectedRewardName ? ` | OBJETIVO: ${String(this.selectedRewardName).toUpperCase()}` : '';
                this.specialWaveNotifications.push({
                    text: `?? RAID INICIADA: ${this.selectedRaidName.toUpperCase()}${targetSuffix} ??`,
                    startTime: Date.now(),
                    duration: 4000,
                    color: '#00d9ff'
                });
            },

            spawnWave() {
                const canvas = document.getElementById('game-canvas');
                console.log('🌊 Spawning wave', this.wave, 'Canvas:', canvas.width, 'x', canvas.height);

                // Skip spawnWave for multi-boss dungeons - they handle spawning separately
                if (this.isMultiBossDungeon) {
                    console.log('🏰 Multi-boss dungeon - skipping normal spawnWave');
                    return;
                }

                // NEW: Check if this is a special wave (every 7 waves)
                const isSpecialWave = this.wave % 7 === 0;
                if (isSpecialWave) {
                    console.log('? SPECIAL WAVE! x4 enemies!');

                    // Show fullscreen notification
                    if (!this.specialWaveNotifications) this.specialWaveNotifications = [];
                    this.specialWaveNotifications.push({
                        text: '? OLEADA ESPECIAL - x4 ENEMIGOS ?',
                        startTime: Date.now(),
                        duration: 3000
                    });
                }

                // NEW v19.11.2025: Determine if stationary boss will spawn
                let stationaryBossType = null;
                const isBossWave = this.wave % 5 === 0; // Boss every 5 waves

                if (isBossWave) {
                    if (this.isCustomRaid && this.customBossTypes.length > 0) {
                        const bossType = this.customBossTypes[Math.floor(Math.random() * this.customBossTypes.length)];
                        if (this.mobTypes[bossType]?.isStationaryBoss) {
                            stationaryBossType = bossType;
                        }
                    } else {
                        const rand = Math.random();
                        let bossType;
                        if (rand < 0.091) bossType = 'tornado_master';
                        else if (rand < 0.182) bossType = 'king_of_skeletons';
                        else if (rand < 0.273) bossType = 'ancient_dragon';
                        else if (rand < 0.364) bossType = 'storm_titan';
                        else if (rand < 0.455) bossType = 'shogun_lord';
                        else if (rand < 0.545) bossType = 'mech_titan';
                        else if (rand < 0.636) bossType = 'elder_sorcerer';
                        else if (rand < 0.727) bossType = 'tempest_lord';
                        else if (rand < 0.818) bossType = 'warlord_colossus';
                        else if (rand < 0.909) bossType = 'shadow_emperor';
                        else bossType = 'aether_dragon'; // NEW: Aether Dragon

                        if (this.mobTypes[bossType]?.isStationaryBoss) {
                            stationaryBossType = bossType;
                        }
                    }
                }

                // Custom Raid Logic
                if (this.isCustomRaid) {
                    // Check if this is a multi-boss dungeon - they handle boss spawning separately
                    const dungeonData = DungeonManager.dungeons[this.selectedRaidName];
                    const isMultiBossDungeon = dungeonData && dungeonData.isMultiBossDungeon;

                    // Reduced mobs if stationary boss (1-2 max), x4 if special wave
                    let baseMobCount = stationaryBossType ? Math.min(2, 1 + Math.floor(this.wave / 2)) : 3 + this.wave;
                    const mobCount = isSpecialWave ? baseMobCount * 4 : baseMobCount;

                    for (let i = 0; i < mobCount; i++) {
                        if (this.customMobTypes.length > 0) {
                            const mobType = this.customMobTypes[Math.floor(Math.random() * this.customMobTypes.length)];
                            this.spawnMob(mobType, canvas);
                        }
                    }

                    // IMPORTANT: Skip normal boss spawning for multi-boss dungeons
                    // Multi-boss dungeons spawn bosses one at a time in sequence (handled in update())
                    if (isBossWave && this.customBossTypes.length > 0 && !isMultiBossDungeon) {
                        const bossType = stationaryBossType || this.customBossTypes[Math.floor(Math.random() * this.customBossTypes.length)];
                        this.spawnMob(bossType, canvas, stationaryBossType !== null);
                    }
                } else {
                    // Normal Raid Logic - REDUCED mobs if stationary boss
                    // NEW v19.11.2025: Special wave every 7 waves (x4 enemies)
                    const isSpecialWave = this.wave % 7 === 0;
                    let baseMobCount = stationaryBossType ? Math.min(2, 1 + Math.floor(this.wave / 2)) : 3 + this.wave;
                    const mobCount = isSpecialWave ? baseMobCount * 4 : baseMobCount;

                    if (isSpecialWave) {
                        console.log('?? SPECIAL WAVE! x4 ENEMIES!');
                    }
                    for (let i = 0; i < mobCount; i++) {
                        const rand = Math.random();
                        let mobType;
                        if (rand < 0.077) mobType = 'tornado_apprentice';
                        else if (rand < 0.154) mobType = 'necromancer';
                        else if (rand < 0.231) mobType = 'fire_drake';
                        else if (rand < 0.308) mobType = 'water_elemental';
                        else if (rand < 0.385) mobType = 'ronin_warrior';
                        else if (rand < 0.462) mobType = 'combat_drone';
                        else if (rand < 0.539) mobType = 'arcane_wisp';
                        else if (rand < 0.616) mobType = 'toxic_zephyr';
                        else if (rand < 0.693) mobType = 'radioactive_cyclone';
                        else if (rand < 0.770) mobType = 'blood_reaver';
                        else if (rand < 0.847) mobType = 'axe_thrower';
                        else if (rand < 0.924) mobType = 'shadow_assassin';
                        else mobType = 'smoke_phantom';
                        this.spawnMob(mobType, canvas);
                    }

                    if (isBossWave) {
                        const rand = Math.random();
                        let bossType;
                        if (rand < 0.091) bossType = 'tornado_master';
                        else if (rand < 0.182) bossType = 'king_of_skeletons';
                        else if (rand < 0.273) bossType = 'ancient_dragon';
                        else if (rand < 0.364) bossType = 'storm_titan';
                        else if (rand < 0.455) bossType = 'shogun_lord';
                        else if (rand < 0.545) bossType = 'mech_titan';
                        else if (rand < 0.636) bossType = 'elder_sorcerer';
                        else if (rand < 0.727) bossType = 'tempest_lord';
                        else if (rand < 0.818) bossType = 'warlord_colossus';
                        else if (rand < 0.909) bossType = 'shadow_emperor';
                        else bossType = 'aether_dragon'; // NEW: Aether Dragon
                        this.spawnMob(bossType, canvas, this.mobTypes[bossType]?.isStationaryBoss);
                    }
                }

                // SAFETY MECHANIC: If stationary boss spawned, move player to safe position and give invulnerability
                if (stationaryBossType) {
                    console.log('??? STATIONARY BOSS DETECTED! Moving player to safe position...');

                    // Move player to bottom-left corner (safe distance from center)
                    Player.x = 150;
                    Player.y = canvas.height - 150;

                    // Give player 3 seconds of invulnerability to escape
                    Player.invulnerable = true;
                    Player.invulnerableTime = 3000;

                    // Show warning notification
                    if (!this.specialWaveNotifications) this.specialWaveNotifications = [];
                    this.specialWaveNotifications.push({
                        text: '?? BOSS ESTACIONARIO - 3s INVULNERABILIDAD ??',
                        startTime: Date.now(),
                        duration: 3000
                    });

                    console.log('??? Player moved to safe position with 3s invulnerability!');
                }

                console.log('?? Mobs:', this.mobs.length, 'Bosses:', this.bosses.length, stationaryBossType ? '?? STATIONARY!' : '');
            },

            startWave() {
                this.wave++;
                console.log(`=== STARTING WAVE ${this.wave} ===`);

                // Create Wave Notification
                if (this.wave > 1) {
                    if (!this.specialWaveNotifications) this.specialWaveNotifications = [];
                    this.specialWaveNotifications.push({
                        text: `⚔️ OLEADA ${this.wave}`,
                        startTime: Date.now(),
                        duration: 3000,
                        color: '#ffffff'
                    });
                }

                // Check for multi-boss dungeon - spawn boss immediately on wave 1
                if (this.isMultiBossDungeon) {
                    // Initialize defeated bosses tracking
                    if (!this.defeatedBosses) this.defeatedBosses = [];

                    // Only spawn first boss on wave 1
                    if (this.wave === 1 && !this.isSpawningNextBoss) {
                        this.isSpawningNextBoss = true;
                        // Spawn first boss immediately
                        const firstBossType = this.multiBossOrder[0];
                        const bossData = this.mobTypes[firstBossType];

                        if (!this.specialWaveNotifications) this.specialWaveNotifications = [];
                        this.specialWaveNotifications.push({
                            text: `⚠️ ¡JEFE INICIAL: ${bossData ? bossData.name.toUpperCase() : firstBossType.toUpperCase()}! (1/${this.totalBossCount}) ⚠️`,
                            startTime: Date.now(),
                            duration: 4000,
                            color: '#ff6b00'
                        });

                        // Spawn first boss and some mobs
                        const canvas = document.getElementById('game-canvas');
                        setTimeout(() => {
                            this.spawnMob(firstBossType, canvas, this.mobTypes[firstBossType]?.isStationaryBoss);

                            // Spawn support mobs (reduced amount)
                            const mobTypes = this.customMobTypes;
                            for (let i = 0; i < 3; i++) {
                                const mobType = mobTypes[Math.floor(Math.random() * mobTypes.length)];
                                this.spawnMob(mobType, canvas, false);
                            }
                            this.isSpawningNextBoss = false;
                        }, 2500);

                        console.log(`🏰 Multi-boss dungeon started! First boss: ${firstBossType}`);
                    }

                    // ALWAYS return early for multi-boss dungeons
                    // Boss spawning is handled in update() when previous boss is defeated
                    return;
                }

                // Mob Count Scaling
                let mobCount = 5 + Math.floor(this.wave * 1.5);
                if (mobCount > 18) mobCount = 18;

                // Spawn Mobs
                const canvas = document.getElementById('game-canvas');
                const mobTypes = this.isCustomRaid ? this.customMobTypes : ['tornado_apprentice'];

                if (mobTypes && mobTypes.length > 0) {
                    for (let i = 0; i < mobCount; i++) {
                        const type = mobTypes[Math.floor(Math.random() * mobTypes.length)];
                        if (this.mobTypes[type]) {
                            this.spawnMob(type, canvas, false);
                        }
                    }
                }

                // Boss Spawn (Every 5 waves) - Skip for multi-boss dungeons
                const dungeonData = this.isCustomRaid ? DungeonManager.dungeons[this.selectedRaidName] : null;
                const isMultiBossDungeon = dungeonData && dungeonData.isMultiBossDungeon;

                if (this.wave % 5 === 0 && !isMultiBossDungeon) {
                    const bossTypes = this.isCustomRaid ? this.customBossTypes : ['tornado_master'];
                    if (bossTypes && bossTypes.length > 0) {
                        const bossType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                        if (this.mobTypes[bossType]) {
                            // Check for special boss notification
                            if (!this.specialWaveNotifications) this.specialWaveNotifications = [];
                            this.specialWaveNotifications.push({
                                text: `⚠️ JEFE APROXIMÁNDOSE: ${this.mobTypes[bossType].name.toUpperCase()} ⚠️`,
                                startTime: Date.now(),
                                duration: 5000,
                                color: '#ff0000'
                            });

                            // Spawn slightly delayed so player sees warning
                            setTimeout(() => {
                                this.spawnMob(bossType, canvas, true);
                            }, 2000);
                        }
                    }
                }
            },

            spawnMob(type, canvas, isStationary = false) {
                const mobData = this.mobTypes[type];

                // Guard against undefined mob types
                if (!mobData) {
                    console.warn(`⚠️ Unknown mob type: ${type}, skipping spawn`);
                    return;
                }

                let x, y;

                // NEW v19.11.2025: Stationary Boss Positioning
                if (isStationary && mobData.isStationaryBoss) {
                    if (mobData.stationaryPosition === 'center') {
                        x = canvas.width / 2;
                        y = canvas.height / 2;
                    } else if (mobData.stationaryPosition === 'center-bottom') {
                        x = canvas.width / 2;
                        y = canvas.height * 0.75; // 75% down
                    }
                    console.log(`?? Stationary Boss spawned at ${mobData.stationaryPosition}:`, x, y);
                } else {
                    // Normal spawn from edges
                    const side = Math.floor(Math.random() * 4);
                    switch (side) {
                        case 0: x = Math.random() * canvas.width; y = -50; break;
                        case 1: x = canvas.width + 50; y = Math.random() * canvas.height; break;
                        case 2: x = Math.random() * canvas.width; y = canvas.height + 50; break;
                        case 3: x = -50; y = Math.random() * canvas.height; break;
                    }
                }

                const mob = {
                    id: Date.now() + Math.random(),
                    type: type,
                    x: x,
                    y: y,
                    ...mobData,
                    currentAbilityCooldown: 0,
                    burning: false,
                    burnStacks: 0,
                    burnDamage: 0,
                    confused: false,
                    confusedTime: 0,
                    damageReduction: 0,
                    damageReductionPermanent: false,
                    // NEW v19.11.2025: Stationary boss flag
                    isStationary: isStationary && mobData.isStationaryBoss,
                    targetX: x, // For stationary bosses
                    targetY: y,
                    returnTimer: 0, // Timer to return to position after being moved
                    needsReturn: false // Flag to indicate boss needs to return
                };

                // Validate HP values to prevent NaN/Infinity errors (only if invalid)
                if (typeof mob.maxHp !== 'number' || !isFinite(mob.maxHp) || mob.maxHp <= 0) {
                    console.warn(`⚠️ Invalid maxHp for ${type}, using fallback`);
                    mob.maxHp = 100; // Default fallback only if truly invalid
                }
                if (typeof mob.hp !== 'number' || !isFinite(mob.hp)) {
                    mob.hp = mob.maxHp;
                }

                if (mobData.isBoss) {
                    this.bosses.push(mob);
                } else {
                    this.mobs.push(mob);
                }
            },

            update(deltaTime) {
                if (!this.active || this.paused) return;

                // NEW v19.11.2025: Update attack indicators
                this.updateAttackIndicators(deltaTime);

                const allMobs = [...this.mobs, ...this.bosses];

                allMobs.forEach(mob => {
                    // Update status effects
                    if (mob.confused) {
                        mob.confusedTime -= deltaTime;
                        if (mob.confusedTime <= 0) {
                            mob.confused = false;
                        }
                    }

                    if (mob.stunned) {
                        if (!mob.stunUntil && mob.stunnedTime) {
                            mob.stunUntil = Date.now() + mob.stunnedTime;
                        }
                        if (mob.stunUntil && Date.now() >= mob.stunUntil) {
                            mob.stunned = false;
                            mob.stunnedTime = 0;
                            mob.stunUntil = null;
                            if (typeof mob.preStunSpeed === 'number') {
                                mob.speed = mob.preStunSpeed;
                            } else if (typeof mob.originalSpeed === 'number' && mob.speed === 0) {
                                mob.speed = mob.originalSpeed;
                            }
                            delete mob.preStunSpeed;
                        }
                    }

                    if (mob.silenced) {
                        mob.silencedTime = Math.max(0, (mob.silencedTime || 0) - deltaTime);
                        if (mob.silencedTime <= 0) {
                            mob.silenced = false;
                        }
                    }

                    if (mob.deathMarked) {
                        if (!mob.deathMarkUntil && mob.deathMarkTime) {
                            mob.deathMarkUntil = Date.now() + mob.deathMarkTime;
                        }
                        if (mob.deathMarkUntil && Date.now() >= mob.deathMarkUntil) {
                            mob.deathMarked = false;
                            mob.deathMarkTime = 0;
                            mob.deathMarkMultiplier = 1;
                            mob.deathMarkUntil = null;
                        }
                    }

                    // Radioactivity effect - constant damage + spreads to nearby enemies
                    if (mob.radioactive) {
                        if (!mob.radioactiveLastTick) mob.radioactiveLastTick = Date.now();

                        const timeSinceLastTick = Date.now() - mob.radioactiveLastTick;
                        if (timeSinceLastTick >= mob.radioactiveTickInterval) {
                            this.damageMob(mob.id, mob.radioactiveDamage);
                            mob.radioactiveLastTick = Date.now();

                            // Check for nearby enemies to spread radioactivity
                            allMobs.forEach(otherMob => {
                                if (otherMob.id !== mob.id && !otherMob.radioactive) {
                                    const dx = otherMob.x - mob.x;
                                    const dy = otherMob.y - mob.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);

                                    // Spread if very close (infection mechanic)
                                    if (dist < 80) {
                                        otherMob.radioactive = true;
                                        otherMob.radioactiveTime = 7000;
                                        otherMob.radioactiveDamage = 4;
                                        otherMob.radioactiveTickInterval = 500;
                                        console.log(`?? Radioactividad se propagí a ${otherMob.name}!`);
                                    }
                                }
                            });
                        }

                        mob.radioactiveTime -= deltaTime;
                        if (mob.radioactiveTime <= 0) {
                            mob.radioactive = false;
                            delete mob.radioactiveLastTick;
                        }
                    }

                    // Poison effect - constant damage + defense reduction + speed reduction
                    if (mob.poisoned) {
                        if (!mob.poisonLastTick) mob.poisonLastTick = Date.now();

                        const timeSinceLastTick = Date.now() - mob.poisonLastTick;
                        if (timeSinceLastTick >= mob.poisonTickInterval) {
                            this.damageMob(mob.id, mob.poisonDamage);
                            mob.poisonLastTick = Date.now();
                        }

                        mob.poisonTime -= deltaTime;
                        if (mob.poisonTime <= 0) {
                            mob.poisoned = false;
                            delete mob.poisonLastTick;
                        }
                    }

                    // Handle being thrown by wind
                    if (mob.beingThrown) {
                        mob.x += mob.throwVelocityX * (deltaTime / 1000);
                        mob.y += mob.throwVelocityY * (deltaTime / 1000);
                        // Slow down over time
                        mob.throwVelocityX *= 0.95;
                        mob.throwVelocityY *= 0.95;
                    }

                    // WIND MASTER MOB SPECIAL MECHANICS

                    // Toxic Zephyr - Constant radiation emission
                    if (mob.constantRadiation && mob.type === 'toxic_zephyr') {
                        if (!mob.radiationEmitTimer) mob.radiationEmitTimer = 0;
                        mob.radiationEmitTimer += deltaTime;

                        if (mob.radiationEmitTimer >= 2000) { // Every 2 seconds
                            const dx = Player.x - mob.x;
                            const dy = Player.y - mob.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < 150) {
                                Player.takeDamage(3); // Small constant damage
                            }
                            mob.radiationEmitTimer = 0;
                        }
                    }

                    // Radioactive Cyclone - Pull effect (NERFED v19.11.2025)
                    if (mob.pullEffect && mob.type === 'radioactive_cyclone') {
                        const dx = mob.x - Player.x;
                        const dy = mob.y - Player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 250 && dist > 0) {
                            // Reduced pull strength (NERFED v19.11.2025)
                            const pullStrength = mob.pullStrength || 0.4;
                            Player.x += (dx / dist) * pullStrength * (deltaTime / 1000) * 60;
                            Player.y += (dy / dist) * pullStrength * (deltaTime / 1000) * 60;
                        }
                    }

                    // Tempest Lord - Wind Barrier (reflects damage)
                    if (mob.windBarrier && mob.type === 'tempest_lord') {
                        // This is handled in damageMob function
                    }

                    // Tempest Lord - Enrage when below 30% HP
                    if (mob.enrageThreshold && mob.type === 'tempest_lord') {
                        const healthPercent = mob.hp / mob.maxHp;
                        if (healthPercent < mob.enrageThreshold && !mob.enraged) {
                            mob.enraged = true;
                            mob.speed *= 1.5; // 50% faster
                            mob.damage *= 1.3; // 30% more damage
                            mob.color = '#ff0000'; // Turn red
                            console.log('??? Tempest Lord ENRAGED! Speed and damage increased!');
                        }
                    }

                    // Tempest Lord - Phase shift teleport
                    if (mob.phaseShift && mob.type === 'tempest_lord') {
                        if (!mob.phaseShiftTimer) mob.phaseShiftTimer = 0;
                        mob.phaseShiftTimer += deltaTime;

                        if (mob.phaseShiftTimer >= 8000) { // Every 8 seconds
                            const canvas = document.getElementById('game-canvas');
                            mob.x = 100 + Math.random() * (canvas.width - 200);
                            mob.y = 100 + Math.random() * (canvas.height - 200);
                            console.log('??? Tempest Lord phase shifted!');
                            mob.phaseShiftTimer = 0;
                        }
                    }

                    // Burn stacks don't do passive damage - only when enemy attacks

                    // Move towards player (NEW v19.11.2025: Stationary bosses don't move)
                    // NEW: Enemies can't see invisible player
                    const dx = Player.x - mob.x;
                    const dy = Player.y - mob.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (!mob.isStationary) {
                        if (dist > 0 && !mob.confused && !mob.stunned && !Player.invisible) {
                            // Normal movement toward player (only if player is visible)
                            mob.x += (dx / dist) * mob.speed * (deltaTime / 1000);
                            mob.y += (dy / dist) * mob.speed * (deltaTime / 1000);
                        } else if (mob.confused || Player.invisible) {
                            // Random movement when confused OR when player is invisible
                            const randomAngle = Math.random() * Math.PI * 2;
                            mob.x += Math.cos(randomAngle) * mob.speed * 0.5 * (deltaTime / 1000);
                            mob.y += Math.sin(randomAngle) * mob.speed * 0.5 * (deltaTime / 1000);
                        }
                    } else {
                        // NEW v19.11.2025: Stationary boss return system
                        const distFromTarget = Math.sqrt(Math.pow(mob.x - mob.targetX, 2) + Math.pow(mob.y - mob.targetY, 2));

                        if (distFromTarget > 10) {
                            // Boss was moved, start return timer
                            if (!mob.needsReturn) {
                                mob.needsReturn = true;
                                mob.returnTimer = 2000; // 2 seconds
                                console.log(`?? ${mob.name} was moved! Returning in 2s...`);
                            }

                            mob.returnTimer -= deltaTime;
                            if (mob.returnTimer <= 0) {
                                // Return to position
                                mob.x = mob.targetX;
                                mob.y = mob.targetY;
                                mob.needsReturn = false;
                                console.log(`?? ${mob.name} returned to position!`);
                            }
                        } else {
                            // Boss is at target position
                            mob.x = mob.targetX;
                            mob.y = mob.targetY;
                            mob.needsReturn = false;
                        }
                    }

                    // Check collision with player
                    if (!mob.stunned && dist < mob.size + 25) {
                        // If mob has burn stacks, it takes damage BEFORE attacking (Dragonhunter's Triple Flecha Flamígera)
                        if (mob.burning && mob.burnStacks > 0) {
                            const burnDamage = 35; // Fixed damage per attack attempt
                            this.damageMob(mob.id, burnDamage);
                            mob.burnStacks--;
                            console.log(`?? ${mob.name} tried to attack but took ${burnDamage} burn damage! ${mob.burnStacks} stacks left`);

                            if (mob.burnStacks === 0) {
                                mob.burning = false;
                                console.log(`?? ${mob.name} is no longer burning!`);
                            }
                        }

                        // Then mob attacks player normally
                        let finalDamage = mob.damage;
                        if (mob.damageReduction > 0) {
                            finalDamage *= (1 - mob.damageReduction / 100);
                        }
                        Player.takeDamage(Math.floor(finalDamage), mob.id);
                    }

                    // Update ability cooldown
                    if (mob.currentAbilityCooldown > 0) {
                        mob.currentAbilityCooldown -= deltaTime;
                    }

                    // Use ability if in range and cooldown ready (not when confused or player invisible)
                    if (mob.ability && !mob.confused && !mob.stunned && !mob.silenced && !Player.invisible && mob.currentAbilityCooldown <= 0 && dist < mob.abilityRange) {
                        this.useMobAbility(mob);
                        mob.currentAbilityCooldown = mob.abilityCooldown;
                    }
                });

                // Update projectiles
                this.projectiles = this.projectiles.filter(proj => {
                    proj.x += proj.vx * (deltaTime / 1000);
                    proj.y += proj.vy * (deltaTime / 1000);
                    proj.life -= deltaTime;

                    // Check collision with player (only for enemy projectiles)
                    if (!proj.isPlayerProjectile) {
                        const dx = Player.x - proj.x;
                        const dy = Player.y - proj.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 25 + proj.size) {
                            Player.takeDamage(proj.damage);

                            // NEW v19.11.2025: Apply Electrified effect from Storm Titan projectiles
                            if (proj.electrifies) {
                                Player.electrified = true;
                                Player.electrifiedTime = 2000; // 2 seconds stun
                                console.log('? Player is ELECTRIFIED! Stunned for 2s!');
                            }

                            return false;
                        }
                    } else {
                        // Check collision with mobs for player projectiles
                        const allMobs = [...this.mobs, ...this.bosses];

                        // Also check collision with dummies in practice mode
                        let allTargets = allMobs;
                        if (PracticeModeManager.active && TrainingDummySystem.dummies.length > 0) {
                            allTargets = [...allMobs, ...TrainingDummySystem.dummies.map(d => ({
                                ...d,
                                isDummy: true
                            }))];
                        }

                        for (let mob of allTargets) {
                            const dx = mob.x - proj.x;
                            const dy = mob.y - proj.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < mob.size + proj.size) {
                                // Special handling for Pilum (piercing projectile)
                                if (proj.isPilum && proj.piercing) {
                                    // Check if we already hit this enemy
                                    if (!proj.hitEnemies.has(mob.id)) {
                                        if (mob.isDummy) {
                                            TrainingDummySystem.damageDummy(mob.id, proj.damage);
                                        } else {
                                            this.damageMob(mob.id, proj.damage);
                                        }
                                        proj.hitEnemies.add(mob.id);

                                        // Apply armor reduction
                                        if (!mob.armorReduced) {
                                            mob.originalDamageReduction = mob.damageReduction || 0;
                                            mob.damageReduction = Math.max(0, mob.originalDamageReduction - proj.armorReduction);
                                            mob.armorReduced = true;

                                            // Restore armor after 8 seconds
                                            setTimeout(() => {
                                                if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                                    mob.damageReduction = mob.originalDamageReduction;
                                                    mob.armorReduced = false;
                                                }
                                            }, 8000);
                                        }

                                        // Apply bleeding effect
                                        mob.bleeding = true;
                                        mob.bleedDamage = proj.bleedDamage;
                                        mob.bleedDuration = proj.bleedDuration;
                                        mob.bleedStartTime = Date.now();

                                        // Bleeding damage over time
                                        if (!mob.bleedInterval) {
                                            mob.bleedInterval = setInterval(() => {
                                                if (mob.bleeding && (Date.now() - mob.bleedStartTime < mob.bleedDuration)) {
                                                    this.damageMob(mob.id, mob.bleedDamage);
                                                } else {
                                                    mob.bleeding = false;
                                                    clearInterval(mob.bleedInterval);
                                                    mob.bleedInterval = null;
                                                }
                                            }, 1000); // Damage every second
                                        }

                                        console.log(`??? Pilum atravesó a ${mob.name}! Sangrado y -40% armadura!`);
                                    }
                                    // Don't remove pilum, it continues through
                                }
                                // Special handling for Doru (Spartan spear - piercing projectile)
                                else if (proj.isDoru && proj.piercing) {
                                    if (!proj.hitEnemies.has(mob.id)) {
                                        if (mob.isDummy) {
                                            TrainingDummySystem.damageDummy(mob.id, proj.damage);
                                        } else {
                                            this.damageMob(mob.id, proj.damage);
                                        }
                                        proj.hitEnemies.add(mob.id);

                                        // Apply bleeding effect
                                        mob.bleeding = true;
                                        mob.bleedDamage = proj.bleedDamage;
                                        mob.bleedDuration = proj.bleedDuration;
                                        mob.bleedStartTime = Date.now();

                                        if (!mob.bleedInterval) {
                                            mob.bleedInterval = setInterval(() => {
                                                if (mob.bleeding && (Date.now() - mob.bleedStartTime < mob.bleedDuration)) {
                                                    this.damageMob(mob.id, mob.bleedDamage);
                                                } else {
                                                    mob.bleeding = false;
                                                    clearInterval(mob.bleedInterval);
                                                    mob.bleedInterval = null;
                                                }
                                            }, 1000);
                                        }

                                        console.log(`??? Doru atravesó a ${mob.name}! Sangrado espartano!`);
                                    }
                                    // Don't remove doru, it continues through
                                } else {
                                    // Normal projectile - remove after hit
                                    if (mob.isDummy) {
                                        TrainingDummySystem.damageDummy(mob.id, proj.damage);
                                    } else {
                                        this.damageMob(mob.id, proj.damage);
                                    }
                                    return false;
                                }
                            }
                        }
                    }

                    return proj.life > 0;
                });

                // Check if wave is complete
                if (this.mobs.length === 0 && this.bosses.length === 0) {
                    // Check for multi-boss dungeon completion
                    if (this.isMultiBossDungeon) {
                        // Initialize boss tracking if not exists
                        if (!this.defeatedBosses) this.defeatedBosses = [];

                        const allBossesDefeated = this.multiBossOrder.every(bossType =>
                            this.defeatedBosses.includes(bossType)
                        );

                        if (allBossesDefeated) {
                            // ... existing victory logic ...
                            console.log(`🏆 DUNGEON COMPLETE: ${this.selectedRaidName}!`);

                            if (!this.specialWaveNotifications) this.specialWaveNotifications = [];
                            this.specialWaveNotifications.push({
                                text: `🏆 ¡MAZMORRA COMPLETADA: ${this.selectedRaidName.toUpperCase()}! 🏆`,
                                startTime: Date.now(),
                                duration: 6000,
                                color: '#ffd700'
                            });

                            // Victory after 3 seconds
                            setTimeout(() => {
                                this.defeatedBosses = [];
                                this.isMultiBossDungeon = false; // Reset flag
                                this.isSpawningNextBoss = false;
                                this.showGameOverScreen(true);
                            }, 3000);
                            return;
                        } else if (!this.isSpawningNextBoss) {
                            // Find next boss to spawn
                            const nextBossIndex = this.defeatedBosses.length;
                            if (nextBossIndex < this.multiBossOrder.length) {
                                this.isSpawningNextBoss = true;
                                const nextBossType = this.multiBossOrder[nextBossIndex];
                                const bossData = this.mobTypes[nextBossType];

                                // Show boss approaching notification
                                if (!this.specialWaveNotifications) this.specialWaveNotifications = [];
                                this.specialWaveNotifications.push({
                                    text: `⚠️ SIGUIENTE JEFE: ${bossData ? bossData.name.toUpperCase() : nextBossType.toUpperCase()} (${nextBossIndex + 1}/${this.totalBossCount}) ⚠️`,
                                    startTime: Date.now(),
                                    duration: 4000,
                                    color: '#ff6b00'
                                });

                                // Spawn next boss after delay
                                const canvas = document.getElementById('game-canvas');
                                setTimeout(() => {
                                    this.spawnMob(nextBossType, canvas, this.mobTypes[nextBossType]?.isStationaryBoss);

                                    // Also spawn some support mobs (reduced)
                                    const mobTypes = this.customMobTypes;
                                    for (let i = 0; i < 3; i++) {
                                        const mobType = mobTypes[Math.floor(Math.random() * mobTypes.length)];
                                        this.spawnMob(mobType, canvas, false);
                                    }
                                    this.isSpawningNextBoss = false;
                                }, 2500);
                            }
                        }
                        // Don't continue to normal wave logic for multi-boss
                        return;
                    } else {
                        // Normal wave progression
                        this.wave++;

                        // Award class experience for completing wave
                        if (EquipmentManager.equippedRole && EquipmentManager.equippedRole.type === 'class') {
                            const classId = EquipmentManager.equippedRole.id;
                            const expReward = 50 + (this.wave * 10); // More exp for higher waves
                            ClassProgressionSystem.addClassExp(classId, expReward);
                            console.log(`⭐ +${expReward} EXP para ${classId} (Wave ${this.wave})`);
                        }

                        // Track wave survival for mastery missions
                        if (EquipmentManager.equippedRole && EquipmentManager.equippedRole.type === 'class') {
                            const classId = EquipmentManager.equippedRole.id;
                            // Use class-specific requirement IDs for wave survival
                            if (classId === 'class_wind_master') {
                                LoadoutManager.updateMissionProgress(classId, 'survive_raid', 1);
                            } else if (classId === 'class_gunslinger') {
                                // Gunslinger doesn't have wave survival requirement, skip
                            } else if (classId === 'class_ninja') {
                                LoadoutManager.updateMissionProgress(classId, 'survive_ninja_raid', 1);
                            }
                        }

                        this.spawnWave();
                    }
                }
            },

            useMobAbility(mob) {
                // Burn stacks are now only applied when mob attacks player (not when using abilities)

                if (mob.ability === 'tornado') {
                    // Shoot 3 projectiles in a spread
                    const angleToPlayer = Math.atan2(Player.y - mob.y, Player.x - mob.x);
                    for (let i = -1; i <= 1; i++) {
                        const angle = angleToPlayer + (i * 0.3);
                        this.projectiles.push({
                            x: mob.x,
                            y: mob.y,
                            vx: Math.cos(angle) * 200,
                            vy: Math.sin(angle) * 200,
                            size: 10,
                            damage: 15,
                            color: mob.color,
                            life: 3000
                        });
                    }
                    console.log('???', mob.name, 'used Tornado ability!');
                } else if (mob.ability === 'summon') {
                    // Summon a skeleton nearby
                    const canvas = document.getElementById('game-canvas');
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 50;
                    const skeleton = {
                        id: Date.now() + Math.random(),
                        type: 'skeleton',
                        x: mob.x + Math.cos(angle) * distance,
                        y: mob.y + Math.sin(angle) * distance,
                        ...this.mobTypes.skeleton,
                        currentAbilityCooldown: 0
                    };
                    this.mobs.push(skeleton);
                    console.log('??', mob.name, 'summoned a Skeleton!');
                } else if (mob.ability === 'fireball') {
                    // Fire Drake shoots a single powerful fireball
                    const angleToPlayer = Math.atan2(Player.y - mob.y, Player.x - mob.x);
                    this.projectiles.push({
                        x: mob.x,
                        y: mob.y,
                        vx: Math.cos(angleToPlayer) * 250,
                        vy: Math.sin(angleToPlayer) * 250,
                        size: 15,
                        damage: 25,
                        color: '#ff4500',
                        life: 4000
                    });
                    console.log('??', mob.name, 'shot a Fireball!');
                } else if (mob.ability === 'dragon_rage') {
                    // Ancient Dragon shoots 5 fireballs in a cone
                    const angleToPlayer = Math.atan2(Player.y - mob.y, Player.x - mob.x);
                    for (let i = -2; i <= 2; i++) {
                        const angle = angleToPlayer + (i * 0.2);
                        this.projectiles.push({
                            x: mob.x,
                            y: mob.y,
                            vx: Math.cos(angle) * 300,
                            vy: Math.sin(angle) * 300,
                            size: 18,
                            damage: 35,
                            color: '#8b0000',
                            life: 5000
                        });
                    }
                    console.log('??', mob.name, 'unleashed Dragon Rage!');
                } else if (mob.ability === 'blood_frenzy') {
                    // Blood Reaver - Frenzy
                    if (!mob.frenzied) {
                        mob.frenzied = true;
                        mob.originalColor = mob.color;
                        mob.color = '#ff0000'; // Bright red
                        mob.damage *= 1.5;
                        mob.speed *= 1.5;

                        // Check if EffectRenderer exists
                        if (typeof EffectRenderer !== 'undefined') {
                            EffectRenderer.playEffect('effect_explosion', mob.x, mob.y);
                        }

                        setTimeout(() => {
                            if (this.mobs.includes(mob)) {
                                mob.frenzied = false;
                                mob.color = mob.originalColor;
                                mob.damage /= 1.5;
                                mob.speed /= 1.5;
                            }
                        }, 3000);
                        console.log('???', mob.name, 'entered BLOOD FRENZY!');
                    }
                } else if (mob.ability === 'axe_throw') {
                    // Axe Thrower - Throws an axe
                    const angleToPlayer = Math.atan2(Player.y - mob.y, Player.x - mob.x);
                    this.projectiles.push({
                        x: mob.x,
                        y: mob.y,
                        vx: Math.cos(angleToPlayer) * 350,
                        vy: Math.sin(angleToPlayer) * 350,
                        size: 20,
                        damage: 30,
                        color: mob.color,
                        life: 3000
                    });
                    console.log('???', mob.name, 'threw an Axe!');
                } else if (mob.ability === 'ground_slam') {
                    // Warlord Colossus - Ground Slam
                    const slamRadius = 250;

                    // Telegraph
                    this.addAttackIndicator(mob.x, mob.y, slamRadius, slamRadius, 1000, '#8B0000', 'circle');

                    setTimeout(() => {
                        // Check player distance
                        const dx = Player.x - mob.x;
                        const dy = Player.y - mob.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < slamRadius) {
                            Player.takeDamage(50);

                            // Massive Knockback
                            const knockAngle = Math.atan2(dy, dx);
                            // Ensure Player stays in bounds or move function handles it
                            if (Player.move) {
                                Player.move(Math.cos(knockAngle) * 100, Math.sin(knockAngle) * 100);
                            } else {
                                Player.x += Math.cos(knockAngle) * 100;
                                Player.y += Math.sin(knockAngle) * 100;
                            }
                        }
                        console.log('???', mob.name, 'used GROUND SLAM!');
                    }, 1000);
                } else if (mob.ability === 'water_blast') {
                    // Water Elemental shoots water projectile
                    const angleToPlayer = Math.atan2(Player.y - mob.y, Player.x - mob.x);
                    this.projectiles.push({
                        x: mob.x,
                        y: mob.y,
                        vx: Math.cos(angleToPlayer) * 220,
                        vy: Math.sin(angleToPlayer) * 220,
                        size: 12,
                        damage: 18,
                        color: '#00d9ff',
                        life: 3500
                    });
                    console.log('??', mob.name, 'used Water Blast!');
                } else if (mob.ability === 'lightning_storm') {
                    // Storm Titan shoots lightning bolts - BUFFED v19.11.2025
                    // Phase 1: Cardinal directions (4 bolts)
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI * 2 / 4) * i;
                        const lineLength = 200;
                        this.addAttackIndicator(mob.x, mob.y, lineLength, 30, 700, '#ffbe0b', 'rect', angle);
                    }

                    setTimeout(() => {
                        for (let i = 0; i < 4; i++) {
                            const angle = (Math.PI * 2 / 4) * i;
                            this.projectiles.push({
                                x: mob.x,
                                y: mob.y,
                                vx: Math.cos(angle) * 280,
                                vy: Math.sin(angle) * 280,
                                size: 16,
                                damage: 35,
                                color: '#ffbe0b',
                                life: 4000,
                                electrifies: true // NEW: Applies Electrified status
                            });
                        }
                    }, 700);

                    // Phase 2: Diagonal directions (4 more bolts)
                    setTimeout(() => {
                        for (let i = 0; i < 4; i++) {
                            const angle = (Math.PI * 2 / 4) * i + Math.PI / 4;
                            const lineLength = 180;
                            this.addAttackIndicator(mob.x, mob.y, lineLength, 25, 600, '#ff8c00', 'rect', angle);
                        }
                    }, 400);

                    setTimeout(() => {
                        for (let i = 0; i < 4; i++) {
                            const angle = (Math.PI * 2 / 4) * i + Math.PI / 4;
                            this.projectiles.push({
                                x: mob.x,
                                y: mob.y,
                                vx: Math.cos(angle) * 260,
                                vy: Math.sin(angle) * 260,
                                size: 14,
                                damage: 28,
                                color: '#ff8c00',
                                life: 3800,
                                electrifies: true // NEW: Applies Electrified status
                            });
                        }
                    }, 1000);

                    // Phase 3: Circular wave (12 bolts) - NEW PATTERN!
                    setTimeout(() => {
                        const circleIndicator = this.addAttackIndicator(mob.x, mob.y, 100, 100, 500, '#ffff00', 'circle');

                        setTimeout(() => {
                            for (let i = 0; i < 12; i++) {
                                const angle = (Math.PI * 2 / 12) * i;
                                this.projectiles.push({
                                    x: mob.x,
                                    y: mob.y,
                                    vx: Math.cos(angle) * 240,
                                    vy: Math.sin(angle) * 240,
                                    size: 12,
                                    damage: 25,
                                    color: '#ffff00',
                                    life: 3500,
                                    electrifies: true // NEW: Applies Electrified status
                                });
                            }
                            console.log('?', mob.name, 'summoned ULTIMATE Lightning Storm! (24 bolts total)');
                        }, 500);
                    }, 1200);
                } else if (mob.ability === 'quick_slash') {
                    // Ronin Warrior dashes toward player
                    const angleToPlayer = Math.atan2(Player.y - mob.y, Player.x - mob.x);
                    mob.x += Math.cos(angleToPlayer) * 50;
                    mob.y += Math.sin(angleToPlayer) * 50;
                    console.log('??', mob.name, 'used Quick Slash!');
                } else if (mob.ability === 'blade_dance') {
                    // Shogun Lord spins and shoots blades
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 / 6) * i;
                        this.projectiles.push({
                            x: mob.x,
                            y: mob.y,
                            vx: Math.cos(angle) * 260,
                            vy: Math.sin(angle) * 260,
                            size: 14,
                            damage: 28,
                            color: '#8b0000',
                            life: 4500
                        });
                    }
                    console.log('??', mob.name, 'performed Blade Dance!');
                } else if (mob.ability === 'laser_burst') {
                    // Combat Drone shoots rapid laser bursts
                    const angleToPlayer = Math.atan2(Player.y - mob.y, Player.x - mob.x);
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            this.projectiles.push({
                                x: mob.x,
                                y: mob.y,
                                vx: Math.cos(angleToPlayer) * 280,
                                vy: Math.sin(angleToPlayer) * 280,
                                size: 8,
                                damage: 12,
                                color: '#00ffff',
                                life: 3000
                            });
                        }, i * 150);
                    }
                    console.log('??', mob.name, 'fired Laser Burst!');
                } else if (mob.ability === 'missile_barrage') {
                    // Mech Titan launches homing missiles
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 / 5) * i + Math.random() * 0.3;
                        this.projectiles.push({
                            x: mob.x,
                            y: mob.y,
                            vx: Math.cos(angle) * 240,
                            vy: Math.sin(angle) * 240,
                            size: 14,
                            damage: 32,
                            color: '#00ff00',
                            life: 4500
                        });
                    }
                    console.log('??', mob.name, 'launched Missile Barrage!');
                } else if (mob.ability === 'magic_bolt') {
                    // Arcane Wisp shoots magical projectile
                    const angleToPlayer = Math.atan2(Player.y - mob.y, Player.x - mob.x);
                    this.projectiles.push({
                        x: mob.x,
                        y: mob.y,
                        vx: Math.cos(angleToPlayer) * 200,
                        vy: Math.sin(angleToPlayer) * 200,
                        size: 10,
                        damage: 16,
                        color: '#9370db',
                        life: 3200
                    });
                    console.log('?', mob.name, 'cast Magic Bolt!');
                } else if (mob.ability === 'arcane_explosion') {
                    // Elder Sorcerer creates expanding arcane ring
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        this.projectiles.push({
                            x: mob.x,
                            y: mob.y,
                            vx: Math.cos(angle) * 220,
                            vy: Math.sin(angle) * 220,
                            size: 16,
                            damage: 28,
                            color: '#8b00ff',
                            life: 4200
                        });
                    }
                    console.log('??', mob.name, 'unleashed Arcane Explosion!');
                }
                // WIND MASTER MOB ABILITIES - EXTREMELY ANNOYING
                else if (mob.ability === 'toxic_dash') {
                    // Toxic Zephyr - Dashes toward player leaving poison trail
                    const angleToPlayer = Math.atan2(Player.y - mob.y, Player.x - mob.x);
                    const dashDistance = 150;

                    // Store starting position
                    const startX = mob.x;
                    const startY = mob.y;

                    // Dash toward player
                    mob.x += Math.cos(angleToPlayer) * dashDistance;
                    mob.y += Math.sin(angleToPlayer) * dashDistance;

                    // Leave poison trail (create toxic bubbles along path)
                    for (let i = 0; i < 3; i++) {
                        const t = (i + 1) / 4; // 0.25, 0.5, 0.75
                        const trailX = startX + (mob.x - startX) * t;
                        const trailY = startY + (mob.y - startY) * t;

                        // Create mini toxic bubble
                        if (!this.toxicBubbles) this.toxicBubbles = [];
                        this.toxicBubbles.push({
                            x: trailX,
                            y: trailY,
                            size: 25,
                            color: '#00ff88',
                            lifetime: 4000,
                            createdAt: Date.now(),
                            exploded: false
                        });
                    }

                    console.log('??', mob.name, 'dashed and left poison trail!');
                }
                else if (mob.ability === 'radiation_pulse') {
                    // Radioactive Cyclone - Pulses radiation in area
                    const allMobs = [...this.mobs, ...this.bosses];

                    // Create expanding radiation wave
                    for (let ring = 0; ring < 3; ring++) {
                        setTimeout(() => {
                            const radius = 100 + (ring * 60); // 100, 160, 220

                            // Check if player is in range
                            const dx = Player.x - mob.x;
                            const dy = Player.y - mob.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < radius) {
                                Player.takeDamage(12);
                                // Apply brief slow (FIXED v19.11.2025: Use baseSpeed to prevent permanent reduction)
                                Player.hasActiveSlowEffect = true;
                                Player.speed = Player.baseSpeed * 0.7;
                                setTimeout(() => {
                                    Player.speed = Player.baseSpeed;
                                    Player.hasActiveSlowEffect = false;
                                }, 1500);
                            }

                            // Visual projectiles in circle
                            for (let i = 0; i < 12; i++) {
                                const angle = (Math.PI * 2 / 12) * i;
                                this.projectiles.push({
                                    x: mob.x + Math.cos(angle) * radius * 0.5,
                                    y: mob.y + Math.sin(angle) * radius * 0.5,
                                    vx: Math.cos(angle) * 150,
                                    vy: Math.sin(angle) * 150,
                                    size: 8,
                                    damage: 10,
                                    color: '#39ff14',
                                    life: 1500
                                });
                            }
                        }, ring * 300);
                    }

                    console.log('??', mob.name, 'pulsed radiation waves!');
                }
                else if (mob.ability === 'tempest_fury') {
                    // Tempest Lord - Multi-phase devastating attack
                    console.log('???', mob.name, 'unleashing Tempest Fury!');

                    // NEW v19.11.2025: Show attack indicators for each phase
                    // Phase 1 indicator: Pull effect (circular)
                    this.addAttackIndicator(mob.x, mob.y, 80, 80, 1000, '#00ffaa', 'circle');

                    // Phase 2 indicators: 16 directional lines for projectiles
                    for (let i = 0; i < 16; i++) {
                        const angle = (Math.PI * 2 / 16) * i;
                        const lineLength = 150;

                        setTimeout(() => {
                            // Line starts from boss position and extends in the angle direction
                            this.addAttackIndicator(mob.x, mob.y, lineLength, 8, 500, '#00ffaa', 'line', angle);
                        }, 1000);
                    }

                    // Phase 1: Pull player slightly (0-1s)
                    const pullDuration = 1000;
                    const pullStartTime = Date.now();
                    const pullInterval = setInterval(() => {
                        if (Date.now() - pullStartTime >= pullDuration) {
                            clearInterval(pullInterval);
                        } else {
                            const dx = mob.x - Player.x;
                            const dy = mob.y - Player.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0 && dist < 400) {
                                Player.x += (dx / dist) * 3;
                                Player.y += (dy / dist) * 3;
                            }
                        }
                    }, 16);

                    // Phase 2: Toxic wind spiral (1.5s)
                    setTimeout(() => {
                        for (let i = 0; i < 16; i++) {
                            const angle = (Math.PI * 2 / 16) * i;
                            this.projectiles.push({
                                x: mob.x,
                                y: mob.y,
                                vx: Math.cos(angle) * 200,
                                vy: Math.sin(angle) * 200,
                                size: 14,
                                damage: 25,
                                color: '#00ffaa',
                                life: 4000,
                                isRadioactive: true
                            });
                        }
                    }, 1500);

                    // Phase 3: Summon toxic zephyrs if below 50% HP (2.5s)
                    setTimeout(() => {
                        if (mob.hp / mob.maxHp < 0.5 && mob.summonMinions) {
                            for (let i = 0; i < 2; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = 100;
                                const minion = {
                                    id: Date.now() + Math.random(),
                                    type: 'toxic_zephyr',
                                    x: mob.x + Math.cos(angle) * distance,
                                    y: mob.y + Math.sin(angle) * distance,
                                    ...this.mobTypes.toxic_zephyr,
                                    currentAbilityCooldown: 0
                                };
                                this.mobs.push(minion);
                            }
                            console.log('??? Tempest Lord summoned Toxic Zephyrs!');
                        }
                    }, 2500);

                    // Phase 4: Teleport randomly (3s)
                    if (mob.phaseShift) {
                        setTimeout(() => {
                            const canvas = document.getElementById('game-canvas');
                            mob.x = 100 + Math.random() * (canvas.width - 200);
                            mob.y = 100 + Math.random() * (canvas.height - 200);
                            console.log('??? Tempest Lord teleported!');
                        }, 3000);
                    }
                }
                // WILD BERSERKER MOB ABILITIES
                else if (mob.ability === 'blood_frenzy') {
                    // Blood Reaver enters frenzy, increasing speed and damage
                    const angleToPlayer = Math.atan2(Player.y - mob.y, Player.x - mob.x);

                    // Dash toward player
                    mob.x += Math.cos(angleToPlayer) * 60;
                    mob.y += Math.sin(angleToPlayer) * 60;

                    // Temporary speed and damage boost
                    if (!mob.frenzied) {
                        mob.originalSpeed = mob.speed;
                        mob.originalDamage = mob.damage;
                    }
                    mob.speed = mob.originalSpeed * 1.3;
                    mob.damage = mob.originalDamage * 1.2;
                    mob.frenzied = true;

                    setTimeout(() => {
                        if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                            mob.speed = mob.originalSpeed;
                            mob.damage = mob.originalDamage;
                            mob.frenzied = false;
                        }
                    }, 3000);

                    console.log('??', mob.name, 'entered Blood Frenzy! +30% speed, +20% damage!');
                }
                else if (mob.ability === 'axe_throw') {
                    // Axe Thrower throws 3 axes in a spread
                    const angleToPlayer = Math.atan2(Player.y - mob.y, Player.x - mob.x);

                    for (let i = -1; i <= 1; i++) {
                        const angle = angleToPlayer + (i * 0.3);
                        this.projectiles.push({
                            x: mob.x,
                            y: mob.y,
                            vx: Math.cos(angle) * 300,
                            vy: Math.sin(angle) * 300,
                            size: 16,
                            damage: 22,
                            color: '#ff4500',
                            life: 3500
                        });
                    }
                    console.log('??', mob.name, 'threw 3 axes!');
                }
                else if (mob.ability === 'ground_slam') {
                    // Warlord Colossus slams ground, creating shockwaves
                    console.log('??', mob.name, 'used Ground Slam!');

                    // Show attack indicator
                    this.addAttackIndicator(mob.x, mob.y, 200, 200, 800, '#8b0000', 'circle');

                    setTimeout(() => {
                        // Create 3 expanding shockwave rings
                        for (let ring = 0; ring < 3; ring++) {
                            setTimeout(() => {
                                const radius = 80 + (ring * 60);

                                // Check if player is in range
                                const dx = Player.x - mob.x;
                                const dy = Player.y - mob.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist < radius) {
                                    Player.takeDamage(30);
                                    // Knockback
                                    const knockAngle = Math.atan2(dy, dx);
                                    Player.x += Math.cos(knockAngle) * 40;
                                    Player.y += Math.sin(knockAngle) * 40;
                                }

                                // Visual projectiles in circle
                                for (let i = 0; i < 16; i++) {
                                    const angle = (Math.PI * 2 / 16) * i;
                                    this.projectiles.push({
                                        x: mob.x + Math.cos(angle) * radius * 0.5,
                                        y: mob.y + Math.sin(angle) * radius * 0.5,
                                        vx: Math.cos(angle) * 180,
                                        vy: Math.sin(angle) * 180,
                                        size: 12,
                                        damage: 25,
                                        color: '#8b0000',
                                        life: 2000
                                    });
                                }
                            }, ring * 400);
                        }
                    }, 800);

                    // Summon Blood Reavers if below 50% HP
                    if (mob.hp / mob.maxHp < 0.5 && mob.summonMinions) {
                        setTimeout(() => {
                            for (let i = 0; i < 2; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = 100;
                                const minion = {
                                    id: Date.now() + Math.random(),
                                    type: 'blood_reaver',
                                    x: mob.x + Math.cos(angle) * distance,
                                    y: mob.y + Math.sin(angle) * distance,
                                    ...this.mobTypes.blood_reaver,
                                    currentAbilityCooldown: 0
                                };
                                this.mobs.push(minion);
                            }
                            console.log('?? Warlord Colossus summoned Blood Reavers!');
                        }, 1200);
                    }
                }
                // SHADOW NINJA MOB ABILITIES
                else if (mob.ability === 'shadow_strike') {
                    // Shadow Assassin dashes and strikes
                    const angleToPlayer = Math.atan2(Player.y - mob.y, Player.x - mob.x);

                    // Become invisible briefly
                    mob.invisible = true;
                    setTimeout(() => {
                        if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                            mob.invisible = false;
                        }
                    }, 1000);

                    // Dash toward player
                    mob.x += Math.cos(angleToPlayer) * 80;
                    mob.y += Math.sin(angleToPlayer) * 80;

                    // Critical strike projectile
                    this.projectiles.push({
                        x: mob.x,
                        y: mob.y,
                        vx: Math.cos(angleToPlayer) * 350,
                        vy: Math.sin(angleToPlayer) * 350,
                        size: 14,
                        damage: 35,
                        color: '#2f2f2f',
                        life: 2500
                    });

                    console.log('??', mob.name, 'used Shadow Strike!');
                }
                else if (mob.ability === 'smoke_bomb') {
                    // Smoke Phantom creates smoke cloud
                    console.log('??', mob.name, 'threw Smoke Bomb!');

                    // Create smoke cloud at mob position
                    const smokeCloud = {
                        x: mob.x,
                        y: mob.y,
                        radius: 70,
                        duration: 5000,
                        startTime: Date.now()
                    };

                    if (!this.smokeClouds) this.smokeClouds = [];
                    this.smokeClouds.push(smokeCloud);

                    // Check for player in smoke (confuses and damages)
                    const smokeInterval = setInterval(() => {
                        if (Date.now() - smokeCloud.startTime > smokeCloud.duration) {
                            clearInterval(smokeInterval);
                            this.smokeClouds = this.smokeClouds.filter(s => s !== smokeCloud);
                            return;
                        }

                        const dx = Player.x - smokeCloud.x;
                        const dy = Player.y - smokeCloud.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < smokeCloud.radius) {
                            Player.takeDamage(5);
                        }
                    }, 500);

                    // Teleport chance
                    if (Math.random() < mob.teleportChance) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 100 + Math.random() * 50;
                        mob.x += Math.cos(angle) * distance;
                        mob.y += Math.sin(angle) * distance;
                        console.log('??', mob.name, 'teleported!');
                    }
                }
                else if (mob.ability === 'shadow_realm') {
                    // Shadow Emperor creates shadow realm
                    console.log('??', mob.name, 'opened Shadow Realm!');

                    // Show attack indicator
                    this.addAttackIndicator(mob.x, mob.y, 250, 250, 1000, '#000000', 'circle');

                    setTimeout(() => {
                        // Create shadow clones
                        if (mob.shadowClones) {
                            for (let i = 0; i < 3; i++) {
                                const angle = (Math.PI * 2 / 3) * i;
                                const distance = 120;

                                // Clone shoots projectile toward player
                                const cloneX = mob.x + Math.cos(angle) * distance;
                                const cloneY = mob.y + Math.sin(angle) * distance;

                                const angleToPlayer = Math.atan2(Player.y - cloneY, Player.x - cloneX);
                                this.projectiles.push({
                                    x: cloneX,
                                    y: cloneY,
                                    vx: Math.cos(angleToPlayer) * 280,
                                    vy: Math.sin(angleToPlayer) * 280,
                                    size: 12,
                                    damage: 28,
                                    color: '#000000',
                                    life: 3500
                                });
                            }
                        }

                        // Damage and slow player in range
                        const dx = Player.x - mob.x;
                        const dy = Player.y - mob.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 250) {
                            Player.takeDamage(35);
                            // Slow player
                            Player.hasActiveSlowEffect = true;
                            Player.speed = Player.baseSpeed * 0.6;
                            setTimeout(() => {
                                Player.speed = Player.baseSpeed;
                                Player.hasActiveSlowEffect = false;
                            }, 3000);
                        }
                    }, 1000);

                    // Summon Shadow Assassins if below 50% HP
                    if (mob.hp / mob.maxHp < 0.5 && mob.summonMinions) {
                        setTimeout(() => {
                            for (let i = 0; i < 2; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = 100;
                                const minion = {
                                    id: Date.now() + Math.random(),
                                    type: 'shadow_assassin',
                                    x: mob.x + Math.cos(angle) * distance,
                                    y: mob.y + Math.sin(angle) * distance,
                                    ...this.mobTypes.shadow_assassin,
                                    currentAbilityCooldown: 0
                                };
                                this.mobs.push(minion);
                            }
                            console.log('?? Shadow Emperor summoned Shadow Assassins!');
                        }, 1500);
                    }

                    // Phase shift teleport
                    if (mob.phaseShift && Math.random() < 0.3) {
                        setTimeout(() => {
                            const canvas = document.getElementById('game-canvas');
                            mob.x = 100 + Math.random() * (canvas.width - 200);
                            mob.y = 100 + Math.random() * (canvas.height - 200);
                            console.log('?? Shadow Emperor phase shifted!');
                        }, 2000);
                    }
                }
                // ===== AETHER DRAGON ABILITIES =====
                else if (mob.ability === 'aether_abilities') {
                    this.useAetherDragonAbility(mob);
                }
                // ===== TAURHA ABILITIES =====
                else if (mob.ability === 'taurha_abilities') {
                    this.useTaurhaAbility(mob);
                }
            },

            useAetherDragonAbility(dragon) {
                // Check for Destruction Phase (below 30% HP)
                const hpPercent = dragon.hp / dragon.maxHp;

                if (hpPercent < 0.3 && !dragon.destructionPhaseActive && !dragon.destructionShieldActive) {
                    this.aetherDragonDestructionPhase(dragon);
                    return;
                }

                // Don't use other abilities during destruction phase
                if (dragon.destructionShieldActive) return;

                // Rotate through abilities
                const abilities = ['death_ray', 'ether_explosion', 'cursed_barrier'];
                const abilityIndex = dragon.abilityRotation % abilities.length;
                const selectedAbility = abilities[abilityIndex];
                dragon.abilityRotation++;

                switch (selectedAbility) {
                    case 'death_ray':
                        this.aetherDragonDeathRay(dragon);
                        break;
                    case 'ether_explosion':
                        this.aetherDragonEtherExplosion(dragon);
                        break;
                    case 'cursed_barrier':
                        this.aetherDragonCursedBarrier(dragon);
                        break;
                }
            },

            aetherDragonDeathRay(dragon) {
                console.log('?? Dragón del Éter: ¡RAYO DE MUERTE!');

                // Phase 1: Charging (2 seconds)
                dragon.deathRayCharging = true;
                dragon.deathRayTarget = { x: Player.x, y: Player.y };

                // Visual charging effect
                const chargingInterval = setInterval(() => {
                    if (!dragon.deathRayCharging) {
                        clearInterval(chargingInterval);
                        return;
                    }

                    // Purple particles gathering
                    for (let i = 0; i < 3; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 100 + Math.random() * 50;
                        this.projectiles.push({
                            x: dragon.x + Math.cos(angle) * distance,
                            y: dragon.y + Math.sin(angle) * distance,
                            vx: -Math.cos(angle) * 150,
                            vy: -Math.sin(angle) * 150,
                            size: 6,
                            damage: 0,
                            color: '#9370DB',
                            life: 800,
                            isPlayerProjectile: false,
                            isParticle: true
                        });
                    }
                }, 100);

                // Show attack indicator line
                const angleToTarget = Math.atan2(dragon.deathRayTarget.y - dragon.y, dragon.deathRayTarget.x - dragon.x);
                this.addAttackIndicator(dragon.x, dragon.y, 600, 40, 2000, '#9370DB', 'line', angleToTarget);

                // Phase 2: Fire the ray (after 2 seconds)
                setTimeout(() => {
                    dragon.deathRayCharging = false;
                    dragon.deathRayCharged = true;
                    clearInterval(chargingInterval);

                    // Create massive death ray
                    const angle = Math.atan2(dragon.deathRayTarget.y - dragon.y, dragon.deathRayTarget.x - dragon.x);

                    // Main ray projectile
                    this.projectiles.push({
                        x: dragon.x,
                        y: dragon.y,
                        vx: Math.cos(angle) * 500,
                        vy: Math.sin(angle) * 500,
                        size: 40,
                        damage: 60,
                        color: '#9370DB',
                        life: 3000,
                        isPlayerProjectile: false,
                        isDeathRay: true,
                        piercing: true,
                        appliesCurse: true,
                        curseDuration: 4000,
                        knockbackForce: 150
                    });

                    // Ray trail particles
                    for (let i = 0; i < 20; i++) {
                        setTimeout(() => {
                            this.projectiles.push({
                                x: dragon.x,
                                y: dragon.y,
                                vx: Math.cos(angle) * (450 + Math.random() * 100),
                                vy: Math.sin(angle) * (450 + Math.random() * 100),
                                size: 15 + Math.random() * 10,
                                damage: 0,
                                color: '#9370DB',
                                life: 1500,
                                isPlayerProjectile: false,
                                isParticle: true
                            });
                        }, i * 50);
                    }

                    console.log('?? ¡Rayo de Muerte disparado!');

                    setTimeout(() => {
                        dragon.deathRayCharged = false;
                    }, 1000);
                }, 2000);
            },

            aetherDragonEtherExplosion(dragon) {
                console.log('?? Dragón del Éter: ¡EXPLOSIÓN ÉTER!');

                // Phase 1: Brief charge (1 second)
                dragon.etherExplosionCharging = true;

                // Pulsing purple aura
                const pulseInterval = setInterval(() => {
                    if (!dragon.etherExplosionCharging) {
                        clearInterval(pulseInterval);
                        return;
                    }

                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        this.projectiles.push({
                            x: dragon.x,
                            y: dragon.y,
                            vx: Math.cos(angle) * 80,
                            vy: Math.sin(angle) * 80,
                            size: 8,
                            damage: 0,
                            color: '#9370DB',
                            life: 500,
                            isPlayerProjectile: false,
                            isParticle: true
                        });
                    }
                }, 200);

                // Show attack indicator
                this.addAttackIndicator(dragon.x, dragon.y, 180, 180, 1000, '#9370DB', 'circle');

                // Phase 2: Explosion (after 1 second)
                setTimeout(() => {
                    dragon.etherExplosionCharging = false;
                    clearInterval(pulseInterval);

                    // Create explosion
                    for (let ring = 0; ring < 3; ring++) {
                        setTimeout(() => {
                            const radius = 60 + (ring * 60); // 60, 120, 180

                            // Check if player is in range
                            const dx = Player.x - dragon.x;
                            const dy = Player.y - dragon.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < radius) {
                                Player.takeDamage(45);
                                // Apply Curse for 2 seconds
                                this.applyCurseToPlayer(2000);
                            }

                            // Visual explosion projectiles
                            for (let i = 0; i < 16; i++) {
                                const angle = (Math.PI * 2 / 16) * i;
                                this.projectiles.push({
                                    x: dragon.x + Math.cos(angle) * radius * 0.5,
                                    y: dragon.y + Math.sin(angle) * radius * 0.5,
                                    vx: Math.cos(angle) * 200,
                                    vy: Math.sin(angle) * 200,
                                    size: 12,
                                    damage: 0,
                                    color: '#9370DB',
                                    life: 1500,
                                    isPlayerProjectile: false,
                                    isParticle: true
                                });
                            }
                        }, ring * 200);
                    }

                    console.log('?? ¡Explosión Éter detonada!');
                }, 1000);
            },

            aetherDragonCursedBarrier(dragon) {
                console.log('?? Dragón del Éter: ¡BARRERA MALDITA!');

                dragon.cursedBarrierActive = true;
                dragon.cursedBarrierAngle = 0;

                const duration = 4000; // 4 seconds
                const startTime = Date.now();

                // Create rotating cursed trail
                const barrierInterval = setInterval(() => {
                    if (Date.now() - startTime >= duration) {
                        clearInterval(barrierInterval);
                        dragon.cursedBarrierActive = false;
                        console.log('?? Barrera Maldita terminada');
                        return;
                    }

                    // Rotate angle
                    dragon.cursedBarrierAngle += 0.15;

                    // Create trail particles
                    const radius = 100;
                    for (let i = 0; i < 8; i++) {
                        const angle = dragon.cursedBarrierAngle + (Math.PI * 2 / 8) * i;
                        const trailX = dragon.x + Math.cos(angle) * radius;
                        const trailY = dragon.y + Math.sin(angle) * radius;

                        // Check if player touches the trail
                        const dx = Player.x - trailX;
                        const dy = Player.y - trailY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 30) {
                            Player.takeDamage(15);
                            // Apply Curse for 2 seconds (stacks)
                            this.applyCurseToPlayer(2000);
                        }

                        // Visual trail
                        this.projectiles.push({
                            x: trailX,
                            y: trailY,
                            vx: 0,
                            vy: 0,
                            size: 20,
                            damage: 0,
                            color: '#9370DB',
                            life: 300,
                            isPlayerProjectile: false,
                            isParticle: true,
                            isCursedTrail: true
                        });
                    }
                }, 50);
            },

            aetherDragonDestructionPhase(dragon) {
                console.log('?? ¡DRAGÓN DEL ÉTER: DESTRUCCIÓN PARCIAL!');

                dragon.destructionPhaseActive = true;
                dragon.destructionShieldActive = true;

                // Make dragon invincible
                dragon.invincible = true;

                // Create purple shield visual
                dragon.destructionShield = {
                    active: true,
                    radius: 120,
                    pulsePhase: 0
                };

                // Summon 4 Aether Minions
                const minionPositions = [
                    { angle: 0 },
                    { angle: Math.PI / 2 },
                    { angle: Math.PI },
                    { angle: Math.PI * 1.5 }
                ];

                dragon.summonedMinions = [];

                minionPositions.forEach((pos, index) => {
                    const distance = 200;
                    const minionX = dragon.x + Math.cos(pos.angle) * distance;
                    const minionY = dragon.y + Math.sin(pos.angle) * distance;

                    const minion = {
                        id: Date.now() + Math.random(),
                        type: 'aether_minion',
                        name: 'Sirviente del Éter',
                        icon: '??',
                        x: minionX,
                        y: minionY,
                        hp: 80,
                        maxHp: 80,
                        speed: 70,
                        damage: 20,
                        color: '#9370DB',
                        size: 25,
                        isBoss: false,
                        currentAbilityCooldown: 0,
                        isAetherMinion: true,
                        parentDragon: dragon
                    };

                    this.mobs.push(minion);
                    dragon.summonedMinions.push(minion.id);
                });

                console.log('?? ¡4 Sirvientes del Éter invocados! ¡Elimínalos rápido!');

                // Check minions every second
                const checkInterval = setInterval(() => {
                    // Count alive minions
                    const aliveMinions = this.mobs.filter(m =>
                        dragon.summonedMinions.includes(m.id)
                    );

                    // If all minions dead, break shield and explode
                    if (aliveMinions.length === 0) {
                        clearInterval(checkInterval);

                        console.log('?? ¡Todos los sirvientes eliminados! ¡El escudo se rompe!');

                        // Remove shield
                        dragon.destructionShieldActive = false;
                        dragon.invincible = false;
                        dragon.destructionShield = null;

                        // Massive explosion
                        this.addAttackIndicator(dragon.x, dragon.y, 300, 300, 1000, '#9370DB', 'circle');

                        setTimeout(() => {
                            const dx = Player.x - dragon.x;
                            const dy = Player.y - dragon.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < 300) {
                                // 90% of player's current HP as damage
                                const explosionDamage = Math.floor(Player.hp * 0.9);
                                Player.takeDamage(explosionDamage);
                                console.log(`?? ¡Explosión masiva! ${explosionDamage} de daño!`);

                                // Knockback
                                const angle = Math.atan2(dy, dx);
                                Player.x += Math.cos(angle) * 100;
                                Player.y += Math.sin(angle) * 100;
                            }

                            // Explosion particles
                            for (let i = 0; i < 50; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                this.projectiles.push({
                                    x: dragon.x,
                                    y: dragon.y,
                                    vx: Math.cos(angle) * (200 + Math.random() * 200),
                                    vy: Math.sin(angle) * (200 + Math.random() * 200),
                                    size: 15 + Math.random() * 15,
                                    damage: 0,
                                    color: '#9370DB',
                                    life: 2000,
                                    isPlayerProjectile: false,
                                    isParticle: true
                                });
                            }
                        }, 1000);
                    }
                }, 500);
            },

            applyCurseToPlayer(duration) {
                if (!Player.cursed) {
                    Player.cursed = true;
                    Player.curseEndTime = Date.now() + duration;
                    Player.curseStacks = 1;
                    console.log('?? ¡Jugador MALDITO! Recibirá el doble de daño!');
                } else {
                    // Stack curse (extend duration)
                    Player.curseEndTime = Math.max(Player.curseEndTime, Date.now() + duration);
                    Player.curseStacks = (Player.curseStacks || 1) + 1;
                    console.log(`?? ¡Maldición acumulada! (x${Player.curseStacks})`);
                }
            },

            // ===== TAURHA ABILITIES =====
            useTaurhaAbility(taurha) {
                if (!taurha.taurhaAbilityTimers) {
                    taurha.taurhaAbilityTimers = {
                        sweep: 0,
                        strike_frenzy: 0,
                        sandstorm: 0,
                        pillar_cannon: 0
                    };
                }

                const now = Date.now();
                const phaseTwo = taurha.hp <= (taurha.maxHp * 0.5);
                if (phaseTwo) {
                    taurha.phaseTwoVisual = true;
                }

                // Titan Dive: one-time trigger when Taurha reaches 50% HP.
                if (phaseTwo && !taurha.phaseTwoTriggered) {
                    taurha.phaseTwoTriggered = true;
                    taurha.lastAbilityUsed = 'titan_dive';
                    this.taurhaTitanDive(taurha, true);
                    return;
                }

                const cooldowns = {
                    sweep: 10000,
                    strike_frenzy: 25000,
                    sandstorm: 25000,
                    pillar_cannon: 28000
                };

                // Sandstorm disabled in phase 2, Pillar Cannon unlocked in phase 2.
                const rotation = phaseTwo
                    ? ['sweep', 'strike_frenzy', 'pillar_cannon']
                    : ['sweep', 'strike_frenzy', 'sandstorm'];

                for (let offset = 0; offset < rotation.length; offset++) {
                    const index = (taurha.abilityRotation + offset) % rotation.length;
                    const abilityId = rotation[index];
                    if (now < (taurha.taurhaAbilityTimers[abilityId] || 0)) continue;

                    taurha.abilityRotation = (index + 1) % rotation.length;
                    taurha.taurhaAbilityTimers[abilityId] = now + cooldowns[abilityId];
                    taurha.lastAbilityUsed = abilityId;

                    if (abilityId === 'sweep') this.taurhaSweep(taurha);
                    else if (abilityId === 'strike_frenzy') this.taurhaStrikeFrenzy(taurha);
                    else if (abilityId === 'sandstorm') this.taurhaSandstorm(taurha);
                    else if (abilityId === 'pillar_cannon') this.taurhaPillarCannon(taurha);
                    return;
                }
            },

            taurhaSweep(taurha) {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('taurha_sweep');
                const angle = Math.atan2(Player.y - taurha.y, Player.x - taurha.x);
                const hitX = taurha.x + Math.cos(angle) * 145;
                const hitY = taurha.y + Math.sin(angle) * 145;
                const radius = 185;

                this.addAttackIndicator(hitX, hitY, radius, radius, 650, '#b68d5f', 'circle');
                setTimeout(() => {
                    this.taurhaResolveImpact(hitX, hitY, radius, Math.round(taurha.damage * 1.15), '#8b5d33', {
                        knockback: 70
                    });
                }, 650);
            },

            taurhaStrikeFrenzy(taurha) {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('taurha_strike_frenzy');
                const baseAngle = Math.atan2(Player.y - taurha.y, Player.x - taurha.x);

                // 3 heavy alternating strikes in large radius.
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const offset = (i % 2 === 0 ? 0.55 : -0.55);
                        const angle = baseAngle + offset;
                        const hitX = taurha.x + Math.cos(angle) * 155;
                        const hitY = taurha.y + Math.sin(angle) * 155;
                        const radius = 190;
                        this.addAttackIndicator(hitX, hitY, radius, radius, 500, '#cc8a48', 'circle');
                        setTimeout(() => {
                            this.taurhaResolveImpact(hitX, hitY, radius, Math.round(taurha.damage * 1.35), '#cd853f', {
                                knockback: 55
                            });
                        }, 500);
                    }, i * 360);
                }

                // 7 adjacent triangles twice (14 directional sweeps).
                const chainStart = 1250;
                const sweepsPerCycle = 7;
                const cycles = 2;
                for (let cycle = 0; cycle < cycles; cycle++) {
                    for (let i = 0; i < sweepsPerCycle; i++) {
                        const seq = cycle * sweepsPerCycle + i;
                        setTimeout(() => {
                            const spread = (i - 3) * 0.28;
                            const angle = baseAngle + spread + (cycle * 0.12);
                            const hitX = taurha.x + Math.cos(angle) * 220;
                            const hitY = taurha.y + Math.sin(angle) * 220;
                            const radius = 120;
                            this.addAttackIndicator(hitX, hitY, radius, radius, 360, '#9a6a3d', 'circle');
                            setTimeout(() => {
                                this.taurhaResolveImpact(hitX, hitY, radius, Math.round(taurha.damage * 0.95), '#8B7355');
                            }, 360);
                        }, chainStart + seq * 170);
                    }
                }
            },

            taurhaSandstorm(taurha) {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('taurha_sandstorm');
                // Disabled once Taurha enters phase 2.
                if (taurha.phaseTwoTriggered) return;

                const centerX = Player.x;
                const centerY = Player.y;
                const tornadoRadius = 230;
                this.addAttackIndicator(centerX, centerY, tornadoRadius, tornadoRadius, 1000, '#d3a45a', 'circle');

                // 25 meteors with poison in medium radius.
                const meteorCount = 25;
                for (let i = 0; i < meteorCount; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * 190;
                        const x = centerX + Math.cos(angle) * dist;
                        const y = centerY + Math.sin(angle) * dist;

                        this.addAttackIndicator(x, y, 70, 70, 640, '#cfa26a', 'circle');
                        setTimeout(() => {
                            this.taurhaResolveImpact(x, y, 70, Math.max(12, Math.round(taurha.damage * 0.35)), '#b9894f', {
                                poisonDuration: 4000,
                                poisonDamage: 8,
                                poisonTickInterval: 500
                            });
                        }, 640);
                    }, 900 + i * 95);
                }

                // Final pillar slam (x10 style finisher) in massive radius.
                setTimeout(() => {
                    this.addAttackIndicator(taurha.x, taurha.y, 340, 340, 900, '#7a5230', 'circle');
                    setTimeout(() => {
                        this.taurhaResolveImpact(taurha.x, taurha.y, 340, Math.round(taurha.damage * 2.5), '#6a4528', {
                            knockback: 120
                        });
                    }, 900);
                }, 3600);
            },

            taurhaTitanDive(taurha, phaseTrigger = false) {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('taurha_titan_dive');
                const targetX = Player.x;
                const targetY = Player.y;
                const radius = 430;
                taurha.phaseTwoVisual = true;
                if (phaseTrigger) taurha.phaseTwoTriggered = true;

                this.addAttackIndicator(targetX, targetY, radius, radius, 1200, '#58ff95', 'circle');
                setTimeout(() => {
                    taurha.x = targetX;
                    taurha.y = targetY;
                    this.taurhaResolveImpact(targetX, targetY, radius, Math.round(taurha.damage * 2.8), '#3adf7f', {
                        knockback: 150
                    });
                }, 1200);
            },

            taurhaPillarCannon(taurha) {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('taurha_pillar_cannon');
                const initialTargets = [];
                const baseAngle = Math.random() * Math.PI * 2;
                const centerX = Player.x;
                const centerY = Player.y;

                // Initial 3 meteors.
                for (let i = 0; i < 3; i++) {
                    const angle = baseAngle + (Math.PI * 2 / 3) * i;
                    initialTargets.push({
                        x: centerX + Math.cos(angle) * 120,
                        y: centerY + Math.sin(angle) * 120
                    });
                }

                const levels = [initialTargets];
                for (let level = 0; level < 2; level++) {
                    const next = [];
                    levels[level].forEach((target) => {
                        for (let i = 0; i < 3; i++) {
                            const a = Math.random() * Math.PI * 2;
                            const d = 65 + Math.random() * 70;
                            next.push({
                                x: target.x + Math.cos(a) * d,
                                y: target.y + Math.sin(a) * d
                            });
                        }
                    });
                    levels.push(next);
                }

                // Wave 0/1 are bounce/split visuals. Wave 2 contains final 27 impacts with poison.
                levels.forEach((targets, level) => {
                    targets.forEach((target, idx) => {
                        const delay = level * 760 + idx * 70;
                        setTimeout(() => {
                            const radius = level === 2 ? 82 : 56;
                            const color = level === 2 ? '#6ae38f' : '#7d5f43';
                            this.addAttackIndicator(target.x, target.y, radius, radius, 620, color, 'circle');
                            setTimeout(() => {
                                if (level === 2) {
                                    this.taurhaResolveImpact(
                                        target.x,
                                        target.y,
                                        radius,
                                        Math.round(taurha.damage * 1.55),
                                        '#59cd78',
                                        {
                                            poisonDuration: 4000,
                                            poisonDamage: 10,
                                            poisonTickInterval: 500
                                        }
                                    );
                                } else {
                                    for (let p = 0; p < 8; p++) {
                                        const a = (Math.PI * 2 / 8) * p;
                                        this.projectiles.push({
                                            x: target.x,
                                            y: target.y,
                                            vx: Math.cos(a) * (110 + level * 35),
                                            vy: Math.sin(a) * (110 + level * 35),
                                            size: 6,
                                            damage: 0,
                                            color: '#8B7355',
                                            life: 600,
                                            isPlayerProjectile: false,
                                            isParticle: true
                                        });
                                    }
                                }
                            }, 620);
                        }, delay);
                    });
                });
            },

            taurhaResolveImpact(x, y, radius, damage, particleColor = '#8B7355', options = {}) {
                const dx = Player.x - x;
                const dy = Player.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < radius) {
                    Player.takeDamage(damage);

                    if (options.knockback) {
                        const kAngle = Math.atan2(dy, dx);
                        Player.x += Math.cos(kAngle) * options.knockback;
                        Player.y += Math.sin(kAngle) * options.knockback;
                    }

                    if (options.poisonDuration) {
                        this.taurhaApplyPoisonToPlayer(
                            options.poisonDuration,
                            options.poisonDamage || 8,
                            options.poisonTickInterval || 500
                        );
                    }
                }

                for (let i = 0; i < 14; i++) {
                    const angle = (Math.PI * 2 / 14) * i;
                    this.projectiles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 155,
                        vy: Math.sin(angle) * 155,
                        size: 7,
                        damage: 0,
                        color: particleColor,
                        life: 700,
                        isPlayerProjectile: false,
                        isParticle: true
                    });
                }
            },

            taurhaApplyPoisonToPlayer(durationMs, tickDamage, tickInterval) {
                const now = Date.now();
                Player.poisoned = true;
                Player.poisonDamage = Math.max(Player.poisonDamage || 0, tickDamage);
                Player.poisonTickInterval = tickInterval;
                Player.poisonLastTick = Player.poisonLastTick || now;
                Player.poisonEndTime = Math.max(Player.poisonEndTime || 0, now + durationMs);
            },

            renderTaurhaBossModel(ctx, mob, size) {
                const phaseTwo = mob.hp <= (mob.maxHp * 0.5);
                if (phaseTwo) {
                    mob.phaseTwoVisual = true;
                }

                const bodyW = size * 0.78;
                const bodyH = size * 0.98;
                const bodyX = -bodyW / 2;
                const bodyY = -bodyH * 0.56;

                // Phase 2 cloud particles on Taurha's back.
                if (mob.phaseTwoVisual) {
                    const t = Date.now() * 0.003;
                    for (let i = 0; i < 7; i++) {
                        const a = t + (i / 7) * Math.PI * 2;
                        const cx = Math.cos(a) * size * 0.42;
                        const cy = -size * 0.22 + Math.sin(a * 1.6) * size * 0.12;
                        const cr = size * (0.12 + (i % 3) * 0.02);
                        const cloud = ctx.createRadialGradient(cx, cy, 0, cx, cy, cr);
                        cloud.addColorStop(0, 'rgba(210, 230, 255, 0.35)');
                        cloud.addColorStop(1, 'rgba(150, 190, 230, 0)');
                        ctx.fillStyle = cloud;
                        ctx.beginPath();
                        ctx.arc(cx, cy, cr, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Main body: sand-colored stone + dark brick layers.
                const body = ctx.createLinearGradient(0, bodyY, 0, bodyY + bodyH);
                body.addColorStop(0, '#bfa57f');
                body.addColorStop(0.55, '#9b7d5b');
                body.addColorStop(1, '#4d3a2c');
                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.moveTo(bodyX + bodyW * 0.08, bodyY + bodyH * 0.05);
                ctx.lineTo(bodyX + bodyW * 0.92, bodyY + bodyH * 0.05);
                ctx.lineTo(bodyX + bodyW, bodyY + bodyH * 0.62);
                ctx.lineTo(0, bodyY + bodyH);
                ctx.lineTo(bodyX, bodyY + bodyH * 0.62);
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = '#35271d';
                ctx.lineWidth = Math.max(2, size * 0.03);
                for (let i = 0; i < 5; i++) {
                    const y = bodyY + bodyH * (0.18 + i * 0.14);
                    ctx.beginPath();
                    ctx.moveTo(bodyX + bodyW * 0.12, y);
                    ctx.lineTo(bodyX + bodyW * 0.88, y);
                    ctx.stroke();
                }

                // Blue glyphs on body.
                ctx.strokeStyle = '#2be6ff';
                ctx.lineWidth = Math.max(2, size * 0.018);
                ctx.beginPath();
                ctx.moveTo(-size * 0.14, bodyY + bodyH * 0.44);
                ctx.lineTo(-size * 0.05, bodyY + bodyH * 0.37);
                ctx.lineTo(size * 0.04, bodyY + bodyH * 0.46);
                ctx.moveTo(-size * 0.17, bodyY + bodyH * 0.57);
                ctx.lineTo(size * 0.17, bodyY + bodyH * 0.57);
                ctx.moveTo(-size * 0.1, bodyY + bodyH * 0.7);
                ctx.lineTo(size * 0.1, bodyY + bodyH * 0.7);
                ctx.stroke();

                // Crown with glowing glyphs.
                ctx.fillStyle = '#2a1f17';
                ctx.beginPath();
                ctx.moveTo(-size * 0.25, bodyY + bodyH * 0.07);
                ctx.lineTo(-size * 0.17, bodyY - size * 0.14);
                ctx.lineTo(-size * 0.07, bodyY + bodyH * 0.04);
                ctx.lineTo(0, bodyY - size * 0.16);
                ctx.lineTo(size * 0.07, bodyY + bodyH * 0.04);
                ctx.lineTo(size * 0.17, bodyY - size * 0.14);
                ctx.lineTo(size * 0.25, bodyY + bodyH * 0.07);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#35e7ff';
                for (let i = 0; i < 5; i++) {
                    const gx = -size * 0.16 + i * size * 0.08;
                    ctx.fillRect(gx, bodyY - size * 0.02, size * 0.03, size * 0.03);
                }

                // Eyes: white phase 1, green phase 2.
                const eyeColor = mob.phaseTwoVisual ? '#62ff8f' : '#ffffff';
                ctx.shadowBlur = size * 0.14;
                ctx.shadowColor = eyeColor;
                ctx.fillStyle = eyeColor;
                ctx.beginPath();
                ctx.arc(-size * 0.12, bodyY + bodyH * 0.38, size * 0.06, 0, Math.PI * 2);
                ctx.arc(size * 0.12, bodyY + bodyH * 0.38, size * 0.06, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Giant pillar weapon.
                ctx.save();
                ctx.translate(size * 0.31, size * 0.08);
                ctx.rotate(-0.18);
                const pillar = ctx.createLinearGradient(0, -size * 0.42, 0, size * 0.42);
                pillar.addColorStop(0, '#7a5f47');
                pillar.addColorStop(1, '#3e2f23');
                ctx.fillStyle = pillar;
                ctx.fillRect(-size * 0.05, -size * 0.42, size * 0.1, size * 0.84);

                ctx.strokeStyle = '#2be6ff';
                ctx.lineWidth = Math.max(2, size * 0.015);
                ctx.beginPath();
                ctx.moveTo(-size * 0.02, -size * 0.33);
                ctx.lineTo(size * 0.02, -size * 0.28);
                ctx.moveTo(-size * 0.03, 0);
                ctx.lineTo(size * 0.03, size * 0.05);
                ctx.moveTo(-size * 0.02, size * 0.27);
                ctx.lineTo(size * 0.02, size * 0.32);
                ctx.stroke();
                ctx.restore();
            },


            render(ctx) {
                if (!this.active) return;

                const allMobs = [...this.mobs, ...this.bosses];

                allMobs.forEach(mob => {
                    const time = Date.now();
                    const isBoss = mob.isBoss;
                    const pulse = 1 + Math.sin(time / (isBoss ? 300 : 200)) * (isBoss ? 0.1 : 0.05);
                    const size = mob.size * pulse;
                    if (mob.type === 'taurha_giant' && mob.hp <= (mob.maxHp * 0.5)) {
                        mob.phaseTwoVisual = true;
                    }

                    // 1. Aura (Universal)
                    ctx.save();
                    const gradient = ctx.createRadialGradient(mob.x, mob.y, size * 0.2, mob.x, mob.y, size * (isBoss ? 2 : 1.5));
                    gradient.addColorStop(0, mob.color);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');

                    ctx.fillStyle = gradient;
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.arc(mob.x, mob.y, size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    // 2. Procedural Icon Model
                    ctx.save();
                    ctx.translate(mob.x, mob.y);

                    // Simple rotation for some variety
                    if (mob.type && (mob.type.includes('tornado') || mob.type.includes('cyclone'))) {
                        ctx.rotate(time / 200);
                    }

                    // Use custom model for Taurha boss, IconRenderer for others.
                    if (mob.type === 'taurha_giant') {
                        this.renderTaurhaBossModel(ctx, mob, size);
                    } else {
                        const iconId = 'mob_' + mob.type;
                        IconRenderer.renderTo(ctx, iconId, -size / 2, -size / 2, size);
                    }

                    // Add distinctive Boss aura/glow in-game
                    if (isBoss) {
                        ctx.strokeStyle = mob.color;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(0, 0, size * 0.6, 0, Math.PI * 2);
                        ctx.stroke();

                        // Boss Name
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 16px Orbitron';
                        ctx.textAlign = 'center';
                        ctx.fillText(mob.name.toUpperCase(), 0, -size * 0.8);
                    }
                    ctx.restore();


                    // HP Bar
                    const barWidth = size * 1.2;
                    const barHeight = 6;
                    const barX = mob.x - barWidth / 2;
                    const barY = mob.y + size * 0.7;

                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);

                    const hpPercent = Math.max(0, Math.min(1, mob.hp / mob.maxHp));
                    ctx.fillStyle = isBoss ? '#ffd700' : (hpPercent > 0.5 ? '#00ff00' : (hpPercent > 0.25 ? '#ffff00' : '#ff0000'));
                    ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);

                    // Status Effects
                    let statusX = mob.x + size + 10;
                    if (mob.burning) {
                        ctx.font = '16px Arial';
                        ctx.fillText('🔥', statusX, mob.y);
                        statusX += 20;
                    }
                    if (mob.stunned) {
                        ctx.font = '16px Arial';
                        ctx.fillText('💫', statusX, mob.y);
                        statusX += 20;
                    }
                    if (mob.deathMarked) {
                        ctx.save();
                        ctx.translate(statusX, mob.y);
                        ctx.strokeStyle = '#ffd166';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, -7);
                        ctx.lineTo(0, 7);
                        ctx.moveTo(-6, 0);
                        ctx.lineTo(6, 0);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                        statusX += 20;
                    }
                    if (mob.silenced) {
                        ctx.save();
                        ctx.translate(statusX, mob.y);
                        ctx.strokeStyle = '#8bf2ff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(-5, 5);
                        ctx.lineTo(5, -5);
                        ctx.stroke();
                        ctx.restore();
                        statusX += 20;
                    }
                });
                // Render toxic bubbles
                if (this.toxicBubbles && this.toxicBubbles.length > 0) {
                    this.toxicBubbles.forEach(bubble => {
                        if (bubble.exploded) return;

                        ctx.save();
                        // Pulsing effect
                        const pulse = 1 + Math.sin(Date.now() / 300) * 0.1;
                        const size = bubble.size * pulse;

                        // Outer glow
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = bubble.color;

                        // Gradient fill
                        const gradient = ctx.createRadialGradient(bubble.x, bubble.y, 0, bubble.x, bubble.y, size);
                        gradient.addColorStop(0, 'rgba(0, 255, 136, 0.6)');
                        gradient.addColorStop(0.7, 'rgba(0, 255, 136, 0.3)');
                        gradient.addColorStop(1, 'rgba(0, 255, 136, 0.1)');

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(bubble.x, bubble.y, size, 0, Math.PI * 2);
                        ctx.fill();

                        // Inner circle
                        ctx.fillStyle = 'rgba(0, 255, 136, 0.8)';
                        ctx.beginPath();
                        ctx.arc(bubble.x, bubble.y, size * 0.3, 0, Math.PI * 2);
                        ctx.fill();

                        // Toxic symbol
                        ctx.font = `${size * 0.6}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#000';
                        ctx.fillText('?', bubble.x, bubble.y);

                        ctx.restore();
                    });
                }

                // Render nature obstacles (trees/bushes)
                if (this.natureObstacles && this.natureObstacles.length > 0) {
                    this.natureObstacles.forEach(obstacle => {
                        ctx.save();

                        // Draw tree/bush base
                        const gradient = ctx.createRadialGradient(obstacle.x, obstacle.y, 0, obstacle.x, obstacle.y, obstacle.radius);
                        gradient.addColorStop(0, 'rgba(34, 139, 34, 0.8)');
                        gradient.addColorStop(0.7, 'rgba(34, 139, 34, 0.5)');
                        gradient.addColorStop(1, 'rgba(34, 139, 34, 0.2)');

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw tree icon
                        ctx.font = `${obstacle.radius * 1.5}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#228b22';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#00ff00';
                        ctx.fillText('??', obstacle.x, obstacle.y);

                        ctx.restore();
                    });
                }

                // Render smoke balls (from Ninja Power)
                if (this.smokeBalls && this.smokeBalls.length > 0) {
                    this.smokeBalls.forEach(smoke => {
                        ctx.save();

                        // Pulsing effect
                        const pulse = 1 + Math.sin(Date.now() / 200) * 0.15;
                        const size = smoke.radius * pulse;

                        // Smoke gradient
                        const gradient = ctx.createRadialGradient(smoke.x, smoke.y, 0, smoke.x, smoke.y, size);
                        gradient.addColorStop(0, 'rgba(100, 100, 100, 0.8)');
                        gradient.addColorStop(0.5, 'rgba(80, 80, 80, 0.5)');
                        gradient.addColorStop(1, 'rgba(60, 60, 60, 0.1)');

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(smoke.x, smoke.y, size, 0, Math.PI * 2);
                        ctx.fill();

                        // Smoke icon
                        ctx.font = `${size * 0.8}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#888888';
                        ctx.fillText('??', smoke.x, smoke.y);

                        ctx.restore();
                    });
                }

                // Render projectiles
                this.projectiles.forEach(proj => {
                    ctx.save();

                    // Special rendering for Pilum (Roman Legionary)
                    if (proj.isPilum) {
                        // Pilum trail effect
                        if (!proj.trail) proj.trail = [];
                        proj.trail.push({ x: proj.x, y: proj.y, time: Date.now() });
                        // Keep only last 10 trail points
                        if (proj.trail.length > 10) proj.trail.shift();

                        // Render trail
                        proj.trail.forEach((point, index) => {
                            const age = Date.now() - point.time;
                            const alpha = Math.max(0, 1 - (age / 300));
                            const size = proj.size * (0.3 + (index / proj.trail.length) * 0.7);

                            ctx.globalAlpha = alpha * 0.5;
                            ctx.fillStyle = '#ffd700';
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, size * 0.4, 0, Math.PI * 2);
                            ctx.fill();
                        });

                        ctx.globalAlpha = 1;

                        // Pilum body (wooden shaft)
                        const length = 40;
                        const width = 6;
                        ctx.save();
                        ctx.translate(proj.x, proj.y);
                        ctx.rotate(proj.angle);

                        // Shaft shadow
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#000000';

                        // Wooden shaft
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(-length / 2, -width / 2, length * 0.7, width);

                        // Iron tip
                        ctx.fillStyle = '#696969';
                        ctx.beginPath();
                        ctx.moveTo(length * 0.2, 0);
                        ctx.lineTo(length * 0.5, -width);
                        ctx.lineTo(length * 0.5, width);
                        ctx.closePath();
                        ctx.fill();

                        // Tip shine
                        ctx.fillStyle = '#c0c0c0';
                        ctx.beginPath();
                        ctx.moveTo(length * 0.25, 0);
                        ctx.lineTo(length * 0.45, -width * 0.5);
                        ctx.lineTo(length * 0.45, width * 0.5);
                        ctx.closePath();
                        ctx.fill();

                        // Golden glow around pilum
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#ffd700';
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        ctx.moveTo(-length / 2, 0);
                        ctx.lineTo(length * 0.5, 0);
                        ctx.stroke();

                        ctx.restore();
                    }
                    // Special rendering for Doru (Spartan Hoplite)
                    else if (proj.isDoru) {
                        // Doru trail effect
                        if (!proj.trail) proj.trail = [];
                        proj.trail.push({ x: proj.x, y: proj.y, time: Date.now() });
                        if (proj.trail.length > 12) proj.trail.shift();

                        // Render trail
                        proj.trail.forEach((point, index) => {
                            const age = Date.now() - point.time;
                            const alpha = Math.max(0, 1 - (age / 350));
                            const size = proj.size * (0.3 + (index / proj.trail.length) * 0.7);

                            ctx.globalAlpha = alpha * 0.6;
                            ctx.fillStyle = '#8B0000'; // Rojo espartano
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, size * 0.4, 0, Math.PI * 2);
                            ctx.fill();
                        });

                        ctx.globalAlpha = 1;

                        // Doru body (lanza espartana)
                        const length = 45;
                        const width = 7;
                        ctx.save();
                        ctx.translate(proj.x, proj.y);
                        ctx.rotate(proj.angle);

                        // Shaft shadow
                        ctx.shadowBlur = 18;
                        ctx.shadowColor = '#8B0000';

                        // Wooden shaft
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(-length / 2, -width / 2, length * 0.65, width);

                        // Bronze tip
                        ctx.fillStyle = '#CD7F32';
                        ctx.beginPath();
                        ctx.moveTo(length * 0.15, 0);
                        ctx.lineTo(length * 0.5, -width * 1.2);
                        ctx.lineTo(length * 0.5, width * 1.2);
                        ctx.closePath();
                        ctx.fill();

                        // Tip shine
                        ctx.fillStyle = '#DAA520';
                        ctx.beginPath();
                        ctx.moveTo(length * 0.2, 0);
                        ctx.lineTo(length * 0.45, -width * 0.6);
                        ctx.lineTo(length * 0.45, width * 0.6);
                        ctx.closePath();
                        ctx.fill();

                        // Red glow around doru
                        ctx.shadowBlur = 22;
                        ctx.shadowColor = '#8B0000';
                        ctx.strokeStyle = '#8B0000';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.7;
                        ctx.beginPath();
                        ctx.moveTo(-length / 2, 0);
                        ctx.lineTo(length * 0.5, 0);
                        ctx.stroke();

                        ctx.restore();
                    } else {
                        // Normal projectile rendering
                        ctx.fillStyle = proj.color;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = proj.color;
                        ctx.beginPath();
                        ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();
                });

                // Render shadow clones
                if (this.shadowClones && this.shadowClones.length > 0) {
                    this.shadowClones.forEach(clone => {
                        ctx.save();

                        // Pulsing shadow effect
                        const pulse = 1 + Math.sin(Date.now() / 200) * 0.1;
                        const size = 25 * pulse;

                        // Shadow gradient
                        const gradient = ctx.createRadialGradient(clone.x, clone.y, 0, clone.x, clone.y, size);
                        gradient.addColorStop(0, 'rgba(47, 47, 47, 0.9)');
                        gradient.addColorStop(0.5, 'rgba(47, 47, 47, 0.6)');
                        gradient.addColorStop(1, 'rgba(47, 47, 47, 0.2)');

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(clone.x, clone.y, size, 0, Math.PI * 2);
                        ctx.fill();

                        // Clone icon
                        ctx.font = '32px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#2f2f2f';
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#000000';
                        ctx.fillText('??', clone.x, clone.y);

                        ctx.restore();
                    });
                }

                // Render wind singularities (Tornado Overlord)
                if (this.windSingularities && this.windSingularities.length > 0) {
                    this.windSingularities.forEach(singularity => {
                        ctx.save();

                        // Pulsing black hole effect
                        const pulse = 1 + Math.sin(Date.now() / 150) * 0.3;
                        const size = singularity.radius * pulse;

                        // Dark center
                        const gradient = ctx.createRadialGradient(singularity.x, singularity.y, 0, singularity.x, singularity.y, size);
                        gradient.addColorStop(0, 'rgba(0, 0, 0, 0.9)');
                        gradient.addColorStop(0.3, 'rgba(57, 255, 20, 0.6)');
                        gradient.addColorStop(0.7, 'rgba(57, 255, 20, 0.3)');
                        gradient.addColorStop(1, 'rgba(57, 255, 20, 0.1)');

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(singularity.x, singularity.y, size, 0, Math.PI * 2);
                        ctx.fill();

                        // Swirling effect
                        for (let i = 0; i < 8; i++) {
                            const angle = (Date.now() / 100 + i * Math.PI / 4) % (Math.PI * 2);
                            const x = singularity.x + Math.cos(angle) * size * 0.8;
                            const y = singularity.y + Math.sin(angle) * size * 0.8;

                            ctx.font = '16px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillStyle = '#39ff14';
                            ctx.fillText('??', x, y);
                        }

                        ctx.restore();
                    });
                }

                // Render static storms (Tornado Overlord)
                if (this.staticStorms && this.staticStorms.length > 0) {
                    this.staticStorms.forEach(storm => {
                        ctx.save();

                        // Lightning storm effect
                        const pulse = 1 + Math.sin(Date.now() / 200) * 0.2;
                        const size = storm.radius * pulse;

                        // Storm gradient
                        const gradient = ctx.createRadialGradient(storm.x, storm.y, 0, storm.x, storm.y, size);
                        gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                        gradient.addColorStop(0.5, 'rgba(57, 255, 20, 0.5)');
                        gradient.addColorStop(1, 'rgba(57, 255, 20, 0.1)');

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(storm.x, storm.y, size, 0, Math.PI * 2);
                        ctx.fill();

                        // Lightning bolts
                        ctx.font = '24px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillStyle = '#ffff00';
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ffff00';
                        ctx.fillText('?', storm.x, storm.y);

                        ctx.restore();
                    });
                }

                // Render singularity grenades (Cybernetic Warlord)
                if (this.singularityGrenades && this.singularityGrenades.length > 0) {
                    this.singularityGrenades.forEach(grenade => {
                        ctx.save();

                        if (!grenade.detonated) {
                            // Pulsing gravity field
                            const pulse = 1 + Math.sin(Date.now() / 150) * 0.3;
                            const size = grenade.pullRadius * pulse;

                            // Gravity gradient
                            const gradient = ctx.createRadialGradient(grenade.x, grenade.y, 0, grenade.x, grenade.y, size);
                            gradient.addColorStop(0, 'rgba(138, 43, 226, 0.8)');
                            gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.4)');
                            gradient.addColorStop(1, 'rgba(0, 255, 255, 0.1)');

                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(grenade.x, grenade.y, size, 0, Math.PI * 2);
                            ctx.fill();

                            // Grenade icon
                            ctx.font = '32px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillStyle = '#00ffff';
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#00ffff';
                            ctx.fillText('??', grenade.x, grenade.y);
                        } else {
                            // Explosion effect
                            const explosionSize = grenade.radius * 1.5;
                            const gradient = ctx.createRadialGradient(grenade.x, grenade.y, 0, grenade.x, grenade.y, explosionSize);
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                            gradient.addColorStop(0.3, 'rgba(0, 255, 255, 0.8)');
                            gradient.addColorStop(1, 'rgba(138, 43, 226, 0)');

                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(grenade.x, grenade.y, explosionSize, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        ctx.restore();
                    });
                }

                // Render combat drones (Cybernetic Warlord)
                if (this.combatDrones && this.combatDrones.length > 0) {
                    this.combatDrones.forEach(drone => {
                        const droneX = Player.x + Math.cos(drone.angle) * drone.distance;
                        const droneY = Player.y + Math.sin(drone.angle) * drone.distance;

                        ctx.save();

                        // Drone body
                        const gradient = ctx.createRadialGradient(droneX, droneY, 0, droneX, droneY, 15);
                        gradient.addColorStop(0, 'rgba(0, 255, 255, 1)');
                        gradient.addColorStop(1, 'rgba(0, 150, 150, 0.6)');

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(droneX, droneY, 15, 0, Math.PI * 2);
                        ctx.fill();

                        // Drone icon
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#00ffff';
                        ctx.fillText('??', droneX, droneY + 5);

                        ctx.restore();
                    });
                }

                // Render photon barriers (Cybernetic Warlord)
                if (this.photonBarriers && this.photonBarriers.length > 0) {
                    this.photonBarriers.forEach(barrier => {
                        ctx.save();

                        // Pulsing energy barrier
                        const pulse = 1 + Math.sin(Date.now() / 100) * 0.2;
                        const alpha = 0.6 + Math.sin(Date.now() / 150) * 0.2;

                        // Barrier gradient
                        const gradient = ctx.createLinearGradient(
                            barrier.x - barrier.width / 2, barrier.y - barrier.height / 2,
                            barrier.x + barrier.width / 2, barrier.y + barrier.height / 2
                        );
                        gradient.addColorStop(0, `rgba(0, 255, 255, ${alpha})`);
                        gradient.addColorStop(0.5, `rgba(255, 255, 255, ${alpha})`);
                        gradient.addColorStop(1, `rgba(0, 255, 255, ${alpha})`);

                        ctx.fillStyle = gradient;
                        ctx.fillRect(
                            barrier.x - barrier.width / 2,
                            barrier.y - barrier.height / 2,
                            barrier.width * pulse,
                            barrier.height
                        );

                        // Border glow
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#00ffff';
                        ctx.strokeRect(
                            barrier.x - barrier.width / 2,
                            barrier.y - barrier.height / 2,
                            barrier.width * pulse,
                            barrier.height
                        );

                        ctx.restore();
                    });
                }

                // Render orbital strikes (Cybernetic Warlord)
                if (this.orbitalStrikes && this.orbitalStrikes.length > 0) {
                    this.orbitalStrikes.forEach(orbital => {
                        ctx.save();

                        if (!orbital.fired) {
                            // Warning indicator
                            const pulse = 1 + Math.sin(Date.now() / 100) * 0.3;
                            const size = orbital.radius * pulse;

                            // Red warning circle
                            ctx.strokeStyle = '#ff0000';
                            ctx.lineWidth = 4;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#ff0000';
                            ctx.beginPath();
                            ctx.arc(orbital.x, orbital.y, size, 0, Math.PI * 2);
                            ctx.stroke();

                            // Warning text
                            ctx.font = 'bold 24px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillStyle = '#ff0000';
                            ctx.fillText('??', orbital.x, orbital.y);

                            // Countdown
                            const timeLeft = Math.ceil((orbital.warningTime - (Date.now() - orbital.startTime)) / 1000);
                            ctx.font = 'bold 18px Arial';
                            ctx.fillText(timeLeft, orbital.x, orbital.y + 30);
                        } else {
                            // Laser beam effect
                            const gradient = ctx.createRadialGradient(orbital.x, orbital.y, 0, orbital.x, orbital.y, orbital.radius);
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                            gradient.addColorStop(0.3, 'rgba(0, 255, 255, 0.9)');
                            gradient.addColorStop(0.7, 'rgba(0, 150, 255, 0.5)');
                            gradient.addColorStop(1, 'rgba(0, 100, 255, 0)');

                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(orbital.x, orbital.y, orbital.radius, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        ctx.restore();
                    });
                }

                // Render burned grounds (Cybernetic Warlord)
                if (this.burnedGrounds && this.burnedGrounds.length > 0) {
                    this.burnedGrounds.forEach(ground => {
                        ctx.save();

                        // Burned ground effect
                        const alpha = 0.4 + Math.sin(Date.now() / 200) * 0.1;
                        const gradient = ctx.createRadialGradient(ground.x, ground.y, 0, ground.x, ground.y, ground.radius);
                        gradient.addColorStop(0, `rgba(255, 100, 0, ${alpha})`);
                        gradient.addColorStop(0.5, `rgba(200, 50, 0, ${alpha * 0.7})`);
                        gradient.addColorStop(1, `rgba(100, 0, 0, 0)`);

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(ground.x, ground.y, ground.radius, 0, Math.PI * 2);
                        ctx.fill();

                        // Fire particles
                        for (let i = 0; i < 5; i++) {
                            const angle = (Date.now() / 500 + i * Math.PI * 2 / 5) % (Math.PI * 2);
                            const dist = ground.radius * 0.6;
                            const x = ground.x + Math.cos(angle) * dist;
                            const y = ground.y + Math.sin(angle) * dist;

                            ctx.font = '16px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillStyle = '#ff6600';
                            ctx.fillText('??', x, y);
                        }

                        ctx.restore();
                    });
                }

                // Render Gladius Fulminante thrusts (Roman Legionary)
                if (this.gladiusThrusts && this.gladiusThrusts.length > 0) {
                    this.gladiusThrusts = this.gladiusThrusts.filter(thrust => {
                        const age = Date.now() - thrust.createdAt;
                        if (age >= thrust.lifetime) return false;

                        ctx.save();

                        // Línea de estocada con efecto de brillo
                        const alpha = 1 - (age / thrust.lifetime);
                        ctx.globalAlpha = alpha;

                        // Sombra brillante
                        ctx.shadowColor = thrust.color;
                        ctx.shadowBlur = 15;

                        // Línea principal
                        ctx.strokeStyle = thrust.color;
                        ctx.lineWidth = thrust.width;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(thrust.startX, thrust.startY);
                        ctx.lineTo(thrust.endX, thrust.endY);
                        ctx.stroke();

                        // Línea dorada interior
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = thrust.width / 2;
                        ctx.beginPath();
                        ctx.moveTo(thrust.startX, thrust.startY);
                        ctx.lineTo(thrust.endX, thrust.endY);
                        ctx.stroke();

                        ctx.restore();
                        return true;
                    });
                }

                // Render Testudo shockwaves (Roman Legionary)
                if (this.testudoShockwaves && this.testudoShockwaves.length > 0) {
                    this.testudoShockwaves = this.testudoShockwaves.filter(wave => {
                        const age = Date.now() - wave.createdAt;
                        if (age >= wave.lifetime) return false;

                        // Expandir onda
                        wave.radius = Math.min(wave.maxRadius, (age / wave.lifetime) * wave.maxRadius);

                        ctx.save();

                        const alpha = 1 - (age / wave.lifetime);
                        ctx.globalAlpha = alpha;

                        // Onda de choque dorada
                        ctx.strokeStyle = wave.color;
                        ctx.lineWidth = 4;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = wave.color;
                        ctx.beginPath();
                        ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Onda interior dorada (solo si el radio es suficiente)
                        if (wave.radius > 5) {
                            ctx.strokeStyle = '#ffd700';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(wave.x, wave.y, wave.radius - 3, 0, Math.PI * 2);
                            ctx.stroke();
                        }

                        ctx.restore();
                        return true;
                    });
                }

                // Render Imperial Eagles (Roman Legionary)
                if (this.imperialEagles && this.imperialEagles.length > 0) {
                    this.imperialEagles = this.imperialEagles.filter(eagle => {
                        const age = Date.now() - eagle.startTime;
                        if (age >= eagle.duration) return false;

                        ctx.save();

                        // Águila dorada gigante con aura brillante
                        const pulse = 1 + Math.sin(Date.now() / 100) * 0.1;
                        const size = eagle.size * pulse;

                        // Aura dorada radiante
                        const auraGradient = ctx.createRadialGradient(
                            eagle.x, eagle.y, 0,
                            eagle.x, eagle.y, size * 1.5
                        );
                        auraGradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                        auraGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.4)');
                        auraGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');

                        ctx.fillStyle = auraGradient;
                        ctx.beginPath();
                        ctx.arc(eagle.x, eagle.y, size * 1.5, 0, Math.PI * 2);
                        ctx.fill();

                        // Águila
                        ctx.font = `${size}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = '#ffd700';
                        ctx.fillStyle = '#ffd700';
                        ctx.fillText('??', eagle.x, eagle.y);

                        // Rayos de luz dorados
                        const rayCount = 12;
                        for (let i = 0; i < rayCount; i++) {
                            const angle = (Math.PI * 2 / rayCount) * i + (Date.now() / 500);
                            const rayLength = 60 + Math.sin(Date.now() / 200 + i) * 20;

                            ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(eagle.x, eagle.y);
                            ctx.lineTo(
                                eagle.x + Math.cos(angle) * rayLength,
                                eagle.y + Math.sin(angle) * rayLength
                            );
                            ctx.stroke();
                        }

                        ctx.restore();
                        return true;
                    });
                }

                // Render Phalanx shockwaves (Spartan Hoplite)
                if (this.phalanxShockwaves && this.phalanxShockwaves.length > 0) {
                    this.phalanxShockwaves = this.phalanxShockwaves.filter(wave => {
                        const age = Date.now() - wave.createdAt;
                        if (age >= wave.lifetime) return false;

                        wave.radius = Math.min(wave.maxRadius, (age / wave.lifetime) * wave.maxRadius);

                        ctx.save();

                        const alpha = 1 - (age / wave.lifetime);
                        ctx.globalAlpha = alpha;

                        // Onda de choque roja espartana
                        ctx.strokeStyle = wave.color;
                        ctx.lineWidth = 5;
                        ctx.shadowBlur = 22;
                        ctx.shadowColor = wave.color;
                        ctx.beginPath();
                        ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Onda interior de bronce
                        if (wave.radius > 5) {
                            ctx.strokeStyle = '#CD7F32';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(wave.x, wave.y, wave.radius - 3, 0, Math.PI * 2);
                            ctx.stroke();
                        }

                        ctx.restore();
                        return true;
                    });
                }

                // Render Eagle shockwaves (Roman Legionary)
                if (this.eagleShockwaves && this.eagleShockwaves.length > 0) {
                    this.eagleShockwaves = this.eagleShockwaves.filter(wave => {
                        const age = Date.now() - wave.createdAt;
                        if (age >= wave.lifetime) return false;

                        wave.radius = Math.min(wave.maxRadius, (age / wave.lifetime) * wave.maxRadius);

                        ctx.save();

                        const alpha = 1 - (age / wave.lifetime);
                        ctx.globalAlpha = alpha;

                        // Onda dorada brillante
                        ctx.strokeStyle = wave.color;
                        ctx.lineWidth = 8;
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = wave.color;
                        ctx.beginPath();
                        ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Onda interior carmesí (solo si el radio es suficiente)
                        if (wave.radius > 6) {
                            ctx.strokeStyle = '#dc143c';
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.arc(wave.x, wave.y, wave.radius - 4, 0, Math.PI * 2);
                            ctx.stroke();
                        }

                        // Plumas doradas en la onda
                        const featherCount = 12;
                        for (let i = 0; i < featherCount; i++) {
                            const angle = (Math.PI * 2 / featherCount) * i;
                            const featherX = wave.x + Math.cos(angle) * wave.radius;
                            const featherY = wave.y + Math.sin(angle) * wave.radius;

                            ctx.font = 'bold 14px Arial';
                            ctx.fillStyle = '#ffd700';
                            ctx.textAlign = 'center';
                            ctx.shadowBlur = 15;
                            ctx.fillText('??', featherX, featherY);
                        }

                        ctx.restore();
                        return true;
                    });
                }

                // Render AROO sound waves (Spartan Hoplite)
                if (this.arooWaves && this.arooWaves.length > 0) {
                    this.arooWaves = this.arooWaves.filter(wave => {
                        const age = Date.now() - wave.createdAt;
                        if (age >= wave.lifetime) return false;

                        wave.radius = Math.min(wave.maxRadius, (age / wave.lifetime) * wave.maxRadius);

                        ctx.save();

                        const alpha = 1 - (age / wave.lifetime);
                        ctx.globalAlpha = alpha;

                        // Onda de sonido roja espartana masiva
                        const vibration = Math.sin(Date.now() / 40) * 4;
                        const mainRadius = Math.max(1, wave.radius + vibration);

                        ctx.strokeStyle = wave.color;
                        ctx.lineWidth = 8;
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = wave.color;
                        ctx.beginPath();
                        ctx.arc(wave.x, wave.y, mainRadius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Onda secundaria de bronce
                        const secondaryRadius = wave.radius - 6 + vibration;
                        if (secondaryRadius > 1) {
                            ctx.strokeStyle = '#CD7F32';
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.arc(wave.x, wave.y, secondaryRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        }

                        // Símbolos lambda espartanos en la onda
                        const symbolCount = 10;
                        for (let i = 0; i < symbolCount; i++) {
                            const angle = (Math.PI * 2 / symbolCount) * i + (Date.now() / 600);
                            const symbolX = wave.x + Math.cos(angle) * wave.radius;
                            const symbolY = wave.y + Math.sin(angle) * wave.radius;

                            ctx.font = 'bold 18px Arial';
                            ctx.fillStyle = '#CD7F32';
                            ctx.textAlign = 'center';
                            ctx.shadowBlur = 12;
                            ctx.fillText('?', symbolX, symbolY);
                        }

                        ctx.restore();
                        return true;
                    });
                }

                // Render Centurion sound waves (Roman Legionary)
                if (this.centurionWaves && this.centurionWaves.length > 0) {
                    this.centurionWaves = this.centurionWaves.filter(wave => {
                        const age = Date.now() - wave.createdAt;
                        if (age >= wave.lifetime) return false;

                        // Expandir onda de sonido
                        wave.radius = Math.min(wave.maxRadius, (age / wave.lifetime) * wave.maxRadius);

                        ctx.save();

                        const alpha = 1 - (age / wave.lifetime);
                        ctx.globalAlpha = alpha;

                        // Onda de sonido carmesí con efecto de vibración
                        const vibration = Math.sin(Date.now() / 50) * 3;

                        // Onda principal - asegurar que el radio sea positivo
                        const mainRadius = Math.max(1, wave.radius + vibration);
                        ctx.strokeStyle = wave.color;
                        ctx.lineWidth = 6;
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = wave.color;
                        ctx.beginPath();
                        ctx.arc(wave.x, wave.y, mainRadius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Onda secundaria (solo si el radio es suficiente para evitar negativos)
                        const secondaryRadius = wave.radius - 5 + vibration;
                        if (secondaryRadius > 1) {
                            ctx.strokeStyle = '#ffd700';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(wave.x, wave.y, secondaryRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        }

                        // Símbolos romanos en la onda
                        const symbolCount = 8;
                        for (let i = 0; i < symbolCount; i++) {
                            const angle = (Math.PI * 2 / symbolCount) * i + (Date.now() / 500);
                            const symbolX = wave.x + Math.cos(angle) * wave.radius;
                            const symbolY = wave.y + Math.sin(angle) * wave.radius;

                            ctx.font = 'bold 16px Arial';
                            ctx.fillStyle = '#ffd700';
                            ctx.textAlign = 'center';
                            ctx.shadowBlur = 10;
                            ctx.fillText('??', symbolX, symbolY);
                        }

                        ctx.restore();
                        return true;
                    });
                }

                // Render Aether Dragon special effects
                this.bosses.forEach(boss => {
                    if (boss.type === 'aether_dragon' || boss.name === 'Dragón del Éter') {
                        ctx.save();

                        // Render Destruction Shield
                        if (boss.destructionShield && boss.destructionShield.active) {
                            const shield = boss.destructionShield;
                            shield.pulsePhase += 0.05;
                            const pulse = 1 + Math.sin(shield.pulsePhase) * 0.2;
                            const shieldRadius = shield.radius * pulse;

                            // Shield gradient
                            const gradient = ctx.createRadialGradient(boss.x, boss.y, 0, boss.x, boss.y, shieldRadius);
                            gradient.addColorStop(0, 'rgba(147, 112, 219, 0.6)');
                            gradient.addColorStop(0.7, 'rgba(147, 112, 219, 0.4)');
                            gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');

                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(boss.x, boss.y, shieldRadius, 0, Math.PI * 2);
                            ctx.fill();

                            // Shield border
                            ctx.strokeStyle = '#9370DB';
                            ctx.lineWidth = 4;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#9370DB';
                            ctx.beginPath();
                            ctx.arc(boss.x, boss.y, shieldRadius, 0, Math.PI * 2);
                            ctx.stroke();

                            // Shield text
                            ctx.font = 'bold 16px Orbitron';
                            ctx.fillStyle = '#9370DB';
                            ctx.textAlign = 'center';
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#9370DB';
                            ctx.fillText('INVENCIBLE', boss.x, boss.y - 30);
                            ctx.fillText('¡Elimina los sirvientes!', boss.x, boss.y + 30);
                        }

                        // Render Death Ray charging effect
                        if (boss.deathRayCharging) {
                            const chargeProgress = 1 - ((boss.deathRayTarget ? 2000 : 0) / 2000);
                            const chargeRadius = 60 + (chargeProgress * 40);

                            // Charging aura
                            const gradient = ctx.createRadialGradient(boss.x, boss.y, 0, boss.x, boss.y, chargeRadius);
                            gradient.addColorStop(0, 'rgba(147, 112, 219, 0.8)');
                            gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');

                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(boss.x, boss.y, chargeRadius, 0, Math.PI * 2);
                            ctx.fill();

                            // Warning text
                            ctx.font = 'bold 14px Arial';
                            ctx.fillStyle = '#9370DB';
                            ctx.textAlign = 'center';
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#9370DB';
                            ctx.fillText('¡CARGANDO RAYO!', boss.x, boss.y - boss.size - 30);
                        }

                        // Render Ether Explosion charging
                        if (boss.etherExplosionCharging) {
                            const pulse = 1 + Math.sin(Date.now() / 100) * 0.3;
                            const explosionRadius = 80 * pulse;

                            const gradient = ctx.createRadialGradient(boss.x, boss.y, 0, boss.x, boss.y, explosionRadius);
                            gradient.addColorStop(0, 'rgba(147, 112, 219, 0.7)');
                            gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');

                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(boss.x, boss.y, explosionRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Render Cursed Barrier trail
                        if (boss.cursedBarrierActive) {
                            const radius = 100;
                            for (let i = 0; i < 8; i++) {
                                const angle = boss.cursedBarrierAngle + (Math.PI * 2 / 8) * i;
                                const trailX = boss.x + Math.cos(angle) * radius;
                                const trailY = boss.y + Math.sin(angle) * radius;

                                // Trail glow
                                const gradient = ctx.createRadialGradient(trailX, trailY, 0, trailX, trailY, 25);
                                gradient.addColorStop(0, 'rgba(147, 112, 219, 0.9)');
                                gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');

                                ctx.fillStyle = gradient;
                                ctx.beginPath();
                                ctx.arc(trailX, trailY, 25, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }

                        ctx.restore();
                    }
                });

                // Render Curse aura on player (visual effect only, status shown in top bar)
                if (Player.cursed && Date.now() < Player.curseEndTime) {
                    ctx.save();

                    // Purple aura around player
                    const cursePhase = Date.now() / 200;
                    const cursePulse = 1 + Math.sin(cursePhase) * 0.3;
                    const curseRadius = 50 * cursePulse;

                    const gradient = ctx.createRadialGradient(Player.x, Player.y, 0, Player.x, Player.y, curseRadius);
                    gradient.addColorStop(0, 'rgba(147, 112, 219, 0.5)');
                    gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(Player.x, Player.y, curseRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }

                // Render boss health bars at top of screen
                this.renderBossHealthBars(ctx);

                // Render Las Termópilas (Spartan Hoplite Ultimate)
                if (Player.thermopylaeActive) {
                    const canvas = ctx.canvas;

                    // Oscurecer el campo de batalla
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.65)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Renderizar hoplitas espartanos
                    if (Player.thermopylaeHoplites) {
                        ctx.save();
                        ctx.font = '22px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = 10;

                        Player.thermopylaeHoplites.forEach(hoplite => {
                            // Mover hoplitas hacia adelante
                            hoplite.y -= hoplite.speed;

                            // Solo renderizar si está visible
                            if (hoplite.y < -50 || hoplite.y > canvas.height + 50) return;

                            // Efecto fantasmal pulsante
                            const pulse = 0.65 + Math.sin(Date.now() / 180 + hoplite.x) * 0.2;
                            ctx.globalAlpha = pulse;

                            // Escudo hoplon rojo
                            ctx.shadowColor = '#8B0000';
                            ctx.fillStyle = '#8B0000';
                            ctx.fillText('???', hoplite.x, hoplite.y);

                            // Lanza de bronce
                            ctx.shadowColor = '#CD7F32';
                            ctx.fillStyle = '#CD7F32';
                            ctx.fillText('???', hoplite.x + 10, hoplite.y);
                        });

                        ctx.restore();
                    }

                    // Texto Épico (solo primeros 2 segundos)
                    const elapsed = Date.now() - Player.thermopylaeStartTime;

                    if (elapsed < 2000) {
                        const textAlpha = Math.min(1, elapsed / 500);

                        ctx.save();
                        ctx.globalAlpha = textAlpha;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        // Título
                        ctx.font = 'bold 68px Orbitron';
                        ctx.fillStyle = '#8B0000';
                        ctx.shadowBlur = 35;
                        ctx.shadowColor = '#8B0000';
                        ctx.fillText('LAS TERMÓPILAS', canvas.width / 2, canvas.height / 2 - 100);

                        // Subtítulo
                        ctx.font = 'bold 34px Orbitron';
                        ctx.fillStyle = '#CD7F32';
                        ctx.shadowColor = '#CD7F32';
                        ctx.fillText('?? LOS 300 DE ESPARTA ??', canvas.width / 2, canvas.height / 2 - 40);

                        // Frase legendaria
                        ctx.font = 'bold 22px Arial';
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowBlur = 18;
                        ctx.shadowColor = '#ffffff';
                        ctx.fillText('Esta noche cenamos en el Hades', canvas.width / 2, canvas.height / 2 + 20);

                        ctx.restore();
                    }
                }

                // Render Legio Aeterna (Roman Legionary Ultimate)
                if (Player.legioAeternaActive) {
                    const canvas = ctx.canvas;

                    // Oscurecer el campo de batalla
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Renderizar legionarios fantasmales (OPTIMIZADO - Con efectos visuales Épicos)
                    if (Player.legioAeternaLegionaries) {
                        ctx.save();
                        ctx.font = '24px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = 8; // Sombra moderada para rendimiento

                        Player.legioAeternaLegionaries.forEach(leg => {
                            // Mover legionarios hacia adelante
                            leg.y -= leg.speed;

                            // Solo renderizar si está visible en pantalla
                            if (leg.y < -50 || leg.y > canvas.height + 50) return;

                            // Alpha con variación para efecto fantasmal
                            const pulse = 0.6 + Math.sin(Date.now() / 200 + leg.x) * 0.15;
                            ctx.globalAlpha = pulse;

                            // Escudo dorado con sombra
                            ctx.shadowColor = '#ffd700';
                            ctx.fillStyle = '#ffd700';
                            ctx.fillText('???', leg.x, leg.y);

                            // Espada carmesí con sombra
                            ctx.shadowColor = '#dc143c';
                            ctx.fillStyle = '#dc143c';
                            ctx.fillText('??', leg.x + 8, leg.y);
                        });

                        ctx.restore();
                    }

                    // Texto Épico en el centro (OPTIMIZADO: solo mostrar durante los primeros 2 segundos)
                    const elapsed = Date.now() - Player.legioAeternaStartTime;

                    if (elapsed < 2000) {
                        const textAlpha = Math.min(1, elapsed / 500);

                        ctx.save();
                        ctx.globalAlpha = textAlpha;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        // Título principal
                        ctx.font = 'bold 72px Orbitron';
                        ctx.fillStyle = '#ffd700';
                        ctx.shadowBlur = 30; // Reducido de 40 a 30
                        ctx.shadowColor = '#ffd700';
                        ctx.fillText('LEGIO AETERNA', canvas.width / 2, canvas.height / 2 - 100);

                        // Subtítulo
                        ctx.font = 'bold 36px Orbitron';
                        ctx.fillStyle = '#dc143c';
                        ctx.shadowColor = '#dc143c';
                        ctx.fillText('?? LA LEGIÓN ETERNA ??', canvas.width / 2, canvas.height / 2 - 40);

                        // Lema romano
                        ctx.font = 'bold 24px Arial';
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowBlur = 15; // Reducido de 20 a 15
                        ctx.shadowColor = '#ffffff';
                        ctx.fillText('Gloria Imperii Romani', canvas.width / 2, canvas.height / 2 + 20);

                        ctx.restore();
                    }
                }

                // Render pause overlay
                if (this.paused) {
                    const canvas = ctx.canvas;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.font = 'bold 72px Orbitron';
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = '#00d9ff';
                    ctx.shadowBlur = 30;
                    ctx.fillText('?? PAUSED', canvas.width / 2, canvas.height / 2 - 40);

                    ctx.font = 'bold 24px Orbitron';
                    ctx.fillStyle = '#ffbe0b';
                    ctx.shadowBlur = 15;
                    ctx.fillText('Press Z to Resume', canvas.width / 2, canvas.height / 2 + 40);
                    ctx.shadowBlur = 0;
                }

                // Render ability cooldowns in fullscreen
                this.renderAbilityCooldowns(ctx);

                // Render floating texts (critical hits, etc.)
                this.renderFloatingTexts(ctx);

                // Render canvas notifications (ticket drops, unlock notifications)
                this.renderCanvasNotifications(ctx);

                // Render unlock indicators
                this.renderUnlockIndicators(ctx);

                // Render mission tracker
                this.renderMissionTracker(ctx);

                // NEW v19.11.2025: Render attack indicators (telegraphing)
                this.renderAttackIndicators(ctx);
            },

            renderCanvasNotifications(ctx) {
                if (!this.canvasNotifications) return;

                const now = Date.now();
                this.canvasNotifications = this.canvasNotifications.filter(notif => {
                    const elapsed = now - notif.startTime;
                    if (elapsed >= notif.duration) return false;

                    const progress = elapsed / notif.duration;
                    const alpha = 1 - progress;
                    const yOffset = progress * 100; // Float up

                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.font = notif.isUnlockNotification ? 'bold 32px Orbitron' : 'bold 24px Arial';
                    ctx.fillStyle = notif.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = notif.color;
                    ctx.shadowBlur = 20;

                    const displayY = notif.y - yOffset;
                    ctx.fillText(notif.text, notif.x, displayY);

                    ctx.restore();
                    return true;
                });
            },

            renderUnlockIndicators(ctx) {
                const unlockable = this.getUnlockableRoles();
                if (unlockable.length === 0) return;

                const drawRoundRect = (x, y, w, h, r) => {
                    ctx.beginPath();
                    ctx.moveTo(x + r, y);
                    ctx.lineTo(x + w - r, y);
                    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                    ctx.lineTo(x + w, y + h - r);
                    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                    ctx.lineTo(x + r, y + h);
                    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                    ctx.lineTo(x, y + r);
                    ctx.quadraticCurveTo(x, y, x + r, y);
                    ctx.closePath();
                };

                const canvas = ctx.canvas;
                const visibleEntries = unlockable.slice(0, 3);
                const rowHeight = 68;
                const panelWidth = 390;
                const panelHeight = 88 + (visibleEntries.length * rowHeight);
                const panelX = canvas.width - panelWidth - 24;
                const panelY = 22;
                const pulse = 0.45 + (Math.sin(Date.now() / 280) * 0.2);

                const panelGrad = ctx.createLinearGradient(panelX, panelY, panelX, panelY + panelHeight);
                panelGrad.addColorStop(0, 'rgba(8, 14, 30, 0.92)');
                panelGrad.addColorStop(1, 'rgba(4, 8, 20, 0.9)');
                drawRoundRect(panelX, panelY, panelWidth, panelHeight, 16);
                ctx.fillStyle = panelGrad;
                ctx.fill();

                ctx.strokeStyle = `rgba(56, 189, 248, ${0.55 + pulse * 0.35})`;
                ctx.lineWidth = 2;
                ctx.shadowColor = 'rgba(56, 189, 248, 0.45)';
                ctx.shadowBlur = 16;
                drawRoundRect(panelX, panelY, panelWidth, panelHeight, 16);
                ctx.stroke();
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#dbeafe';
                ctx.font = '700 18px Orbitron';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText('READY TO UNLOCK', panelX + 18, panelY + 24);

                ctx.font = '500 12px Rajdhani';
                ctx.fillStyle = 'rgba(186, 230, 253, 0.78)';
                ctx.fillText('Open Loadout and claim your reward', panelX + 18, panelY + 45);

                visibleEntries.forEach((entry, index) => {
                    const rowY = panelY + 62 + (index * rowHeight);
                    const rowX = panelX + 12;
                    const rowW = panelWidth - 24;
                    const rowH = 58;
                    const accent = entry.tierColor || '#38bdf8';

                    drawRoundRect(rowX, rowY, rowW, rowH, 12);
                    ctx.fillStyle = 'rgba(15, 23, 42, 0.82)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(148, 163, 184, 0.24)';
                    ctx.lineWidth = 1.2;
                    drawRoundRect(rowX, rowY, rowW, rowH, 12);
                    ctx.stroke();

                    drawRoundRect(rowX + 8, rowY + 8, 42, 42, 10);
                    ctx.fillStyle = 'rgba(2, 6, 23, 0.92)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(148, 163, 184, 0.32)';
                    drawRoundRect(rowX + 8, rowY + 8, 42, 42, 10);
                    ctx.stroke();
                    IconRenderer.renderTo(ctx, entry.id, rowX + 10, rowY + 10, 38);

                    ctx.fillStyle = '#f8fafc';
                    ctx.font = '700 14px Rajdhani';
                    ctx.fillText(entry.name, rowX + 58, rowY + 22);

                    const meta = `${entry.typeLabel} | ${entry.tier || 'BASE'}`;
                    ctx.fillStyle = 'rgba(203, 213, 225, 0.82)';
                    ctx.font = '500 11px Rajdhani';
                    ctx.fillText(meta, rowX + 58, rowY + 40);

                    const progress = entry.progressText || 'Unlock ready';
                    ctx.fillStyle = accent;
                    ctx.font = '700 11px Rajdhani';
                    ctx.textAlign = 'right';
                    ctx.fillText(progress, rowX + rowW - 10, rowY + 40);
                    ctx.textAlign = 'left';
                });
            },

            getUnlockableRoles() {
                const unlockable = [];
                (rolesData.classes || []).forEach(cls => {
                    if (!cls || !cls.id || !cls.ticketsRequired) return;
                    const currentTickets = EquipmentManager.classTickets[cls.id] || 0;
                    if (!EquipmentManager.isClassUnlocked(cls.id) && currentTickets >= cls.ticketsRequired) {
                        unlockable.push({
                            id: cls.id,
                            name: cls.name,
                            tier: cls.tier || 'BASIC',
                            tierColor: cls.tierColor || '#38bdf8',
                            typeLabel: 'Class',
                            progressText: `${currentTickets}/${cls.ticketsRequired} tickets`
                        });
                    }
                });
                return unlockable;
            },

            showUnlockReadyBatch(entries = []) {
                if (!entries.length) return;
                if (!this.unlockReadySeen) this.unlockReadySeen = new Set();
                if (!this.unlockReadyQueue) this.unlockReadyQueue = [];

                entries.forEach((entry) => {
                    const key = `${entry.typeLabel}:${entry.id}`;
                    if (this.unlockReadySeen.has(key)) return;
                    this.unlockReadySeen.add(key);
                    this.unlockReadyQueue.push(entry);
                });

                this.processUnlockReadyQueue();
            },

            processUnlockReadyQueue() {
                if (!this.unlockReadyQueue || this.unlockReadyQueue.length === 0) return;
                if (this.unlockReadyActive) return;
                const next = this.unlockReadyQueue.shift();
                if (!next) return;
                this.unlockReadyActive = next;
                this.showUnlockReadyToast(next);
            },

            showUnlockReadyToast(entry) {
                const old = document.getElementById('unlock-ready-toast');
                if (old) old.remove();

                const toast = document.createElement('div');
                toast.id = 'unlock-ready-toast';
                toast.style.cssText = `
                    position: fixed;
                    right: 24px;
                    top: 24px;
                    width: 360px;
                    max-width: calc(100vw - 40px);
                    z-index: 99999;
                    background: linear-gradient(160deg, rgba(8,14,30,0.96), rgba(4,8,20,0.94));
                    border: 1px solid rgba(56, 189, 248, 0.55);
                    box-shadow: 0 18px 48px rgba(2,6,23,0.8), 0 0 20px rgba(56, 189, 248, 0.28);
                    border-radius: 16px;
                    overflow: hidden;
                    animation: slideInUnlockToast 280ms ease-out;
                    pointer-events: auto;
                `;

                const iconHTML = IconRenderer.getIconHTML(entry.id, 50);
                toast.innerHTML = `
                    <div style="padding: 14px 14px 12px 14px; border-bottom: 1px solid rgba(148,163,184,0.2);">
                        <div style="font: 700 15px Orbitron, sans-serif; color: #dbeafe; letter-spacing: 0.4px;">Unlock Available</div>
                        <div style="font: 500 12px Rajdhani, sans-serif; color: rgba(186,230,253,0.8); margin-top: 2px;">Ready to claim in Loadout</div>
                    </div>
                    <div style="display:flex; align-items:center; gap:12px; padding: 12px 14px;">
                        <div style="width: 56px; height: 56px; border-radius: 12px; background: rgba(2,6,23,0.9); border:1px solid rgba(148,163,184,0.28); display:flex; align-items:center; justify-content:center;">
                            ${iconHTML}
                        </div>
                        <div style="flex:1; min-width:0;">
                            <div style="font: 700 18px Rajdhani, sans-serif; color: #f8fafc; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${entry.name}</div>
                            <div style="font: 600 12px Rajdhani, sans-serif; color: ${entry.tierColor || '#38bdf8'}; margin-top: 2px;">${entry.typeLabel} | ${entry.tier || 'BASE'}</div>
                            <div style="font: 500 11px Rajdhani, sans-serif; color: rgba(203,213,225,0.9); margin-top: 3px;">${entry.progressText || 'Unlock ready'}</div>
                        </div>
                    </div>
                    <div style="display:flex; gap:10px; padding: 0 14px 14px 14px;">
                        <button id="unlock-toast-open" style="flex:1; height: 36px; border-radius: 10px; border: 1px solid rgba(56,189,248,0.7); background: rgba(56,189,248,0.14); color:#e0f2fe; font: 700 12px Rajdhani, sans-serif; cursor:pointer;">Open Loadout</button>
                        <button id="unlock-toast-close" style="width: 92px; height: 36px; border-radius: 10px; border:1px solid rgba(148,163,184,0.45); background: rgba(15,23,42,0.78); color:#cbd5e1; font: 700 12px Rajdhani, sans-serif; cursor:pointer;">Dismiss</button>
                    </div>
                `;

                const styleId = 'unlock-ready-toast-style';
                if (!document.getElementById(styleId)) {
                    const style = document.createElement('style');
                    style.id = styleId;
                    style.textContent = `
                        @keyframes slideInUnlockToast {
                            from { transform: translateX(20px); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }

                document.body.appendChild(toast);
                const closeToast = () => {
                    if (!toast.parentNode) return;
                    toast.remove();
                    this.unlockReadyActive = null;
                    this.processUnlockReadyQueue();
                };

                toast.querySelector('#unlock-toast-open')?.addEventListener('click', () => {
                    closeToast();
                    if (typeof LoadoutManager !== 'undefined') {
                        LoadoutManager.openLoadoutModal();
                        LoadoutManager.showTab('classes');
                    }
                });
                toast.querySelector('#unlock-toast-close')?.addEventListener('click', closeToast);
                setTimeout(closeToast, 6500);
            },

            renderAbilityCooldowns(ctx) {
                const abilities = EquipmentManager.getAllAbilities();
                if (abilities.length === 0) return;

                const canvas = ctx.canvas;
                const abilitySize = 60;
                const abilitySpacing = 15;
                const startX = canvas.width / 2 - ((abilities.length * (abilitySize + abilitySpacing)) / 2);
                const startY = canvas.height - abilitySize - 30;

                abilities.forEach((ability, index) => {
                    const x = startX + (index * (abilitySize + abilitySpacing));
                    const y = startY;

                    // Background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(x, y, abilitySize, abilitySize);

                    // Border
                    const isReady = ability.currentCooldown === 0;
                    ctx.strokeStyle = isReady ? '#00ff00' : '#666666';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, abilitySize, abilitySize);

                    // Icon - Use procedural 2D model
                    const abilityIconId = ability.id || ability.effectId || IconRenderer.getIconFor(ability) || 'default';
                    ctx.save();
                    if (!isReady) {
                        ctx.globalAlpha = 0.4;
                    }
                    IconRenderer.renderTo(ctx, abilityIconId, x + abilitySize * 0.1, y + abilitySize * 0.1, abilitySize * 0.8);
                    ctx.restore();

                    // Cooldown overlay
                    if (ability.currentCooldown > 0) {
                        const cooldownPercent = ability.currentCooldown / ability.cooldown;
                        const overlayHeight = abilitySize * cooldownPercent;

                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(x, y, abilitySize, overlayHeight);

                        // Cooldown text
                        ctx.font = 'bold 20px Arial';
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowColor = '#000000';
                        ctx.shadowBlur = 5;
                        const seconds = Math.ceil(ability.currentCooldown / 1000);
                        ctx.fillText(seconds, x + abilitySize / 2, y + abilitySize / 2);
                        ctx.shadowBlur = 0;
                    }

                    // Key binding
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = '#ffbe0b';
                    ctx.fillText(ability.keyBinding.toUpperCase(), x + abilitySize / 2, y + abilitySize + 15);
                });

                // Render class progress bar
                this.renderClassProgress(ctx);
            },

            renderClassProgress(ctx) {
                if (!EquipmentManager.equippedRole) return;
                const role = EquipmentManager.equippedRole;
                if (role.type !== 'class' && role.type !== 'master_class') return;

                const classData = ClassProgressionSystem.getClassLevel(role.id);
                const canvas = ctx.canvas;

                // Position above abilities
                const barWidth = 300;
                const barHeight = 30;
                const x = canvas.width / 2 - barWidth / 2;
                const y = canvas.height - 130;

                ctx.save();

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.strokeStyle = '#ffbe0b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(x, y, barWidth, barHeight, 5);
                ctx.fill();
                ctx.stroke();

                // Progress bar
                const progress = classData.exp / classData.expToNext;
                const progressWidth = (barWidth - 4) * progress;

                const gradient = ctx.createLinearGradient(x + 2, y + 2, x + 2 + progressWidth, y + 2);
                gradient.addColorStop(0, '#ffbe0b');
                gradient.addColorStop(1, '#ff006e');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.roundRect(x + 2, y + 2, progressWidth, barHeight - 4, 3);
                ctx.fill();

                // Text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 3;

                const levelText = `Nivel ${classData.level}`;
                const expText = `${classData.exp} / ${classData.expToNext} EXP`;
                ctx.fillText(`${levelText} | ${expText}`, x + barWidth / 2, y + barHeight / 2);

                ctx.restore();
            },

            renderFloatingTexts(ctx) {
                if (!this.floatingTexts) return;

                const now = Date.now();
                ctx.save();

                this.floatingTexts = this.floatingTexts.filter(text => {
                    const age = now - text.startTime;
                    if (age > text.life) return false;

                    const progress = age / text.life;
                    const y = text.y - (progress * 50); // Float upwards
                    const alpha = 1 - progress;

                    ctx.globalAlpha = alpha;
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = text.color;
                    ctx.shadowColor = '#000';
                    ctx.shadowBlur = 5;
                    ctx.fillText(text.text, text.x, y);

                    return true;
                });

                ctx.restore();
            },

            renderBossHealthBars(ctx) {
                if (this.bosses.length === 0) return;

                const canvas = ctx.canvas;
                const barHeight = 40;
                const barPadding = 10;
                let yOffset = 20;

                this.bosses.forEach((boss, index) => {
                    const barWidth = canvas.width * 0.6;
                    const barX = (canvas.width - barWidth) / 2;
                    const barY = yOffset + (index * (barHeight + barPadding));

                    // Background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(barX - 10, barY - 10, barWidth + 20, barHeight + 20);

                    // Boss icon and name
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(boss.icon, barX - 40, barY + barHeight / 2);

                    ctx.font = 'bold 16px Orbitron';
                    ctx.fillStyle = '#ffd700';
                    ctx.fillText(`${boss.name} (Lv.${boss.level || 1})`, barX, barY - 5);

                    // HP bar background
                    ctx.fillStyle = 'rgba(50, 50, 50, 0.9)';
                    ctx.fillRect(barX, barY + 15, barWidth, 20);

                    // HP bar fill with validation
                    const hpPercent = Math.max(0, Math.min(1, boss.hp / boss.maxHp));
                    const fillWidth = Math.max(0, barWidth * hpPercent);

                    // Only draw if fillWidth is valid and greater than 0
                    if (fillWidth > 0 && isFinite(fillWidth)) {
                        const gradient = ctx.createLinearGradient(barX, 0, barX + fillWidth, 0);
                        if (hpPercent > 0.5) {
                            gradient.addColorStop(0, '#00ff00');
                            gradient.addColorStop(1, '#00cc00');
                        } else if (hpPercent > 0.25) {
                            gradient.addColorStop(0, '#ffff00');
                            gradient.addColorStop(1, '#ffaa00');
                        } else {
                            gradient.addColorStop(0, '#ff0000');
                            gradient.addColorStop(1, '#cc0000');
                        }

                        ctx.fillStyle = gradient;
                        ctx.fillRect(barX, barY + 15, fillWidth, 20);
                    }

                    // HP text
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${Math.ceil(boss.hp)} / ${boss.maxHp}`, barX + barWidth / 2, barY + 25);

                    // Border
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(barX, barY + 15, barWidth, 20);
                });
            },

            renderMissionTracker(ctx) {
                // Only show if LoadoutManager says it should be visible
                if (!LoadoutManager.missionTrackerVisible) return;

                // Check if player has a class equipped with a mastery mission
                if (!EquipmentManager.equippedRole || EquipmentManager.equippedRole.type !== 'class') return;

                const classId = EquipmentManager.equippedRole.id;
                const masterClass = rolesData.masterClasses.find(mc => mc.baseClassId === classId);
                if (!masterClass) return;

                const progress = LoadoutManager.getMissionProgress(classId);
                if (!progress) return;

                const canvas = ctx.canvas;
                const boxWidth = 350;
                const boxX = canvas.width - boxWidth - 20;
                const boxY = canvas.height - 280;

                // Background
                ctx.fillStyle = 'rgba(10, 14, 39, 0.95)';
                ctx.fillRect(boxX, boxY, boxWidth, 260);

                // Border
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 2;
                ctx.strokeRect(boxX, boxY, boxWidth, 260);

                // Header
                ctx.fillStyle = '#ff00ff';
                ctx.font = 'bold 16px Orbitron';
                ctx.textAlign = 'left';
                ctx.fillText('? MISIÓN ACTIVA', boxX + 15, boxY + 25);

                ctx.font = '10px Arial';
                ctx.fillStyle = 'rgba(224, 231, 255, 0.6)';
                ctx.textAlign = 'right';
                ctx.fillText('Presiona M para ocultar', boxX + boxWidth - 15, boxY + 25);

                // Mission name
                ctx.font = 'bold 14px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'left';
                ctx.fillText(masterClass.name, boxX + 15, boxY + 50);

                // Overall progress
                const totalReqs = progress.requirements.length;
                const completedReqs = progress.requirements.filter(r => r.current >= (r.amount || r.waves)).length;
                const overallProgress = (completedReqs / totalReqs);

                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = '#ffd700';
                ctx.textAlign = 'right';
                ctx.fillText(`${completedReqs}/${totalReqs}`, boxX + boxWidth - 15, boxY + 50);

                // Overall progress bar
                const barY = boxY + 60;
                const barWidth = boxWidth - 30;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.fillRect(boxX + 15, barY, barWidth, 8);

                const gradient = ctx.createLinearGradient(boxX + 15, 0, boxX + 15 + barWidth, 0);
                gradient.addColorStop(0, '#ff00ff');
                gradient.addColorStop(1, '#8a2be2');
                ctx.fillStyle = gradient;
                ctx.fillRect(boxX + 15, barY, barWidth * overallProgress, 8);

                // Requirements
                let reqY = boxY + 85;
                progress.requirements.forEach(req => {
                    const maxValue = req.amount || req.waves;
                    const reqProgress = Math.min(req.current / maxValue, 1);
                    const isComplete = req.current >= maxValue;

                    // Requirement background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(boxX + 15, reqY, boxWidth - 30, 38);

                    // Left border indicator
                    ctx.fillStyle = isComplete ? '#00ff00' : '#ff00ff';
                    ctx.fillRect(boxX + 15, reqY, 3, 38);

                    // Description
                    ctx.font = '11px Arial';
                    ctx.fillStyle = 'rgba(224, 231, 255, 0.9)';
                    ctx.textAlign = 'left';
                    const maxTextWidth = boxWidth - 100;
                    let text = req.description;
                    if (ctx.measureText(text).width > maxTextWidth) {
                        while (ctx.measureText(text + '...').width > maxTextWidth && text.length > 0) {
                            text = text.slice(0, -1);
                        }
                        text += '...';
                    }
                    ctx.fillText(text, boxX + 25, reqY + 12);

                    // Progress text
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = isComplete ? '#00ff00' : '#ffd700';
                    ctx.textAlign = 'right';
                    ctx.fillText(isComplete ? '?' : `${req.current}/${maxValue}`, boxX + boxWidth - 25, reqY + 12);

                    // Progress bar
                    const reqBarY = reqY + 22;
                    const reqBarWidth = boxWidth - 50;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.fillRect(boxX + 25, reqBarY, reqBarWidth, 5);

                    if (isComplete) {
                        const completeGradient = ctx.createLinearGradient(boxX + 25, 0, boxX + 25 + reqBarWidth, 0);
                        completeGradient.addColorStop(0, '#00ff00');
                        completeGradient.addColorStop(1, '#00aa00');
                        ctx.fillStyle = completeGradient;
                    } else {
                        const progressGradient = ctx.createLinearGradient(boxX + 25, 0, boxX + 25 + reqBarWidth, 0);
                        progressGradient.addColorStop(0, '#ffd700');
                        progressGradient.addColorStop(1, '#ff8c00');
                        ctx.fillStyle = progressGradient;
                    }
                    ctx.fillRect(boxX + 25, reqBarY, reqBarWidth * reqProgress, 5);

                    reqY += 43;
                });

                // Completion message
                if (progress.completed) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                    ctx.fillRect(boxX + 15, reqY, boxWidth - 30, 30);
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(boxX + 15, reqY, boxWidth - 30, 30);

                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = '#00ff00';
                    ctx.textAlign = 'center';
                    ctx.fillText('?? ¡MISIÓN COMPLETADA!', boxX + boxWidth / 2, reqY + 20);
                }
            },

            // NEW v19.11.2025: Attack Indicator System (Telegraphing)
            addAttackIndicator(x, y, width, height, duration, color = '#ff0000', shape = 'rect', angle = 0) {
                this.attackIndicators.push({
                    x, y, width, height,
                    duration,
                    maxDuration: duration,
                    color,
                    shape, // 'rect', 'circle', 'line'
                    angle, // Rotation angle in radians
                    startTime: Date.now()
                });
            },

            updateAttackIndicators(deltaTime) {
                this.attackIndicators = this.attackIndicators.filter(indicator => {
                    indicator.duration -= deltaTime;
                    return indicator.duration > 0;
                });
            },

            renderAttackIndicators(ctx) {
                this.attackIndicators.forEach(indicator => {
                    const progress = 1 - (indicator.duration / indicator.maxDuration);
                    const alpha = 0.3 + (progress * 0.4); // Fade in as it fills

                    ctx.save();

                    // Apply rotation if angle is specified
                    if (indicator.angle && indicator.angle !== 0) {
                        ctx.translate(indicator.x, indicator.y);
                        ctx.rotate(indicator.angle);
                        ctx.translate(-indicator.x, -indicator.y);
                    }

                    if (indicator.shape === 'rect') {
                        // Center the rectangle vertically for proper rotation
                        const rectY = indicator.y - indicator.height / 2;

                        // Draw background
                        ctx.fillStyle = `rgba(0, 0, 0, 0.3)`;
                        ctx.fillRect(indicator.x, rectY, indicator.width, indicator.height);

                        // Draw fill from center
                        const fillWidth = indicator.width * progress;
                        const startX = indicator.x + (indicator.width - fillWidth) / 2;

                        ctx.fillStyle = indicator.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                        ctx.fillRect(startX, rectY, fillWidth, indicator.height);

                        // Draw border
                        ctx.strokeStyle = indicator.color;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(indicator.x, rectY, indicator.width, indicator.height);

                    } else if (indicator.shape === 'circle') {
                        // Draw background circle
                        ctx.fillStyle = `rgba(0, 0, 0, 0.3)`;
                        ctx.beginPath();
                        ctx.arc(indicator.x, indicator.y, indicator.width, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw fill arc
                        ctx.fillStyle = indicator.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                        ctx.beginPath();
                        ctx.arc(indicator.x, indicator.y, indicator.width * progress, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw border
                        ctx.strokeStyle = indicator.color;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(indicator.x, indicator.y, indicator.width, 0, Math.PI * 2);
                        ctx.stroke();

                    } else if (indicator.shape === 'line') {
                        // Draw line indicator with proper direction
                        const lineLength = indicator.width * progress;
                        ctx.strokeStyle = indicator.color;
                        ctx.lineWidth = indicator.height;
                        ctx.beginPath();
                        ctx.moveTo(indicator.x, indicator.y);
                        ctx.lineTo(indicator.x + lineLength, indicator.y);
                        ctx.stroke();
                    }

                    ctx.restore();
                });
            },

            damageMob(mobId, damage) {
                let mob = this.mobs.find(m => m.id === mobId);
                let isBoss = false;

                if (!mob) {
                    mob = this.bosses.find(m => m.id === mobId);
                    isBoss = true;
                }

                if (mob) {
                    // Check if mob is invincible (e.g., Aether Dragon during Destruction Phase)
                    if (mob.invincible) {
                        console.log(`??? ${mob.name} is INVINCIBLE! No damage taken.`);
                        return; // No damage taken
                    }

                    // TOXIC ZEPHYR - Evasion chance
                    if (mob.evasionChance && mob.type === 'toxic_zephyr') {
                        if (Math.random() < mob.evasionChance) {
                            console.log(`?? ${mob.name} evaded the attack!`);
                            // Quick dash away
                            const angle = Math.random() * Math.PI * 2;
                            mob.x += Math.cos(angle) * 60;
                            mob.y += Math.sin(angle) * 60;
                            return; // No damage taken
                        }
                    }

                    // TEMPEST LORD - Wind Barrier (reflects damage) - NERFED v4
                    if (mob.windBarrier && mob.type === 'tempest_lord') {
                        const reflectedDamage = Math.floor(damage * 0.10); // 10% reflection (NERFED v4: 12% ? 10%)
                        Player.takeDamage(reflectedDamage);
                        console.log(`??? Wind Barrier reflected ${reflectedDamage} damage back!`);
                    }

                    // BUFFED v5: Apply Radioactive Damage Buff from Wind Master
                    let finalDamage = damage;
                    if (Player.radioactiveDamageBuff && Player.radioactiveDamageBuff > 0) {
                        // Check if buff is still active
                        const buffTimeElapsed = Date.now() - (Player.radioactiveBuffStartTime || 0);
                        if (buffTimeElapsed < (Player.radioactiveBuffDuration || 0)) {
                            finalDamage = damage * (1 + Player.radioactiveDamageBuff);
                        } else {
                            // Buff expired
                            Player.radioactiveDamageBuff = 0;
                        }
                    }

                    // Generic amplification hooks (used by multiple classes)
                    if (typeof mob.damageAmplification === 'number' && mob.damageAmplification > 1) {
                        finalDamage *= mob.damageAmplification;
                    }

                    // Death Mark from Anubis and other classes
                    if (mob.deathMarked) {
                        if (!mob.deathMarkUntil && mob.deathMarkTime) {
                            mob.deathMarkUntil = Date.now() + mob.deathMarkTime;
                        }
                        if (mob.deathMarkUntil && Date.now() <= mob.deathMarkUntil) {
                            finalDamage *= (mob.deathMarkMultiplier || 1.25);
                        } else if (mob.deathMarkUntil && Date.now() > mob.deathMarkUntil) {
                            mob.deathMarked = false;
                            mob.deathMarkTime = 0;
                            mob.deathMarkMultiplier = 1;
                            mob.deathMarkUntil = null;
                        }
                    }

                    mob.hp -= finalDamage;

                    // Track damage dealt for mastery missions
                    if (EquipmentManager.equippedRole && EquipmentManager.equippedRole.type === 'class') {
                        LoadoutManager.updateMissionProgress(EquipmentManager.equippedRole.id, 'deal_damage', damage);
                    }

                    if (mob.hp <= 0) {
                        this.score += isBoss ? 100 : 10;

                        // Track kills for mastery missions
                        if (EquipmentManager.equippedRole && EquipmentManager.equippedRole.type === 'class') {
                            const classId = EquipmentManager.equippedRole.id;

                            // Track general kills for all classes
                            if (classId === 'class_wind_master') {
                                LoadoutManager.updateMissionProgress(classId, 'kill_with_wind', 1);
                            } else if (classId === 'class_gunslinger') {
                                LoadoutManager.updateMissionProgress(classId, 'kill_with_gunslinger', 1);
                            } else if (classId === 'class_ninja') {
                                // Track kills for Shadow Ninja mastery mission
                                LoadoutManager.updateMissionProgress(classId, 'kill_with_ninja', 1);
                            }
                        }

                        // Abyssal Shadowlord Passive: Abismo Letal
                        // Each kill generates shadow essence (+10% crit stackable up to 5 stacks)
                        if (EquipmentManager.equippedRole && EquipmentManager.equippedRole.id === 'master_abyssal_shadowlord') {
                            if (!Player.shadowEssenceStacks) Player.shadowEssenceStacks = 0;
                            if (Player.shadowEssenceStacks < 5) {
                                Player.shadowEssenceStacks++;
                                Player.critBoost = Player.shadowEssenceStacks * 10; // 10% per stack
                                console.log(`? Abismo Letal: ${Player.shadowEssenceStacks} stacks (+${Player.critBoost}% crit)`);
                            }
                        }

                        // Continue with class-specific tracking
                        if (EquipmentManager.equippedRole && EquipmentManager.equippedRole.type === 'class') {
                            const classId = EquipmentManager.equippedRole.id;

                            // Track boss kills
                            if (isBoss && mob.type) {
                                if (classId === 'class_wind_master' && mob.type === 'tempest_lord') {
                                    LoadoutManager.updateMissionProgress(classId, 'kill_tempest_lord', 1);
                                } else if (classId === 'class_gunslinger' && mob.type === 'mech_titan') {
                                    LoadoutManager.updateMissionProgress(classId, 'kill_mech_titan', 1);
                                } else if (classId === 'class_ninja' && mob.type === 'shadow_emperor') {
                                    // Track Shadow Emperor kills for Shadow Ninja mastery mission
                                    LoadoutManager.updateMissionProgress(classId, 'kill_shadow_emperor', 1);
                                }
                            }

                            // Track specific mob kills (for Cyber Gunslinger)
                            if (classId === 'class_gunslinger' && mob.type === 'combat_drone') {
                                LoadoutManager.updateMissionProgress(classId, 'kill_combat_drones', 1);
                            }
                        }

                        // Drop class tickets
                        this.dropClassTicket(mob, isBoss);

                        // Give EXP based on mob level and type
                        let expGain = 0;
                        if (isBoss) {
                            expGain = 100 + (mob.level || 1) * 20; // Bosses give more EXP
                        } else {
                            expGain = 10 + (mob.level || 1) * 5; // Regular mobs
                        }

                        Player.gainExp(expGain, this.isCustomRaid);

                        if (isBoss) {
                            // Track boss kill for multi-boss dungeons
                            const currentDungeonData = this.isCustomRaid ? DungeonManager.dungeons[this.selectedRaidName] : null;
                            if (currentDungeonData && currentDungeonData.isMultiBossDungeon) {
                                if (!this.defeatedBosses) this.defeatedBosses = [];
                                if (!this.defeatedBosses.includes(mob.type)) {
                                    this.defeatedBosses.push(mob.type);

                                    // Show boss defeated notification with progress
                                    const bossIndex = this.defeatedBosses.length;
                                    const totalBosses = currentDungeonData.bossCount;

                                    if (!this.specialWaveNotifications) this.specialWaveNotifications = [];
                                    this.specialWaveNotifications.push({
                                        text: `💀 ¡${mob.name.toUpperCase()} DERROTADO! (${bossIndex}/${totalBosses}) 💀`,
                                        startTime: Date.now(),
                                        duration: 4000,
                                        color: '#ffd700'
                                    });

                                    console.log(`💀 Multi-boss progress: ${bossIndex}/${totalBosses} bosses defeated`);
                                }
                            }

                            this.bosses = this.bosses.filter(m => m.id !== mobId);
                        } else {
                            this.mobs = this.mobs.filter(m => m.id !== mobId);
                        }
                    }
                }
            },

            // Helper method to get all targets (mobs in raids, dummies in practice mode)
            getAllTargets() {
                if (PracticeModeManager.active) {
                    // Return dummies as targets in practice mode
                    return TrainingDummySystem.dummies.map(dummy => ({
                        id: dummy.id,
                        x: dummy.x,
                        y: dummy.y,
                        size: dummy.size,
                        hp: dummy.hp,
                        maxHp: dummy.maxHp,
                        isDummy: true
                    }));
                } else {
                    // Return mobs and bosses in raid mode
                    return [...this.mobs, ...this.bosses];
                }
            },

            // Show floating text (for critical hits, etc.)
            showFloatingText(x, y, text, color = '#fff') {
                if (!this.floatingTexts) this.floatingTexts = [];

                this.floatingTexts.push({
                    x: x,
                    y: y,
                    text: text,
                    color: color,
                    life: 1000,
                    startTime: Date.now()
                });
            },

            // Helper method to apply damage to any target (mob or dummy)
            damageTarget(target, damage) {
                let finalDamage = damage;

                // Apply critical hit chance
                if (EquipmentManager.equippedRole && EquipmentManager.equippedRole.type === 'class') {
                    const classId = EquipmentManager.equippedRole.id;
                    const allUpgrades = ClassProgressionSystem.getAllUpgradesForClass(classId);
                    const critUpgrades = allUpgrades.filter(u => u.type === 'crit');
                    const critChance = critUpgrades.reduce((sum, u) => sum + u.bonus, 0);

                    if (critChance > 0 && Math.random() * 100 < critChance) {
                        finalDamage *= 2; // Critical hit does 2x damage
                        console.log(`?? ¡CRÍTICO! ${finalDamage} daño`);

                        // Show critical hit indicator
                        this.showFloatingText(target.x, target.y, '?? CRÍTICO!', '#ff0');
                    }
                }

                // Apply lifesteal
                if (EquipmentManager.equippedRole && EquipmentManager.equippedRole.type === 'class') {
                    const classId = EquipmentManager.equippedRole.id;
                    const allUpgrades = ClassProgressionSystem.getAllUpgradesForClass(classId);
                    const lifestealUpgrades = allUpgrades.filter(u => u.type === 'lifesteal');
                    const lifestealPercent = lifestealUpgrades.reduce((sum, u) => sum + u.bonus, 0);

                    if (lifestealPercent > 0) {
                        const healAmount = Math.floor(finalDamage * (lifestealPercent / 100));
                        Player.hp = Math.min(Player.maxHp, Player.hp + healAmount);
                        console.log(`?? Robo de vida: +${healAmount} HP`);
                    }
                }

                if (target.isDummy) {
                    TrainingDummySystem.damageDummy(target.id, Math.floor(finalDamage));
                } else {
                    this.damageMob(target.id, Math.floor(finalDamage));
                }
            },

            checkAbilityHit(x, y, radius, damage = 25, onHit = null) {
                const allTargets = this.getAllTargets();
                let baseDamage = damage;
                let effectiveRadius = radius;

                // Apply player damage boost
                if (Player.damageBoost > 0) {
                    baseDamage *= (1 + Player.damageBoost / 100);
                }

                // Apply class damage multiplier and range multiplier
                if (EquipmentManager.equippedRole && EquipmentManager.equippedRole.type === 'class') {
                    const classId = EquipmentManager.equippedRole.id;
                    const damageMultiplier = ClassProgressionSystem.getDamageMultiplier(classId);
                    baseDamage *= damageMultiplier;

                    // Apply range multiplier
                    const allUpgrades = ClassProgressionSystem.getAllUpgradesForClass(classId);
                    const rangeUpgrades = allUpgrades.filter(u => u.type === 'range');
                    const rangeBonus = rangeUpgrades.reduce((sum, u) => sum + u.bonus, 0);
                    effectiveRadius *= (1 + rangeBonus / 100);
                }

                allTargets.forEach(target => {
                    const dx = target.x - x;
                    const dy = target.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < effectiveRadius + (target.size || 20)) {
                        this.damageTarget(target, baseDamage);
                        if (onHit) onHit(target);
                    }
                });
            },

            // DRAGONHUNTER ABILITIES
            dragonFlameArrow(ability) {
                const allTargets = this.getAllTargets();
                const nearbyTargets = allTargets.filter(target => {
                    const dx = target.x - Player.x;
                    const dy = target.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    return dist < 300;
                }).slice(0, 3); // Only 3 closest

                if (nearbyTargets.length === 0) {
                    console.log('?? No enemies nearby for Flame Arrow!');
                    return;
                }

                nearbyTargets.forEach(target => {
                    // Apply burn stacks (enemy will take damage when it attacks) - only for mobs
                    if (!target.isDummy) {
                        target.burning = true;
                        target.burnStacks = 3;
                    }

                    // Shoot arrow projectile
                    const angle = Math.atan2(target.y - Player.y, target.x - Player.x);
                    this.projectiles.push({
                        x: Player.x,
                        y: Player.y,
                        vx: Math.cos(angle) * 400,
                        vy: Math.sin(angle) * 400,
                        size: 8,
                        damage: 30,
                        color: '#ff4500',
                        life: 2000,
                        isFlameArrow: true,
                        isPlayerProjectile: true, // Mark as player projectile
                        targetId: target.id,
                        targetIsDummy: target.isDummy
                    });
                });

                console.log(`?? Flame Arrows shot at ${nearbyTargets.length} enemies! They'll take damage when attacking!`);
            },

            dragonBreathBomb() {
                const allMobs = this.getAllTargets();
                let affectedCount = 0;

                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 200) { // Medium radius
                        // Apply confusion
                        mob.confused = true;
                        mob.confusedTime = 4000; // 4 seconds

                        // 65% chance for burn
                        if (Math.random() < 0.65) {
                            mob.burning = true;
                            mob.burnStacks = Math.max(mob.burnStacks, 2);
                        }

                        affectedCount++;
                    }
                });

                console.log(`?? Dragon Breath affected ${affectedCount} enemies! Confusion + Burn!`);
            },

            draconicExplosion() {
                // Apply player buff
                Player.applyDamageBoost(25, 11000); // 25% for 11 seconds

                const allMobs = this.getAllTargets();
                let affectedCount = 0;

                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 250) { // Large radius
                        // Apply permanent damage reduction
                        mob.damageReduction = 10;
                        mob.damageReductionPermanent = true;

                        // Immediate damage
                        this.damageMob(mob.id, 80);

                        affectedCount++;
                    }
                });

                console.log(`?? Draconic Explosion! Player: +25% DMG | Enemies: -10% DMG (${affectedCount} affected)`);
            },

            // NEW DRAGONHUNTER ABILITIES
            tripleArrowUse() {
                // Flecha Triple Uso: 3 flechas a direcciones aleatorias
                // - Una traspasa enemigos (más daño por cada traspaso)
                // - Una inflige quemadura por 5s
                // - Una empuja hacia atrás

                const allMobs = [...this.mobs, ...this.bosses];
                if (allMobs.length === 0) {
                    console.log('?? No enemies for Triple Arrow!');
                    return;
                }

                // Arrow 1: Piercing arrow (traspasa enemigos)
                const angle1 = Math.random() * Math.PI * 2;
                let piercingDamage = 25;
                let piercedCount = 0;

                this.projectiles.push({
                    x: Player.x,
                    y: Player.y,
                    vx: Math.cos(angle1) * 450,
                    vy: Math.sin(angle1) * 450,
                    size: 10,
                    damage: piercingDamage,
                    color: '#00ffff',
                    life: 2500,
                    isPiercing: true,
                    piercedEnemies: [],
                    isPlayerProjectile: true,
                    onHit: (mob) => {
                        piercedCount++;
                        piercingDamage += 8; // +8 damage per pierce
                        return piercingDamage;
                    }
                });

                // Arrow 2: Burning arrow (quemadura 5s)
                const angle2 = Math.random() * Math.PI * 2;
                this.projectiles.push({
                    x: Player.x,
                    y: Player.y,
                    vx: Math.cos(angle2) * 450,
                    vy: Math.sin(angle2) * 450,
                    size: 10,
                    damage: 30,
                    color: '#ff4500',
                    life: 2500,
                    isBurningArrow: true,
                    isPlayerProjectile: true,
                    onHit: (mob) => {
                        mob.burning = true;
                        mob.burnStacks = 5;
                        mob.burnDuration = 5000; // 5 seconds
                        return 30;
                    }
                });

                // Arrow 3: Knockback arrow (empuja hacia atrás)
                const angle3 = Math.random() * Math.PI * 2;
                this.projectiles.push({
                    x: Player.x,
                    y: Player.y,
                    vx: Math.cos(angle3) * 450,
                    vy: Math.sin(angle3) * 450,
                    size: 10,
                    damage: 28,
                    color: '#ffbe0b',
                    life: 2500,
                    isKnockbackArrow: true,
                    isPlayerProjectile: true,
                    onHit: (mob) => {
                        const dx = mob.x - Player.x;
                        const dy = mob.y - Player.y;
                        const knockAngle = Math.atan2(dy, dx);
                        mob.x += Math.cos(knockAngle) * 80;
                        mob.y += Math.sin(knockAngle) * 80;
                        return 28;
                    }
                });

                console.log('?? Triple Arrow launched! Piercing, Burning, and Knockback arrows!');
            },

            draconicMadness() {
                // Locura Dracónica: Empuja enemigos + quemadura 2s + invencibilidad + 7 flechas + 3 flechas aleatorias con quemadura 4s
                const allMobs = this.getAllTargets();
                let affectedCount = 0;

                // PHASE 1: Push and burn nearby enemies
                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 300) { // Long range
                        // Push away
                        const pushAngle = Math.atan2(dy, dx);
                        mob.x += Math.cos(pushAngle) * 100;
                        mob.y += Math.sin(pushAngle) * 100;

                        // Apply burn for 2s
                        mob.burning = true;
                        mob.burnStacks = 2;
                        mob.burnDuration = 2000;

                        affectedCount++;
                    }
                });

                // PHASE 2: Invincibility
                Player.invulnerable = true;
                Player.invulnerableTime = 3000; // 3 seconds

                // PHASE 3: Shoot 7 arrows at nearby enemies (after 0.5s)
                setTimeout(() => {
                    const nearbyMobs = allMobs.filter(mob => {
                        const dx = mob.x - Player.x;
                        const dy = mob.y - Player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        return dist < 350;
                    }).slice(0, 7);

                    nearbyMobs.forEach(mob => {
                        const angle = Math.atan2(mob.y - Player.y, mob.x - Player.x);
                        this.projectiles.push({
                            x: Player.x,
                            y: Player.y,
                            vx: Math.cos(angle) * 500,
                            vy: Math.sin(angle) * 500,
                            size: 9,
                            damage: 35,
                            color: '#ff0000',
                            life: 2000,
                            isPlayerProjectile: true
                        });
                    });

                    console.log(`?? Locura Dracónica - Phase 2: ${nearbyMobs.length} arrows fired!`);
                }, 500);

                // PHASE 4: Shoot 3 random burning arrows (after 1.2s)
                setTimeout(() => {
                    for (let i = 0; i < 3; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        this.projectiles.push({
                            x: Player.x,
                            y: Player.y,
                            vx: Math.cos(angle) * 450,
                            vy: Math.sin(angle) * 450,
                            size: 10,
                            damage: 32,
                            color: '#ff6600',
                            life: 2500,
                            isBurningArrow: true,
                            isPlayerProjectile: true,
                            onHit: (mob) => {
                                mob.burning = true;
                                mob.burnStacks = 4;
                                mob.burnDuration = 4000; // 4 seconds
                                return 32;
                            }
                        });
                    }

                    console.log('?? Locura Dracónica - Phase 3: 3 burning arrows launched!');
                }, 1200);

                console.log(`?? Locura Dracónica activated! ${affectedCount} enemies pushed and burned! Invincibility active!`);
            },

            natureRising() {
                // Naturaleza en Ascenso: Invoca írboles y arbustos que reducen velocidad de enemigos
                const allMobs = [...this.mobs, ...this.bosses];

                // Create 8 nature obstacles around player
                const obstacles = [];
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i) / 8;
                    const distance = 80 + Math.random() * 40;
                    obstacles.push({
                        x: Player.x + Math.cos(angle) * distance,
                        y: Player.y + Math.sin(angle) * distance,
                        radius: 25,
                        duration: 8000, // 8 seconds
                        startTime: Date.now()
                    });
                }

                // Store obstacles for rendering and collision
                if (!this.natureObstacles) this.natureObstacles = [];
                this.natureObstacles.push(...obstacles);

                // Apply slow effect to enemies that touch obstacles
                const slowInterval = setInterval(() => {
                    if (this.natureObstacles.length === 0) {
                        clearInterval(slowInterval);
                        return;
                    }

                    allMobs.forEach(mob => {
                        this.natureObstacles.forEach(obstacle => {
                            const dx = mob.x - obstacle.x;
                            const dy = mob.y - obstacle.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < obstacle.radius + mob.size) {
                                // Apply slow (30% speed reduction)
                                if (!mob.natureSlowed) {
                                    mob.speed *= 0.7;
                                    mob.natureSlowed = true;

                                    // Remove slow after 2s
                                    setTimeout(() => {
                                        if (mob.natureSlowed) {
                                            mob.speed /= 0.7;
                                            mob.natureSlowed = false;
                                        }
                                    }, 2000);
                                }
                            }
                        });
                    });

                    // Remove expired obstacles
                    this.natureObstacles = this.natureObstacles.filter(obs => {
                        return Date.now() - obs.startTime < obs.duration;
                    });
                }, 100);

                console.log('?? Naturaleza en Ascenso - 8 nature obstacles created! Enemies will be slowed!');
            },

            // WIND MASTER ABILITIES
            ventoso() {
                // Ventoso: Todos los enemigos en rango corto reciben confusion por 5s
                const allMobs = this.getAllTargets();
                let affectedCount = 0;

                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 180) { // Short range
                        // Apply confusion
                        mob.confused = true;
                        mob.confusedTime = 5000; // 5 seconds
                        mob.confusedIntensity = 0.3; // Light deviation

                        affectedCount++;
                    }
                });

                console.log(`?? Ventoso - ${affectedCount} enemies confused for 5s!`);
            },

            ciclon() {
                // Ciclón: Todos los enemigos en rango mediano son empujados drásticamente y reciben confusion por 10s
                const allMobs = this.getAllTargets();
                let affectedCount = 0;

                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 280) { // Medium range
                        // Apply physics-based push (gradual, not teleport)
                        const pushAngle = Math.atan2(dy, dx);
                        const pushForce = 150; // Total push distance
                        const pushDuration = 400; // Duration in ms
                        const pushSteps = 20; // Number of steps for smooth animation
                        const pushPerStep = pushForce / pushSteps;

                        // Apply gradual push over time
                        for (let i = 0; i < pushSteps; i++) {
                            setTimeout(() => {
                                if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                    mob.x += Math.cos(pushAngle) * pushPerStep;
                                    mob.y += Math.sin(pushAngle) * pushPerStep;
                                }
                            }, (pushDuration / pushSteps) * i);
                        }

                        // Apply long confusion
                        mob.confused = true;
                        mob.confusedTime = 10000; // 10 seconds
                        mob.confusedIntensity = 0.5; // Moderate deviation

                        affectedCount++;
                    }
                });

                console.log(`?? Ciclón - ${affectedCount} enemies pushed and confused for 10s!`);
            },

            // ELEMENTALIST ABILITIES
            elementalStorm() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('elem_storm');
                const allMobs = this.getAllTargets();
                if (allMobs.length === 0) return;

                let closest = null;
                let minDist = Infinity;
                allMobs.forEach(mob => {
                    const d = Math.hypot(mob.x - Player.x, mob.y - Player.y);
                    if (d < minDist) { minDist = d; closest = mob; }
                });
                if (!closest || minDist > 460) return;

                EffectRenderer.playEffect('effect_elem_bolt', Player.x, Player.y);
                const chained = [closest];
                let current = closest;
                for (let i = 0; i < 5; i++) {
                    let next = null;
                    let nextDist = Infinity;
                    allMobs.forEach(mob => {
                        if (chained.includes(mob)) return;
                        const d = Math.hypot(mob.x - current.x, mob.y - current.y);
                        if (d < 280 && d < nextDist) {
                            nextDist = d;
                            next = mob;
                        }
                    });
                    if (!next) break;
                    chained.push(next);
                    current = next;
                }

                chained.forEach((mob, idx) => {
                    setTimeout(() => {
                        if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;
                        const damage = Math.max(26, 62 - (idx * 7));
                        this.damageTarget(mob, damage);
                        mob.confused = true;
                        mob.confusedTime = Math.max(mob.confusedTime || 0, 900);
                        mob.damageAmplification = Math.max(mob.damageAmplification || 1, 1.12);
                        mob.elemStormMarkUntil = Date.now() + 3000;
                        EffectRenderer.playEffect('effect_elem_bolt', mob.x, mob.y);

                        setTimeout(() => {
                            if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;
                            if (mob.elemStormMarkUntil && Date.now() >= mob.elemStormMarkUntil) {
                                mob.damageAmplification = Math.max(1, mob.damageAmplification || 1);
                                delete mob.elemStormMarkUntil;
                            }
                        }, 3100);
                    }, idx * 120);
                });
            },

            iceBarrier() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('elem_ice');
                const radius = 245;
                EffectRenderer.playEffect('effect_barrier', Player.x, Player.y);
                this.addAttackIndicator(Player.x, Player.y, radius, radius, 440, '#8ec5ff', 'circle');

                setTimeout(() => {
                    this.checkAbilityHit(Player.x, Player.y, radius, 36, (mob) => {
                        if (!mob.unyielding) {
                            const baseSpeed = mob.speed;
                            mob.speed = Math.max(6, baseSpeed * 0.35);
                            mob.confused = true;
                            mob.confusedTime = Math.max(mob.confusedTime || 0, 1400);
                            mob.elemIceArmorBreak = (mob.damageReduction || 0);
                            mob.damageReduction = Math.max(0, (mob.damageReduction || 0) - 18);
                            setTimeout(() => {
                                if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;
                                mob.speed = baseSpeed;
                                mob.damageReduction = mob.elemIceArmorBreak || mob.damageReduction;
                            }, 3200);
                        }

                        for (let i = 0; i < 4; i++) {
                            setTimeout(() => {
                                if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;
                                this.damageTarget(mob, 10);
                            }, 420 + (i * 300));
                        }
                    });
                }, 440);

                Player.invulnerable = true;
                Player.invulnerableTime = Math.max(Player.invulnerableTime || 0, 1800);
            },

            elementalCataclysm() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('elem_ultimate');
                const allMobs = this.getAllTargets();
                if (!allMobs.length) return;

                AbilityManager.screenShake();
                EffectRenderer.playEffect('effect_fury', Player.x, Player.y);
                Player.invulnerable = true;
                Player.invulnerableTime = Math.max(Player.invulnerableTime || 0, 3200);
                Player.applyDamageBoost(35, 6500);

                // Phase 1: Lightning ring
                this.checkAbilityHit(Player.x, Player.y, 300, 40, (mob) => {
                    mob.confused = true;
                    mob.confusedTime = Math.max(mob.confusedTime || 0, 1200);
                });

                // Phase 2: Fire wave
                setTimeout(() => {
                    this.checkAbilityHit(Player.x, Player.y, 340, 52, (mob) => {
                        mob.burning = true;
                        mob.burnStacks = Math.max(mob.burnStacks || 0, 4);
                    });
                }, 1100);

                // Phase 3: Cryo rupture
                setTimeout(() => {
                    this.checkAbilityHit(Player.x, Player.y, 360, 62, (mob) => {
                        const oldSpeed = mob.speed;
                        mob.speed = Math.max(6, oldSpeed * 0.55);
                        setTimeout(() => {
                            if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;
                            mob.speed = oldSpeed;
                        }, 2000);
                    });
                }, 2300);

                // Phase 4: Earth collapse finisher
                setTimeout(() => {
                    this.addAttackIndicator(Player.x, Player.y, 430, 430, 520, '#c084fc', 'circle');
                    setTimeout(() => {
                        this.checkAbilityHit(Player.x, Player.y, 430, 118, (mob) => {
                            mob.damageReduction = Math.max(0, (mob.damageReduction || 0) - 25);
                            setTimeout(() => {
                                if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;
                                mob.damageReduction = Math.max(0, (mob.damageReduction || 0) + 25);
                            }, 4500);
                        });
                        EffectRenderer.playEffect('effect_fury', Player.x, Player.y);
                        AbilityManager.screenShake();
                    }, 520);
                }, 3600);
            },

            // RONIN SAMURAI ABILITIES
            swiftCut() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('samurai_dash');
                const targets = this.getAllTargets();
                let angle = 0;
                if (targets.length > 0) {
                    const nearest = targets.reduce((best, t) => {
                        const d = Math.hypot(t.x - Player.x, t.y - Player.y);
                        return !best || d < best.d ? { t, d } : best;
                    }, null);
                    if (nearest && nearest.t) {
                        angle = Math.atan2(nearest.t.y - Player.y, nearest.t.x - Player.x);
                    }
                }

                const dashDistance = 270;
                const startX = Player.x;
                const startY = Player.y;
                const canvas = document.getElementById('game-canvas');
                const maxX = canvas ? canvas.width - 40 : 1240;
                const maxY = canvas ? canvas.height - 40 : 680;
                const endX = Math.max(40, Math.min(maxX, startX + Math.cos(angle) * dashDistance));
                const endY = Math.max(40, Math.min(maxY, startY + Math.sin(angle) * dashDistance));

                const pointToSegmentDistance = (px, py, x1, y1, x2, y2) => {
                    const vx = x2 - x1;
                    const vy = y2 - y1;
                    const len2 = vx * vx + vy * vy || 1;
                    let t = ((px - x1) * vx + (py - y1) * vy) / len2;
                    t = Math.max(0, Math.min(1, t));
                    const sx = x1 + t * vx;
                    const sy = y1 + t * vy;
                    return Math.hypot(px - sx, py - sy);
                };

                Player.x = endX;
                Player.y = endY;
                Player.invulnerable = true;
                Player.invulnerableTime = Math.max(Player.invulnerableTime || 0, 260);
                EffectRenderer.playEffect('effect_iaido', endX, endY);

                let hitCount = 0;
                this.getAllTargets().forEach(mob => {
                    const d = pointToSegmentDistance(mob.x, mob.y, startX, startY, endX, endY);
                    if (d <= 65) {
                        hitCount++;
                        this.damageTarget(mob, 58);
                        if (!mob.isDummy) {
                            mob.poisoned = true;
                            mob.poisonDamage = Math.max(mob.poisonDamage || 0, 7);
                            mob.poisonTickInterval = 500;
                            mob.poisonTime = Math.max(mob.poisonTime || 0, 2400);
                        }
                    }
                });

                console.log(`?? Iaido Relampago conectado: ${hitCount} objetivos.`);
            },

            counterAttack() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('samurai_counter');
                const duration = 2300;
                const token = Date.now() + Math.random();
                const prevReduction = Player.damageReduction || 0;

                Player.counterToken = token;
                Player.counterActive = true;
                Player.counterTime = duration;
                Player.damageReduction = Math.max(prevReduction, 70);
                EffectRenderer.playEffect('effect_parry', Player.x, Player.y);

                const retaliate = () => {
                    const targets = this.getAllTargets()
                        .map(t => ({ t, d: Math.hypot(t.x - Player.x, t.y - Player.y) }))
                        .filter(x => x.d <= 220)
                        .sort((a, b) => a.d - b.d)
                        .slice(0, 3);
                    targets.forEach((entry, idx) => {
                        setTimeout(() => {
                            if (!entry.t) return;
                            this.damageTarget(entry.t, 72);
                            entry.t.confused = true;
                            entry.t.confusedTime = Math.max(entry.t.confusedTime || 0, 700);
                            EffectRenderer.playEffect('effect_parry', entry.t.x, entry.t.y);
                        }, idx * 120);
                    });
                };

                setTimeout(() => {
                    if (Player.counterToken !== token) return;
                    retaliate();
                    Player.counterActive = false;
                    Player.damageReduction = prevReduction;
                }, duration);
            },

            ninjaPower() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('samurai_ninja_power');
                const duration = 6500;
                const token = Date.now() + Math.random();
                const oldSpeed = Player.speed;

                Player.samuraiMistToken = token;
                Player.invisible = true;
                Player.invisibleTime = duration;
                Player.invulnerable = true;
                Player.invulnerableTime = Math.max(Player.invulnerableTime || 0, 1200);
                Player.speed = (Player.baseSpeed || oldSpeed) * 1.35;

                const smokeBall = {
                    x: Player.x,
                    y: Player.y,
                    radius: 140,
                    duration,
                    startTime: Date.now()
                };
                if (!this.smokeBalls) this.smokeBalls = [];
                this.smokeBalls.push(smokeBall);
                EffectRenderer.playEffect('effect_ninja_power', Player.x, Player.y);

                const checkInterval = setInterval(() => {
                    if (Player.samuraiMistToken !== token || Date.now() - smokeBall.startTime > duration) {
                        clearInterval(checkInterval);
                        this.smokeBalls = (this.smokeBalls || []).filter(s => s !== smokeBall);
                        Player.speed = oldSpeed;
                        return;
                    }

                    this.getAllTargets().forEach(mob => {
                        const dist = Math.hypot(mob.x - smokeBall.x, mob.y - smokeBall.y);
                        if (dist < smokeBall.radius + (mob.size || 20)) {
                            mob.confused = true;
                            mob.confusedTime = Math.max(mob.confusedTime || 0, 1400);
                            mob.silenced = true;
                            mob.silencedTime = Math.max(mob.silencedTime || 0, 1200);
                            this.damageTarget(mob, 8);
                        }
                    });
                }, 240);

                setTimeout(() => {
                    if (Player.samuraiMistToken !== token) return;
                    Player.invisible = false;
                    Player.speed = oldSpeed;
                    delete Player.samuraiMistToken;
                }, duration);
            },

            surpriseCut() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('samurai_surprise_cut');
                const allMobs = this.getAllTargets();
                if (allMobs.length === 0) {
                    console.log('? No hay objetivos para Secuencia de Tres Cortes.');
                    return;
                }

                let closest = null;
                let minDist = Infinity;
                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        closest = mob;
                    }
                });

                if (!closest || minDist > 360) {
                    console.log('? Objetivo fuera de rango.');
                    return;
                }

                const cuts = [28, 35, 48];
                cuts.forEach((damage, idx) => {
                    setTimeout(() => {
                        if (!closest || (!this.mobs.includes(closest) && !this.bosses.includes(closest))) return;
                        this.damageTarget(closest, damage);
                        EffectRenderer.playEffect('effect_surprise_cut', closest.x, closest.y);
                        const ratio = closest.hp / Math.max(1, closest.maxHp || 1);
                        if (ratio < 0.25) {
                            this.damageTarget(closest, 24);
                        }
                    }, 120 + idx * 150);
                });
            },

            thousandLeavesDance() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('samurai_ultimate');
                EffectRenderer.playEffect('effect_thousand', Player.x, Player.y);
                AbilityManager.screenShake();

                const radius = 270;
                const duration = 2400;

                // Phase 1: slight pull
                this.getAllTargets().forEach(mob => {
                    const dx = Player.x - mob.x;
                    const dy = Player.y - mob.y;
                    const dist = Math.max(1, Math.hypot(dx, dy));
                    if (dist <= radius && dist > 35) {
                        mob.x += (dx / dist) * 38;
                        mob.y += (dy / dist) * 38;
                    }
                });

                // Phase 2: multi-hit storm
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        this.checkAbilityHit(Player.x, Player.y, radius, 22, (mob) => {
                            mob.confused = true;
                            mob.confusedTime = Math.max(mob.confusedTime || 0, 650);
                        });
                    }, i * 180);
                }

                // Phase 3: finisher with armor cut
                setTimeout(() => {
                    this.checkAbilityHit(Player.x, Player.y, radius + 40, 95, (mob) => {
                        mob.samuraiPrevReduction = mob.damageReduction || 0;
                        mob.damageReduction = Math.max(0, (mob.damageReduction || 0) - 35);
                        setTimeout(() => {
                            if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;
                            mob.damageReduction = mob.samuraiPrevReduction || 0;
                        }, 5000);
                    });
                    EffectRenderer.playEffect('effect_thousand', Player.x, Player.y);
                }, duration);
            },

            // WILD BERSERKER ABILITIES (REWORK)
            wildRage() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('berserker_rage');
                const duration = 10000;
                const token = Date.now() + Math.random();
                const hpCost = Math.max(1, Math.floor(Player.maxHp * 0.12));
                Player.hp = Math.max(1, Player.hp - hpCost);

                const baseSpeed = Player.speed;
                Player.berserkerRageToken = token;
                Player.berserkerRageActive = true;
                Player.berserkerCritBonus = 0.2;
                Player.speed = baseSpeed * 1.35;
                Player.applyDamageBoost(80, duration);
                EffectRenderer.playEffect('effect_rage', Player.x, Player.y);

                const interval = setInterval(() => {
                    if (Player.berserkerRageToken !== token || (!this.active && !PracticeModeManager.active)) {
                        clearInterval(interval);
                        return;
                    }

                    let hits = 0;
                    this.checkAbilityHit(Player.x, Player.y, 165, 22, (mob) => {
                        hits++;
                        mob.confused = true;
                        mob.confusedTime = Math.max(mob.confusedTime || 0, 450);
                    });

                    if (hits > 0) {
                        Player.hp = Math.min(Player.maxHp, Player.hp + (hits * 4));
                    }
                }, 430);

                setTimeout(() => {
                    if (Player.berserkerRageToken !== token) return;
                    clearInterval(interval);
                    Player.berserkerRageActive = false;
                    Player.berserkerCritBonus = 0;
                    Player.speed = baseSpeed;
                }, duration);
            },

            berserkerWhirlwind() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('berserker_whirlwind');
                EffectRenderer.playEffect('effect_whirlwind', Player.x, Player.y);
                const duration = 4000;
                const startTime = Date.now();
                const tickMs = 220;
                const radius = 230;

                const interval = setInterval(() => {
                    if ((!this.active && !PracticeModeManager.active) || Date.now() - startTime > duration) {
                        clearInterval(interval);
                        return;
                    }

                    const targets = this.getAllTargets();
                    targets.forEach(mob => {
                        const dx = mob.x - Player.x;
                        const dy = mob.y - Player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= radius && dist > 5) {
                            const pull = Math.min(38, (radius - dist) * 0.2 + 14);
                            mob.x -= (dx / dist) * pull;
                            mob.y -= (dy / dist) * pull;
                            this.damageTarget(mob, 24);
                            mob.confused = true;
                            mob.confusedTime = Math.max(mob.confusedTime || 0, 300);
                        }
                    });
                }, tickMs);

                setTimeout(() => {
                    this.addAttackIndicator(Player.x, Player.y, 250, 250, 420, '#d45a66', 'circle');
                    setTimeout(() => {
                        this.checkAbilityHit(Player.x, Player.y, 250, 78, (mob) => {
                            const dx = mob.x - Player.x;
                            const dy = mob.y - Player.y;
                            const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
                            mob.x += (dx / dist) * 95;
                            mob.y += (dy / dist) * 95;
                        });
                        EffectRenderer.playEffect('effect_whirlwind', Player.x, Player.y);
                    }, 420);
                }, duration - 420);
            },

            doubleAxes() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('berserker_axes');
                const targets = this.getAllTargets();
                let strikeX = Player.x;
                let strikeY = Player.y;
                let targetRef = null;

                if (targets.length > 0) {
                    targetRef = targets.reduce((best, t) => {
                        const d = Math.hypot(t.x - Player.x, t.y - Player.y);
                        return !best || d < best.d ? { t, d } : best;
                    }, null);
                }

                if (targetRef && targetRef.t) {
                    const t = targetRef.t;
                    const angle = Math.atan2(t.y - Player.y, t.x - Player.x);
                    strikeX = t.x;
                    strikeY = t.y;
                    Player.x = t.x - Math.cos(angle) * 68;
                    Player.y = t.y - Math.sin(angle) * 68;
                }

                EffectRenderer.playEffect('effect_axes', strikeX, strikeY);
                this.addAttackIndicator(strikeX, strikeY, 230, 230, 520, '#bf616a', 'circle');
                setTimeout(() => {
                    const allTargets = this.getAllTargets();
                    allTargets.forEach(mob => {
                        const dist = Math.hypot(mob.x - strikeX, mob.y - strikeY);
                        if (dist <= 230) {
                            const damage = dist <= 120 ? 130 : 65;
                            this.damageTarget(mob, damage);
                            if (dist <= 120) {
                                mob.confused = true;
                                mob.confusedTime = Math.max(mob.confusedTime || 0, 3000);
                                mob.armorBroken = true;
                                mob.berserkerAxesPrevReduction = mob.damageReduction || 0;
                                mob.damageReduction = Math.max(0, (mob.damageReduction || 0) - 50);
                                setTimeout(() => {
                                    if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;
                                    if (mob.armorBroken) {
                                        mob.armorBroken = false;
                                        mob.damageReduction = mob.berserkerAxesPrevReduction || 0;
                                    }
                                }, 8000);
                            }
                        }
                    });
                    AbilityManager.screenShake();
                }, 520);
            },

            berserkerBloodmark() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('berserker_bloodlust');
                const duration = 12000;
                const endAt = Date.now() + duration;
                const targets = this.getAllTargets().filter(mob => Math.hypot(mob.x - Player.x, mob.y - Player.y) <= 320);
                if (targets.length === 0) return;

                EffectRenderer.playEffect('effect_bloodlust', Player.x, Player.y);
                Player.berserkerBloodmarkUntil = endAt;

                targets.forEach(mob => {
                    mob.berserkerBloodmarkUntil = endAt;
                    mob.berserkerPrevAmplification = typeof mob.damageAmplification === 'number' ? mob.damageAmplification : 1;
                    mob.damageAmplification = Math.max(mob.berserkerPrevAmplification, 1.4);
                });

                const interval = setInterval(() => {
                    if ((!this.active && !PracticeModeManager.active) || Date.now() > endAt) {
                        clearInterval(interval);
                        targets.forEach(mob => {
                            if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;
                            if (mob.berserkerBloodmarkUntil && Date.now() >= mob.berserkerBloodmarkUntil) {
                                mob.damageAmplification = mob.berserkerPrevAmplification || 1;
                                delete mob.berserkerPrevAmplification;
                                delete mob.berserkerBloodmarkUntil;
                            }
                        });
                        return;
                    }

                    let drained = 0;
                    targets.forEach(mob => {
                        if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;
                        if (!mob.berserkerBloodmarkUntil || Date.now() > mob.berserkerBloodmarkUntil) return;
                        this.damageTarget(mob, 12);
                        drained += 3;
                    });
                    if (drained > 0) {
                        Player.hp = Math.min(Player.maxHp, Player.hp + drained);
                    }
                }, 820);
            },

            berserkerTransform() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('berserker_transform');
                const duration = 12000;
                const token = Date.now() + Math.random();
                const bonusHp = Math.floor(Player.maxHp * 0.5);
                const baseSpeed = Player.speed;
                const baseSize = Player.size || 30;
                const baseDamageReduction = Player.damageReduction || 0;

                Player.berserkerTransformToken = token;
                Player.maxHp += bonusHp;
                Player.hp = Math.min(Player.maxHp, Player.hp + bonusHp);
                Player.speed = baseSpeed * 1.25;
                Player.size = Math.max(baseSize * 1.5, baseSize + 20);
                Player.damageReduction = Math.max(baseDamageReduction, 35);
                Player.ccImmune = true;
                Player.applyDamageBoost(60, duration);
                EffectRenderer.playEffect('effect_transform', Player.x, Player.y);

                let trackedHp = Player.hp;
                let absorbedDamage = 0;
                const pulse = setInterval(() => {
                    if (Player.berserkerTransformToken !== token || (!this.active && !PracticeModeManager.active)) {
                        clearInterval(pulse);
                        return;
                    }
                    if (Player.hp < trackedHp) {
                        absorbedDamage += (trackedHp - Player.hp);
                    }
                    trackedHp = Player.hp;
                    this.checkAbilityHit(Player.x, Player.y, 115, 32);
                }, 600);

                setTimeout(() => {
                    if (Player.berserkerTransformToken !== token) return;
                    clearInterval(pulse);
                    const explosionDamage = Math.min(280, Math.floor(95 + (absorbedDamage * 0.7)));
                    this.addAttackIndicator(Player.x, Player.y, 265, 265, 520, '#ca5d67', 'circle');
                    setTimeout(() => {
                        this.checkAbilityHit(Player.x, Player.y, 265, explosionDamage);
                        EffectRenderer.playEffect('effect_apocalypse', Player.x, Player.y);
                    }, 520);

                    Player.maxHp = Math.max(1, Player.maxHp - bonusHp);
                    Player.hp = Math.min(Player.hp, Player.maxHp);
                    Player.speed = baseSpeed;
                    Player.size = baseSize;
                    Player.damageReduction = baseDamageReduction;
                    Player.ccImmune = false;
                }, duration);
            },

            bloodlust() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('berserker_ultimate');
                const duration = 9000;
                const token = Date.now() + Math.random();
                const baseSize = Player.size || 30;
                const baseSpeed = Player.speed;
                const baseReduction = Player.damageReduction || 0;
                const originalDamageMob = this.damageMob.bind(this);

                Player.berserkerGodToken = token;
                Player.berserkerGodKills = 0;
                Player.bloodthirstActive = true;
                Player.invulnerable = true;
                Player.invulnerableTime = Math.max(Player.invulnerableTime || 0, 2800);
                Player.size = Math.max(baseSize * 2.2, baseSize + 28);
                Player.speed = baseSpeed * 1.6;
                Player.damageReduction = Math.max(baseReduction, 55);
                Player.applyDamageBoost(220, duration);
                EffectRenderer.playEffect('effect_apocalypse', Player.x, Player.y);
                AbilityManager.screenShake();

                this.damageMob = (mobId, damage) => {
                    const mob = [...this.mobs, ...this.bosses].find(m => m.id === mobId);
                    const wasAlive = mob && mob.hp > 0;
                    const bonusDamage = damage * (1 + Math.min(1.2, (Player.berserkerGodKills || 0) * 0.12));
                    const result = originalDamageMob(mobId, bonusDamage);
                    if (mob && wasAlive && mob.hp <= 0 && Player.berserkerGodToken === token) {
                        Player.berserkerGodKills = (Player.berserkerGodKills || 0) + 1;
                        Player.hp = Math.min(Player.maxHp, Player.hp + (Player.maxHp * 0.12));
                        Player.applyDamageBoost(220 + Math.min(90, Player.berserkerGodKills * 10), 1300);
                        EffectRenderer.playEffect('effect_surprise', Player.x, Player.y);
                    }
                    return result;
                };

                const pulse = setInterval(() => {
                    if (Player.berserkerGodToken !== token || (!this.active && !PracticeModeManager.active)) {
                        clearInterval(pulse);
                        return;
                    }
                    this.checkAbilityHit(Player.x, Player.y, 220, 44, (mob) => {
                        const hpRatio = mob.hp / Math.max(1, mob.maxHp || 1);
                        if (hpRatio <= 0.3) {
                            this.damageMob(mob.id, (mob.hp || 0) + 1);
                        }
                    });
                }, 340);

                setTimeout(() => {
                    if (Player.berserkerGodToken !== token) return;
                    clearInterval(pulse);
                    this.damageMob = originalDamageMob;
                    Player.bloodthirstActive = false;
                    Player.size = baseSize;
                    Player.speed = baseSpeed;
                    Player.damageReduction = baseReduction;
                    Player.berserkerGodKills = 0;
                    delete Player.berserkerGodToken;
                }, duration);
            },

            // Legacy aliases kept for old configs
            devastatingLeap() {
                return this.berserkerWhirlwind();
            },

            berserkerSurprise() {
                return this.berserkerBloodmark();
            },

            // SHADOW NINJA ABILITIES (REDESIGNED)
            shadowStrike() {
                // Golpe de Sombra - Dash rápido con estela de sombras
                const allMobs = this.getAllTargets();
                if (allMobs.length === 0) {
                    console.log('??? No enemies for Shadow Strike!');
                    return;
                }

                // Find closest enemy
                let closest = null;
                let minDist = Infinity;
                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        closest = mob;
                    }
                });

                if (!closest || minDist > 400) {
                    console.log('??? No enemies in range!');
                    return;
                }

                // Store starting position for shadow trail
                const startX = Player.x;
                const startY = Player.y;

                // Dash to enemy
                const angle = Math.atan2(closest.y - Player.y, closest.x - Player.x);
                Player.x = closest.x - Math.cos(angle) * 60;
                Player.y = closest.y - Math.sin(angle) * 60;

                // Grant brief invincibility during and after dash (1.5 seconds)
                Player.invulnerable = true;
                Player.invulnerableTime = 1500;

                // Critical strike (daño escalado con nivel)
                const critDamage = Math.floor(45 + Player.getCurrentDamage() * 1.0);
                this.damageMob(closest.id, critDamage);

                // Create shadow trail that damages enemies
                const trailLength = Math.sqrt((Player.x - startX) ** 2 + (Player.y - startY) ** 2);
                const trailSegments = Math.floor(trailLength / 30);

                for (let i = 0; i < trailSegments; i++) {
                    const t = i / trailSegments;
                    const trailX = startX + (Player.x - startX) * t;
                    const trailY = startY + (Player.y - startY) * t;

                    // Check for enemies near this trail segment
                    setTimeout(() => {
                        allMobs.forEach(mob => {
                            const dx = mob.x - trailX;
                            const dy = mob.y - trailY;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < 40) {
                                const trailDamage = Math.floor(15 + Player.getCurrentDamage() * 0.3);
                                this.damageMob(mob.id, trailDamage);
                            }
                        });
                    }, i * 50);
                }

                console.log('??? Shadow Strike - Dashed to enemy with shadow trail!');
            },

            shurikenRain() {
                // Marca de Muerte - Marks enemies, making them take extra damage
                const allMobs = this.getAllTargets();
                if (allMobs.length === 0) {
                    console.log('?? No enemies to mark!');
                    return;
                }

                // Find 3 closest enemies
                const sortedMobs = allMobs
                    .map(mob => ({
                        mob,
                        dist: Math.sqrt((mob.x - Player.x) ** 2 + (mob.y - Player.y) ** 2)
                    }))
                    .sort((a, b) => a.dist - b.dist)
                    .slice(0, 3);

                let markedCount = 0;
                sortedMobs.forEach(({ mob }) => {
                    // Throw shuriken
                    const angle = Math.atan2(mob.y - Player.y, mob.x - Player.x);
                    this.projectiles.push({
                        x: Player.x,
                        y: Player.y,
                        vx: Math.cos(angle) * 450,
                        vy: Math.sin(angle) * 450,
                        size: 10,
                        damage: 28,
                        color: '#9d4edd',
                        life: 2500,
                        isPlayerProjectile: true
                    });

                    // Apply death mark (enemy takes 30% more damage for 8 seconds)
                    mob.deathMarked = true;
                    mob.deathMarkTime = 8000;
                    mob.deathMarkMultiplier = 1.3; // 30% more damage

                    markedCount++;
                });

                console.log(`?? Marca de Muerte - ${markedCount} enemies marked! They take 30% more damage!`);
            },

            shadowVeil() {
                // Paso Fantasma - Teleport behind closest enemy + brief invisibility + critical strike
                const allMobs = this.getAllTargets();
                if (allMobs.length === 0) {
                    console.log('?? No enemies to teleport to!');
                    return;
                }

                // Find closest enemy
                const closest = allMobs.reduce((prev, curr) => {
                    const prevDist = Math.sqrt((prev.x - Player.x) ** 2 + (prev.y - Player.y) ** 2);
                    const currDist = Math.sqrt((curr.x - Player.x) ** 2 + (curr.y - Player.y) ** 2);
                    return prevDist < currDist ? prev : curr;
                });

                // Teleport behind the enemy
                const angle = Math.atan2(Player.y - closest.y, Player.x - closest.x);
                Player.x = closest.x + Math.cos(angle) * 90;
                Player.y = closest.y + Math.sin(angle) * 90;

                // Critical strike damage (ignores armor, escalado con nivel)
                const criticalDamage = Math.floor(65 + Player.getCurrentDamage() * 1.3);
                const originalReduction = closest.damageReduction || 0;
                closest.damageReduction = 0;
                this.damageMob(closest.id, criticalDamage);
                setTimeout(() => {
                    if (this.mobs.includes(closest) || this.bosses.includes(closest)) {
                        closest.damageReduction = originalReduction;
                    }
                }, 100);

                // Brief invisibility (can't be hit)
                Player.invulnerable = true;
                Player.invulnerableTime = 2000;

                // Speed boost after teleport
                Player.speed *= 1.4;
                setTimeout(() => {
                    Player.speed /= 1.4;
                }, 3000);

                console.log('?? Paso Fantasma - Teleported behind enemy! Critical strike + invisibility!');
            },

            shadowClone() {
                // Clon de Sombra - Creates 2 shadow clones that attack enemies
                const allMobs = this.getAllTargets();
                if (allMobs.length === 0) {
                    console.log('?? No enemies for Shadow Clones!');
                    return;
                }

                // Create 2 clones at player position
                const clones = [];
                for (let i = 0; i < 2; i++) {
                    const angle = (Math.PI * 2 * i) / 2;
                    clones.push({
                        x: Player.x + Math.cos(angle) * 50,
                        y: Player.y + Math.sin(angle) * 50,
                        lifetime: 6000,
                        createdAt: Date.now(),
                        attackCooldown: 0
                    });
                }

                // Store clones for rendering and attacking
                if (!this.shadowClones) this.shadowClones = [];
                this.shadowClones.push(...clones);

                // Clone attack interval
                const cloneInterval = setInterval(() => {
                    if (this.shadowClones.length === 0) {
                        clearInterval(cloneInterval);
                        return;
                    }

                    // Remove expired clones
                    this.shadowClones = this.shadowClones.filter(clone => {
                        return Date.now() - clone.createdAt < clone.lifetime;
                    });

                    // Each clone attacks nearest enemy
                    this.shadowClones.forEach(clone => {
                        if (clone.attackCooldown > 0) {
                            clone.attackCooldown -= 500;
                            return;
                        }

                        // Find closest enemy to clone
                        let closest = null;
                        let minDist = Infinity;
                        allMobs.forEach(mob => {
                            const dx = mob.x - clone.x;
                            const dy = mob.y - clone.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < minDist && dist < 300) {
                                minDist = dist;
                                closest = mob;
                            }
                        });

                        if (closest) {
                            // Clone shoots projectile (50% del daño del jugador)
                            const cloneDamage = Math.floor((20 + Player.getCurrentDamage() * 0.4) * 0.5);
                            const angle = Math.atan2(closest.y - clone.y, closest.x - clone.x);
                            this.projectiles.push({
                                x: clone.x,
                                y: clone.y,
                                vx: Math.cos(angle) * 400,
                                vy: Math.sin(angle) * 400,
                                size: 8,
                                damage: cloneDamage,
                                color: '#2f2f2f',
                                life: 2000,
                                isPlayerProjectile: true
                            });
                            clone.attackCooldown = 1000; // 1 second cooldown
                        }
                    });
                }, 500);

                console.log('?? Shadow Clones - 2 clones created for 6 seconds!');
            },

            silentExecution() {
                // Asesino de Sombras - Execute low HP enemies instantly + massive damage to others
                const allMobs = this.getAllTargets();
                let executedCount = 0;
                let damagedCount = 0;

                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 280) {
                        const healthPercent = mob.hp / mob.maxHp;

                        // Execute enemies below 30% HP
                        if (healthPercent < 0.3) {
                            this.damageMob(mob.id, 9999); // Instant kill
                            executedCount++;
                        } else {
                            // Massive damage to others (ignores armor, escalado con nivel)
                            const executionDamage = Math.floor(85 + Player.getCurrentDamage() * 1.5);
                            const originalReduction = mob.damageReduction || 0;
                            mob.damageReduction = 0;
                            this.damageMob(mob.id, executionDamage);
                            setTimeout(() => {
                                if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                    mob.damageReduction = originalReduction;
                                }
                            }, 100);
                            damagedCount++;
                        }

                        // Apply bleeding effect
                        mob.bleeding = true;
                        mob.bleedStacks = 5;
                        mob.bleedDamage = 6;
                    }
                });

                // Player becomes invisible and gets damage boost
                Player.invulnerable = true;
                Player.invulnerableTime = 4000;
                Player.applyDamageBoost(50, 8000);

                console.log(`?? Asesino de Sombras - Executed ${executedCount} enemies! Damaged ${damagedCount} others!`);
            },

            // ABYSSAL SHADOWLORD ABILITIES (MASTER CLASS)
            abyssalBladeStorm() {
                // Tormenta de Cuchillas Sombrías - Dash múltiple con 5 slashes giratorios + estelas DoT
                const allMobs = [...this.mobs, ...this.bosses];
                if (allMobs.length === 0) {
                    console.log('??? No enemies for Blade Storm!');
                    return;
                }

                // Find 5 closest enemies for multi-dash
                const targets = allMobs
                    .map(mob => ({
                        mob,
                        dist: Math.sqrt((mob.x - Player.x) ** 2 + (mob.y - Player.y) ** 2)
                    }))
                    .sort((a, b) => a.dist - b.dist)
                    .slice(0, 5);

                let dashCount = 0;
                const dashDelay = 150; // 150ms between dashes

                // Invulnerability during entire combo
                Player.invulnerable = true;
                Player.invulnerableTime = 2000;

                targets.forEach(({ mob }, index) => {
                    setTimeout(() => {
                        const startX = Player.x;
                        const startY = Player.y;

                        // Dash to enemy
                        const angle = Math.atan2(mob.y - Player.y, mob.x - Player.x);
                        Player.x = mob.x - Math.cos(angle) * 50;
                        Player.y = mob.y - Math.sin(angle) * 50;

                        // Spinning slash damage (higher than base ninja)
                        this.damageMob(mob.id, 55);

                        // Create shadow trail with DoT and slow
                        const trailLength = Math.sqrt((Player.x - startX) ** 2 + (Player.y - startY) ** 2);
                        const trailSegments = Math.floor(trailLength / 25);

                        for (let i = 0; i < trailSegments; i++) {
                            const t = i / trailSegments;
                            const trailX = startX + (Player.x - startX) * t;
                            const trailY = startY + (Player.y - startY) * t;

                            setTimeout(() => {
                                allMobs.forEach(trailMob => {
                                    const dx = trailMob.x - trailX;
                                    const dy = trailMob.y - trailY;
                                    const dist = Math.sqrt(dx * dx + dy * dy);

                                    if (dist < 45) {
                                        // DoT damage
                                        this.damageMob(trailMob.id, 8);
                                        // Apply slow (50%)
                                        if (!trailMob.originalSpeed) trailMob.originalSpeed = trailMob.speed;
                                        trailMob.speed = trailMob.originalSpeed * 0.5;
                                        trailMob.slowed = true;
                                        setTimeout(() => {
                                            if (this.mobs.includes(trailMob) || this.bosses.includes(trailMob)) {
                                                trailMob.speed = trailMob.originalSpeed;
                                                trailMob.slowed = false;
                                            }
                                        }, 3000);
                                    }
                                });
                            }, i * 40);
                        }

                        dashCount++;
                    }, index * dashDelay);
                });

                console.log(`??? Tormenta de Cuchillas Sombrías - ${targets.length} dashes executed!`);
            },

            abyssalDeathChain() {
                // Cadena de Muerte - Marca 6 enemigos en cadena con +40% daño, daño salta entre targets
                const allMobs = [...this.mobs, ...this.bosses];
                if (allMobs.length === 0) {
                    console.log('?? No enemies for Death Chain!');
                    return;
                }

                // Find 6 closest enemies
                const targets = allMobs
                    .map(mob => ({
                        mob,
                        dist: Math.sqrt((mob.x - Player.x) ** 2 + (mob.y - Player.y) ** 2)
                    }))
                    .sort((a, b) => a.dist - b.dist)
                    .slice(0, 6);

                let chainedCount = 0;
                targets.forEach(({ mob }, index) => {
                    setTimeout(() => {
                        // Apply death mark (40% more damage for 10 seconds)
                        mob.deathMarked = true;
                        mob.deathMarkTime = 10000;
                        mob.deathMarkMultiplier = 1.4; // 40% more damage

                        // Initial chain damage
                        this.damageMob(mob.id, 35);

                        // Chain damage to nearby enemies
                        allMobs.forEach(nearbyMob => {
                            if (nearbyMob.id !== mob.id) {
                                const dx = nearbyMob.x - mob.x;
                                const dy = nearbyMob.y - mob.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist < 120) {
                                    // Chain jumps to nearby enemies
                                    this.damageMob(nearbyMob.id, 25);
                                }
                            }
                        });

                        chainedCount++;
                    }, index * 100);
                });

                console.log(`?? Cadena de Muerte - ${targets.length} enemies marked! Damage chains between targets!`);
            },

            abyssalVoidLeap() {
                // Salto al Vacío Fantasma - TP detrás del boss/elite + crítico x2 + AoE oscuridad que ciega
                const allMobs = [...this.mobs, ...this.bosses];
                if (allMobs.length === 0) {
                    console.log('?? No enemies for Void Leap!');
                    return;
                }

                // Prioritize bosses, then closest enemy
                let target = this.bosses.length > 0 ? this.bosses[0] : null;
                if (!target) {
                    target = allMobs.reduce((prev, curr) => {
                        const prevDist = Math.sqrt((prev.x - Player.x) ** 2 + (prev.y - Player.y) ** 2);
                        const currDist = Math.sqrt((curr.x - Player.x) ** 2 + (curr.y - Player.y) ** 2);
                        return prevDist < currDist ? prev : curr;
                    });
                }

                // Teleport behind target
                const angle = Math.atan2(Player.y - target.y, Player.x - target.x);
                Player.x = target.x + Math.cos(angle) * 100;
                Player.y = target.y + Math.sin(angle) * 100;

                // Critical strike x2 (ignores armor)
                const originalReduction = target.damageReduction || 0;
                target.damageReduction = 0;
                this.damageMob(target.id, 90); // Double critical
                setTimeout(() => {
                    if (this.mobs.includes(target) || this.bosses.includes(target)) {
                        target.damageReduction = originalReduction;
                    }
                }, 100);

                // AoE darkness that blinds enemies (reduces their vision/accuracy)
                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 180) {
                        // Blind effect - confuse enemies
                        mob.confused = true;
                        mob.confusedTime = 3000; // 3 seconds
                        // Reduce their effective range
                        if (!mob.originalRange) mob.originalRange = mob.range || 100;
                        mob.range = mob.originalRange * 0.3; // 70% vision reduction

                        setTimeout(() => {
                            if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                mob.confused = false;
                                mob.range = mob.originalRange;
                            }
                        }, 3000);

                        // AoE damage
                        this.damageMob(mob.id, 30);
                    }
                });

                // Brief invulnerability after leap
                Player.invulnerable = true;
                Player.invulnerableTime = 1500;

                console.log('?? Salto al Vacío Fantasma - Teleported behind target! AoE darkness blinds enemies!');
            },

            abyssalShadowLegion() {
                // Legión de Sombras - Invoca 5 clones que atacan (75% daño, 8s) y explotan al morir
                const allMobs = [...this.mobs, ...this.bosses];
                if (allMobs.length === 0) {
                    console.log('?? No enemies for Shadow Legion!');
                    return;
                }

                // Create 5 clones around player
                const clones = [];
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 * i) / 5;
                    const clone = {
                        id: `shadow_clone_${Date.now()}_${i}`,
                        x: Player.x + Math.cos(angle) * 80,
                        y: Player.y + Math.sin(angle) * 80,
                        hp: 50,
                        maxHp: 50,
                        damage: 0.75, // 75% of player damage
                        lifetime: 8000,
                        createdAt: Date.now(),
                        attackCooldown: 0,
                        attackRate: 1000 // Attack every 1 second
                    };
                    clones.push(clone);
                }

                // Store clones for tracking
                if (!this.shadowClones) this.shadowClones = [];
                this.shadowClones.push(...clones);

                // Clone attack logic
                const cloneInterval = setInterval(() => {
                    clones.forEach(clone => {
                        if (Date.now() - clone.createdAt > clone.lifetime) {
                            // Clone expires - explode
                            allMobs.forEach(mob => {
                                const dx = mob.x - clone.x;
                                const dy = mob.y - clone.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < 100) {
                                    this.damageMob(mob.id, 60); // Explosion damage
                                }
                            });
                            // Remove clone
                            const index = this.shadowClones.indexOf(clone);
                            if (index > -1) this.shadowClones.splice(index, 1);
                            return;
                        }

                        // Clone attacks nearest enemy
                        clone.attackCooldown -= 100;
                        if (clone.attackCooldown <= 0) {
                            const nearest = allMobs.reduce((prev, curr) => {
                                const prevDist = Math.sqrt((prev.x - clone.x) ** 2 + (prev.y - clone.y) ** 2);
                                const currDist = Math.sqrt((curr.x - clone.x) ** 2 + (curr.y - clone.y) ** 2);
                                return prevDist < currDist ? prev : curr;
                            });

                            if (nearest) {
                                const dist = Math.sqrt((nearest.x - clone.x) ** 2 + (nearest.y - clone.y) ** 2);
                                if (dist < 150) {
                                    this.damageMob(nearest.id, Math.floor(30 * clone.damage)); // 75% of base damage
                                    clone.attackCooldown = clone.attackRate;
                                }
                            }
                        }
                    });

                    // Clean up interval when all clones are gone
                    if (clones.every(c => Date.now() - c.createdAt > c.lifetime)) {
                        clearInterval(cloneInterval);
                    }
                }, 100);

                console.log('?? Legión de Sombras - 5 shadow clones summoned! They will explode on death!');
            },

            abyssalShadowEmperor() {
                // Emperador Sombra - Invoca mini-boss sombra (200 HP) que ataca y copia ataques
                const allMobs = [...this.mobs, ...this.bosses];

                // Create Shadow Emperor mini-boss
                const emperor = {
                    id: `shadow_emperor_miniboss_${Date.now()}`,
                    x: Player.x + 100,
                    y: Player.y,
                    hp: 200,
                    maxHp: 200,
                    damage: 40,
                    speed: 80,
                    size: 40,
                    lifetime: 15000, // 15 seconds
                    createdAt: Date.now(),
                    attackCooldown: 0,
                    attackRate: 1500, // Attack every 1.5 seconds
                    isBoss: false,
                    isMiniBoss: true
                };

                // Store emperor
                if (!this.shadowEmperors) this.shadowEmperors = [];
                this.shadowEmperors.push(emperor);

                // Emperor AI
                const emperorInterval = setInterval(() => {
                    if (Date.now() - emperor.createdAt > emperor.lifetime || emperor.hp <= 0) {
                        // Emperor expires or dies
                        const index = this.shadowEmperors.indexOf(emperor);
                        if (index > -1) this.shadowEmperors.splice(index, 1);
                        clearInterval(emperorInterval);
                        console.log('?? Shadow Emperor disappeared!');
                        return;
                    }

                    // Emperor attacks nearest enemy
                    emperor.attackCooldown -= 100;
                    if (emperor.attackCooldown <= 0 && allMobs.length > 0) {
                        const nearest = allMobs.reduce((prev, curr) => {
                            const prevDist = Math.sqrt((prev.x - emperor.x) ** 2 + (prev.y - emperor.y) ** 2);
                            const currDist = Math.sqrt((curr.x - emperor.x) ** 2 + (curr.y - emperor.y) ** 2);
                            return prevDist < currDist ? prev : curr;
                        });

                        if (nearest) {
                            const dist = Math.sqrt((nearest.x - emperor.x) ** 2 + (nearest.y - emperor.y) ** 2);
                            if (dist < 200) {
                                this.damageMob(nearest.id, emperor.damage);
                                emperor.attackCooldown = emperor.attackRate;

                                // Move towards enemy
                                const angle = Math.atan2(nearest.y - emperor.y, nearest.x - emperor.x);
                                emperor.x += Math.cos(angle) * emperor.speed * 0.1;
                                emperor.y += Math.sin(angle) * emperor.speed * 0.1;
                            }
                        }
                    }
                }, 100);

                console.log('?? Emperador Sombra - Shadow Emperor mini-boss summoned (200 HP, 15s duration)!');
            },

            abyssalEternalNight() {
                // Noche Eterna - Oscurece pantalla, ejecuta <25% HP en cadena, DoT masivo, invisibilidad
                const allMobs = [...this.mobs, ...this.bosses];
                let executedCount = 0;
                let damagedCount = 0;
                let chainExecutions = 0;

                // Phase 1: Execute enemies below 25% HP in chain (up to 10 jumps)
                const lowHpEnemies = allMobs.filter(mob => (mob.hp / mob.maxHp) < 0.25);

                lowHpEnemies.slice(0, 10).forEach((mob, index) => {
                    setTimeout(() => {
                        this.damageMob(mob.id, 9999); // Instant kill
                        executedCount++;
                        chainExecutions++;

                        // Chain to nearby enemies
                        allMobs.forEach(nearbyMob => {
                            if (nearbyMob.id !== mob.id) {
                                const dx = nearbyMob.x - mob.x;
                                const dy = nearbyMob.y - mob.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist < 150) {
                                    this.damageMob(nearbyMob.id, 50); // Chain damage
                                }
                            }
                        });
                    }, index * 200);
                });

                // Phase 2: Massive DoT to all remaining enemies
                allMobs.forEach(mob => {
                    if ((mob.hp / mob.maxHp) >= 0.25) {
                        // Apply massive bleeding DoT
                        mob.bleeding = true;
                        mob.bleedStacks = 10;
                        mob.bleedDamage = 12;

                        this.damageMob(mob.id, 70);
                        damagedCount++;

                        // Apply confusion
                        mob.confused = true;
                        mob.confusedTime = 6000;
                    }
                });

                // Phase 3: Player buffs
                Player.invulnerable = true;
                Player.invulnerableTime = 6000; // 6 seconds invulnerability
                Player.invisible = true;
                Player.invisibleTime = 6000;
                Player.applyDamageBoost(50, 10000); // 50% damage boost for 10 seconds

                // Permanent speed boost during duration
                const originalSpeed = Player.speed;
                Player.speed *= 1.5; // 50% speed boost
                setTimeout(() => {
                    Player.speed = originalSpeed;
                }, 6000);

                console.log(`?? NOCHE ETERNA - Executed ${executedCount} enemies in chain! Massive DoT applied to ${damagedCount} others! You are invisible and empowered!`);
            },

            // WIND MASTER ABILITIES
            radioactiveWind() {
                // Viento Radioactivo - Lanza viento en 4 direcciones que aplica radioactividad
                // BUFFED v5: Ahora otorga buff de daño al jugador según enemigos afectados
                const directions = [
                    { angle: 0, name: 'Este' },           // Right
                    { angle: Math.PI / 2, name: 'Sur' },  // Down
                    { angle: Math.PI, name: 'Oeste' },    // Left
                    { angle: -Math.PI / 2, name: 'Norte' } // Up
                ];

                let affectedCount = 0;
                const allMobs = [...this.mobs, ...this.bosses];
                const totalEnemies = allMobs.length;

                directions.forEach((dir, index) => {
                    setTimeout(() => {
                        // Create wind projectile
                        this.projectiles.push({
                            x: Player.x,
                            y: Player.y,
                            vx: Math.cos(dir.angle) * 300,
                            vy: Math.sin(dir.angle) * 300,
                            size: 20,
                            damage: 30, // BUFFED v19.11.2025: 25 ? 30
                            color: '#39ff14',
                            life: 3000,
                            isPlayerProjectile: true,
                            isRadioactive: true
                        });

                        // Check enemies in the path
                        allMobs.forEach(mob => {
                            const dx = mob.x - Player.x;
                            const dy = mob.y - Player.y;
                            const mobAngle = Math.atan2(dy, dx);
                            const angleDiff = Math.abs(mobAngle - dir.angle);
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            // If enemy is roughly in this direction (within 45 degrees) and close enough
                            if ((angleDiff < Math.PI / 4 || angleDiff > 7 * Math.PI / 4) && dist < 400) {
                                // Apply radioactivity
                                mob.radioactive = true;
                                mob.radioactiveTime = 7000; // 7 seconds
                                mob.radioactiveDamage = 4; // Damage per tick
                                mob.radioactiveTickInterval = 500; // Damage every 0.5s
                                affectedCount++;
                            }
                        });

                        // Apply damage buff based on affected enemies (after all directions processed)
                        if (index === directions.length - 1) {
                            setTimeout(() => {
                                const affectedPercentage = totalEnemies > 0 ? affectedCount / totalEnemies : 0;
                                let damageBonus = 0;

                                if (affectedPercentage >= 1.0) {
                                    // Hit ALL enemies - Maximum buff
                                    damageBonus = 0.20; // +20% damage
                                } else if (affectedPercentage >= 0.75) {
                                    // Hit 75%+ enemies
                                    damageBonus = 0.15; // +15% damage
                                } else if (affectedPercentage >= 0.50) {
                                    // Hit 50%+ enemies
                                    damageBonus = 0.10; // +10% damage
                                } else if (affectedPercentage >= 0.25) {
                                    // Hit 25%+ enemies
                                    damageBonus = 0.05; // +5% damage
                                }

                                if (damageBonus > 0) {
                                    Player.applyDamageBoost(damageBonus * 100, 6000);
                                    console.log(`??? Viento Radioactivo - ${affectedCount}/${totalEnemies} enemies affected! +${damageBonus * 100}% damage for 6s!`);
                                } else {
                                    console.log(`??? Viento Radioactivo - ${affectedCount} enemies affected!`);
                                }
                            }, 100);
                        }
                    }, index * 150);
                });
            },

            // TORNADO OVERLORD ABILITIES (MASTER CLASS)
            windSingularity() {
                // Singularidad Eólica - Crea agujero negro de viento estático
                const singularity = {
                    x: Player.x,
                    y: Player.y,
                    radius: 120,
                    pullRadius: 200,
                    duration: 8000,
                    startTime: Date.now()
                };

                if (!this.windSingularities) this.windSingularities = [];
                this.windSingularities.push(singularity);

                // Pull and stun enemies
                const pullInterval = setInterval(() => {
                    if (Date.now() - singularity.startTime > singularity.duration) {
                        clearInterval(pullInterval);
                        this.windSingularities = this.windSingularities.filter(s => s !== singularity);
                        return;
                    }

                    const allMobs = [...this.mobs, ...this.bosses];
                    allMobs.forEach(mob => {
                        const dx = singularity.x - mob.x;
                        const dy = singularity.y - mob.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < singularity.pullRadius) {
                            // Pull toward center
                            const pullForce = Math.max(0.1, 1 - (dist / singularity.pullRadius));
                            mob.x += (dx / dist) * pullForce * 8;
                            mob.y += (dy / dist) * pullForce * 8;

                            // Stun if very close
                            if (dist < singularity.radius) {
                                mob.stunned = true;
                                mob.stunnedTime = 3000;
                                mob.originalSpeed = mob.speed;
                                mob.speed = 0;

                                setTimeout(() => {
                                    if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                        mob.stunned = false;
                                        mob.speed = mob.originalSpeed || mob.speed;
                                    }
                                }, 3000);
                            }
                        }
                    });
                }, 50);

                console.log('?? Wind Singularity created! Pulling enemies for 8s!');
            },

            atmosphericPressure() {
                // Presión Atmosférica - Aplasta enemigos cercanos
                const allMobs = this.getAllTargets();
                let affectedCount = 0;

                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 180) {
                        // Root effect (immobilize)
                        mob.rooted = true;
                        mob.rootedTime = 2000;
                        mob.originalSpeed = mob.speed;
                        mob.speed = 0;

                        // Armor break effect
                        mob.armorBroken = true;
                        mob.armorBrokenTime = 4000;
                        mob.originalDamageReduction = mob.damageReduction || 0;
                        mob.damageReduction = 0;
                        mob.damageMultiplier = 1.2; // +20% damage received

                        // Immediate damage
                        this.damageMob(mob.id, 35);

                        affectedCount++;

                        // Restore speed after root
                        setTimeout(() => {
                            if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                mob.rooted = false;
                                mob.speed = mob.originalSpeed || mob.speed;
                            }
                        }, 2000);

                        // Remove armor break
                        setTimeout(() => {
                            if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                mob.armorBroken = false;
                                mob.damageReduction = mob.originalDamageReduction || 0;
                                mob.damageMultiplier = 1;
                            }
                        }, 4000);
                    }
                });

                console.log(`?? Atmospheric Pressure - ${affectedCount} enemies crushed! Root 2s + Armor Break 4s!`);
            },

            enemyTornado() {
                // Tornado de Enemigo - Semi-Ultimate
                const allMobs = [...this.mobs, ...this.bosses];
                if (allMobs.length === 0) {
                    console.log('?? No enemies for Enemy Tornado!');
                    return;
                }

                // Find closest enemy
                let victim = null;
                let minDist = Infinity;
                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        victim = mob;
                    }
                });

                if (!victim || minDist > 300) {
                    console.log('?? No enemies in range!');
                    return;
                }

                // Player becomes invulnerable
                Player.invulnerable = true;
                Player.invulnerableTime = 4000;

                // Grab victim and spin
                victim.grabbed = true;
                victim.grabStartTime = Date.now();

                const spinDuration = 3000;
                const spinInterval = setInterval(() => {
                    if (Date.now() - victim.grabStartTime > spinDuration) {
                        clearInterval(spinInterval);

                        // Launch victim
                        const launchAngle = Math.random() * Math.PI * 2;
                        victim.x += Math.cos(launchAngle) * 200;
                        victim.y += Math.sin(launchAngle) * 200;
                        this.damageMob(victim.id, 80);
                        victim.grabbed = false;

                        // Generate 4 static storms on remaining enemies
                        const remainingEnemies = allMobs.filter(m => m !== victim && (this.mobs.includes(m) || this.bosses.includes(m)));
                        const stormTargets = remainingEnemies.slice(0, 4);

                        stormTargets.forEach((target, index) => {
                            setTimeout(() => {
                                const storm = {
                                    x: target.x,
                                    y: target.y,
                                    radius: 80,
                                    duration: 6000,
                                    startTime: Date.now()
                                };

                                if (!this.staticStorms) this.staticStorms = [];
                                this.staticStorms.push(storm);

                                // Storm damage over time
                                const stormInterval = setInterval(() => {
                                    if (Date.now() - storm.startTime > storm.duration) {
                                        clearInterval(stormInterval);
                                        this.staticStorms = this.staticStorms.filter(s => s !== storm);
                                        return;
                                    }

                                    const currentMobs = [...this.mobs, ...this.bosses];
                                    currentMobs.forEach(mob => {
                                        const dx = mob.x - storm.x;
                                        const dy = mob.y - storm.y;
                                        const dist = Math.sqrt(dx * dx + dy * dy);

                                        if (dist < storm.radius) {
                                            this.damageMob(mob.id, 15);
                                            // Apply Strong Wind effect
                                            mob.strongWind = true;
                                            mob.strongWindTime = 7000;
                                            if (!mob.originalSpeed) mob.originalSpeed = mob.speed;
                                            mob.speed = mob.originalSpeed * 0.7; // -30% speed

                                            // Remove strong wind after duration
                                            setTimeout(() => {
                                                if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                                    mob.strongWind = false;
                                                    mob.speed = mob.originalSpeed || mob.speed;
                                                }
                                            }, 7000);
                                        }
                                    });
                                }, 500);
                            }, index * 200);
                        });

                        return;
                    }

                    // Spin victim around player
                    const elapsed = Date.now() - victim.grabStartTime;
                    const angle = (elapsed / 100) % (Math.PI * 2);
                    const radius = 60;

                    victim.x = Player.x + Math.cos(angle) * radius;
                    victim.y = Player.y + Math.sin(angle) * radius;

                    // Tornado damage to nearby enemies
                    allMobs.forEach(mob => {
                        if (mob === victim) return;

                        const dx = mob.x - Player.x;
                        const dy = mob.y - Player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 150) {
                            // Massive knockback
                            const knockAngle = Math.atan2(dy, dx);
                            mob.x += Math.cos(knockAngle) * 15;
                            mob.y += Math.sin(knockAngle) * 15;

                            // Damage every 200ms
                            if (elapsed % 200 < 50) {
                                this.damageMob(mob.id, 25);
                            }
                        }
                    });
                }, 50);

                console.log('?? Enemy Tornado! Spinning victim and creating massive tornado!');
            },

            tornadoBarrage() {
                // Ráfaga de Tornados - Lanza 5 tornados en patrón circular
                const tornadoCount = 5;
                const angleStep = (Math.PI * 2) / tornadoCount;

                for (let i = 0; i < tornadoCount; i++) {
                    const angle = angleStep * i;

                    this.projectiles.push({
                        x: Player.x,
                        y: Player.y,
                        vx: Math.cos(angle) * 350,
                        vy: Math.sin(angle) * 350,
                        size: 25,
                        damage: 45,
                        color: '#39ff14',
                        life: 4000,
                        isPlayerProjectile: true,
                        piercing: true, // Atraviesa enemigos
                        confuses: true // Aplica confusión
                    });
                }

                // Apply confusion to hit enemies
                setTimeout(() => {
                    const allMobs = [...this.mobs, ...this.bosses];
                    allMobs.forEach(mob => {
                        const dx = mob.x - Player.x;
                        const dy = mob.y - Player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 200) {
                            mob.confused = true;
                            mob.confusedTime = 4000;
                        }
                    });
                }, 100);

                console.log('??? Tornado Barrage - 5 tornados launched!');
            },

            stormShield() {
                // Escudo de Tormenta - Invulnerabilidad + reducción de daño
                Player.invulnerable = true;
                Player.invulnerableTime = 4000; // 4 seconds invulnerability

                // Additional damage reduction for 6 more seconds
                setTimeout(() => {
                    Player.stormShieldActive = true;
                    Player.damageReduction = (Player.damageReduction || 0) + 30; // 30% damage reduction

                    setTimeout(() => {
                        Player.stormShieldActive = false;
                        Player.damageReduction = Math.max(0, (Player.damageReduction || 0) - 30);
                    }, 6000);
                }, 4000);

                console.log('??? Storm Shield - Invulnerable for 4s + 30% damage reduction for 6s more!');
            },

            apocalypticStorm() {
                // Tormenta Apocalíptica - Ultimate devastador
                const allMobs = [...this.mobs, ...this.bosses];

                // Phase 1: Player invulnerable
                Player.invulnerable = true;
                Player.invulnerableTime = 5000;

                // Phase 2: Attract all enemies
                const attractDuration = 2000;
                const attractStartTime = Date.now();
                const attractInterval = setInterval(() => {
                    if (Date.now() - attractStartTime > attractDuration) {
                        clearInterval(attractInterval);
                    } else {
                        const currentMobs = [...this.mobs, ...this.bosses];
                        currentMobs.forEach(mob => {
                            const dx = Player.x - mob.x;
                            const dy = Player.y - mob.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist > 0) {
                                mob.x += (dx / dist) * 10;
                                mob.y += (dy / dist) * 10;
                            }
                        });
                    }
                }, 50);

                // Phase 3: Massive damage + confusion + radioactivity
                setTimeout(() => {
                    const currentMobs = [...this.mobs, ...this.bosses];
                    currentMobs.forEach(mob => {
                        const dx = mob.x - Player.x;
                        const dy = mob.y - Player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 300) {
                            // Massive damage
                            this.damageMob(mob.id, 100);

                            // Apply confusion
                            mob.confused = true;
                            mob.confusedTime = 6000;

                            // Apply radioactivity
                            mob.radioactive = true;
                            mob.radioactiveTime = 10000;
                            mob.radioactiveDamage = 8;
                            mob.radioactiveTickInterval = 500;
                        }
                    });
                }, 2000);

                // Phase 4: Launch 20 tornados
                setTimeout(() => {
                    for (let i = 0; i < 20; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;

                            this.projectiles.push({
                                x: Player.x,
                                y: Player.y,
                                vx: Math.cos(angle) * 400,
                                vy: Math.sin(angle) * 400,
                                size: 30,
                                damage: 60,
                                color: '#ff00ff',
                                life: 5000,
                                isPlayerProjectile: true,
                                piercing: true
                            });
                        }, i * 100);
                    }
                }, 2500);

                // Phase 5: Damage boost
                Player.applyDamageBoost(50, 10000); // +50% damage for 10s

                console.log('??? APOCALYPTIC STORM - Ultimate devastation unleashed!');
            },

            // CYBERNETIC WARLORD ABILITIES (MASTER CLASS)
            plasmaCannon() {
                // Cañón de Plasma - Rayo láser continuo que atraviesa enemigos
                const angle = Math.atan2(
                    this.mobs[0]?.y - Player.y || 0,
                    this.mobs[0]?.x - Player.x || 1
                );

                // Create thick laser beam
                const beamLength = 600;
                const beamWidth = 40;

                // Create laser projectile (daño escalado con nivel)
                const laserDamage = Math.floor(55 + Player.getCurrentDamage() * 1.2);
                this.projectiles.push({
                    x: Player.x,
                    y: Player.y,
                    vx: Math.cos(angle) * 500,
                    vy: Math.sin(angle) * 500,
                    size: beamWidth,
                    damage: laserDamage,
                    color: '#00ffff',
                    life: 2000,
                    isPlayerProjectile: true,
                    piercing: true,
                    isLaser: true
                });

                // Damage all enemies in line
                const allMobs = [...this.mobs, ...this.bosses];
                let hitCount = 0;

                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const mobAngle = Math.atan2(dy, dx);
                    const angleDiff = Math.abs(mobAngle - angle);

                    // Check if enemy is in laser path
                    if ((angleDiff < 0.2 || angleDiff > Math.PI * 2 - 0.2) && dist < beamLength) {
                        this.damageMob(mob.id, laserDamage);
                        hitCount++;
                    }
                });

                // Increase heat
                Player.heat = Math.min(Player.maxHeat, Player.heat + 15);
                this.checkHeatSystem();

                console.log(`?? Plasma Cannon - Hit ${hitCount} enemies! Heat: ${Player.heat}%`);
            },

            singularityGrenade() {
                // Granada de Singularidad - Atrae enemigos y luego detona
                const grenadeX = Player.x + (Math.random() - 0.5) * 200;
                const grenadeY = Player.y + (Math.random() - 0.5) * 200;

                const grenade = {
                    x: grenadeX,
                    y: grenadeY,
                    radius: 120,
                    pullRadius: 180,
                    duration: 2000,
                    startTime: Date.now(),
                    detonated: false
                };

                if (!this.singularityGrenades) this.singularityGrenades = [];
                this.singularityGrenades.push(grenade);

                // Pull enemies
                const pullInterval = setInterval(() => {
                    if (Date.now() - grenade.startTime > grenade.duration) {
                        clearInterval(pullInterval);

                        // Detonate
                        if (!grenade.detonated) {
                            grenade.detonated = true;
                            const allMobs = [...this.mobs, ...this.bosses];
                            let hitCount = 0;

                            // Daño de detonación escalado
                            const detonationDamage = Math.floor(80 + Player.getCurrentDamage() * 1.5);

                            allMobs.forEach(mob => {
                                const dx = mob.x - grenade.x;
                                const dy = mob.y - grenade.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist < grenade.radius) {
                                    this.damageMob(mob.id, detonationDamage);
                                    hitCount++;
                                }
                            });

                            // Increase heat on detonation
                            Player.heat = Math.min(Player.maxHeat, Player.heat + 10);
                            this.checkHeatSystem();

                            console.log(`?? Singularity Grenade detonated! ${hitCount} enemies hit! Heat: ${Player.heat}%`);

                            // Remove grenade after explosion
                            setTimeout(() => {
                                this.singularityGrenades = this.singularityGrenades.filter(g => g !== grenade);
                            }, 500);
                        }
                        return;
                    }

                    // Pull enemies toward grenade
                    const allMobs = [...this.mobs, ...this.bosses];
                    allMobs.forEach(mob => {
                        const dx = grenade.x - mob.x;
                        const dy = grenade.y - mob.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < grenade.pullRadius && dist > 0) {
                            const pullForce = Math.max(0.1, 1 - (dist / grenade.pullRadius));
                            mob.x += (dx / dist) * pullForce * 6;
                            mob.y += (dy / dist) * pullForce * 6;
                        }
                    });
                }, 50);

                console.log('?? Singularity Grenade deployed! Pulling enemies...');
            },

            droneSwarm() {
                // Enjambre de Drones - 4 drones que orbitan y disparan
                const droneCount = 4;
                const drones = [];

                for (let i = 0; i < droneCount; i++) {
                    const angle = (Math.PI * 2 / droneCount) * i;
                    drones.push({
                        id: Date.now() + i,
                        angle: angle,
                        distance: 80,
                        startTime: Date.now(),
                        duration: 8000,
                        lastShot: 0,
                        shootCooldown: 800
                    });
                }

                if (!this.combatDrones) this.combatDrones = [];
                this.combatDrones.push(...drones);

                // Increase heat when deploying drones
                Player.heat = Math.min(Player.maxHeat, Player.heat + 8);
                this.checkHeatSystem();

                // Drone shooting interval
                const droneInterval = setInterval(() => {
                    const currentTime = Date.now();
                    const activeDrones = this.combatDrones.filter(d => currentTime - d.startTime < d.duration);

                    if (activeDrones.length === 0) {
                        clearInterval(droneInterval);
                        return;
                    }

                    activeDrones.forEach(drone => {
                        // Update drone position (orbit around player)
                        drone.angle += 0.05;
                        const droneX = Player.x + Math.cos(drone.angle) * drone.distance;
                        const droneY = Player.y + Math.sin(drone.angle) * drone.distance;

                        // Shoot at nearest enemy
                        if (currentTime - drone.lastShot > drone.shootCooldown) {
                            const allMobs = [...this.mobs, ...this.bosses];
                            if (allMobs.length > 0) {
                                // Find closest enemy
                                let closest = null;
                                let minDist = Infinity;

                                allMobs.forEach(mob => {
                                    const dx = mob.x - droneX;
                                    const dy = mob.y - droneY;
                                    const dist = Math.sqrt(dx * dx + dy * dy);

                                    if (dist < minDist && dist < 250) {
                                        minDist = dist;
                                        closest = mob;
                                    }
                                });

                                if (closest) {
                                    const angle = Math.atan2(closest.y - droneY, closest.x - droneX);
                                    const droneDamage = Math.floor(20 + Player.getCurrentDamage() * 0.4);

                                    this.projectiles.push({
                                        x: droneX,
                                        y: droneY,
                                        vx: Math.cos(angle) * 400,
                                        vy: Math.sin(angle) * 400,
                                        size: 8,
                                        damage: droneDamage,
                                        color: '#00ffff',
                                        life: 1500,
                                        isPlayerProjectile: true
                                    });

                                    drone.lastShot = currentTime;
                                }
                            }
                        }
                    });
                }, 50);

                // Remove drones after duration
                setTimeout(() => {
                    this.combatDrones = this.combatDrones.filter(d => !drones.includes(d));
                }, 8000);

                console.log('?? Drone Swarm deployed! 4 drones active for 8s!');
            },

            photonBarrier() {
                // Barrera de Fotones - Muro de energía estático
                const barrierX = Player.x + 80; // 80 pixels in front of player
                const barrierY = Player.y;

                const barrier = {
                    x: barrierX,
                    y: barrierY,
                    width: 20,
                    height: 150,
                    duration: 5000,
                    startTime: Date.now()
                };

                if (!this.photonBarriers) this.photonBarriers = [];
                this.photonBarriers.push(barrier);

                // Check collision with enemies
                const barrierInterval = setInterval(() => {
                    if (Date.now() - barrier.startTime > barrier.duration) {
                        clearInterval(barrierInterval);
                        this.photonBarriers = this.photonBarriers.filter(b => b !== barrier);
                        return;
                    }

                    const allMobs = [...this.mobs, ...this.bosses];
                    allMobs.forEach(mob => {
                        // Check if enemy is touching barrier
                        const dx = Math.abs(mob.x - barrier.x);
                        const dy = Math.abs(mob.y - barrier.y);

                        if (dx < barrier.width / 2 + mob.size && dy < barrier.height / 2 + mob.size) {
                            // Push enemy back
                            if (mob.x < barrier.x) {
                                mob.x -= 10;
                            } else {
                                mob.x += 10;
                            }

                            // Burn damage (escalado con nivel)
                            const burnDamage = Math.floor(15 + Player.getCurrentDamage() * 0.3);
                            this.damageMob(mob.id, burnDamage);
                        }
                    });
                }, 100);

                console.log('??? Photon Barrier deployed! Blocking enemies for 5s!');
            },

            mechSuit() {
                // Protocolo: MECH-SUIT - Armadura pesada con misiles teledirigidos
                // Impact damage on landing
                const allMobs = [...this.mobs, ...this.bosses];
                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 150) {
                        const impactDamage = Math.floor(50 + Player.getCurrentDamage() * 1.0);
                        this.damageMob(mob.id, impactDamage);

                        // Knockback
                        const angle = Math.atan2(dy, dx);
                        mob.x += Math.cos(angle) * 80;
                        mob.y += Math.sin(angle) * 80;
                    }
                });

                // Activate MECH-SUIT mode
                Player.mechSuitActive = true;
                Player.mechSuitTime = 10000;
                Player.mechSuitStartTime = Date.now();

                // Increase heat significantly when activating MECH-SUIT
                Player.heat = Math.min(Player.maxHeat, Player.heat + 20);
                this.checkHeatSystem();

                // Modify player stats
                Player.originalSpeed = Player.speed;
                Player.speed = Player.speed * 0.8; // -20% speed
                Player.damageReduction = (Player.damageReduction || 0) + 80; // +80% defense

                // Guided missiles system
                Player.guidedMissilesActive = true;

                // Restore after duration
                setTimeout(() => {
                    Player.mechSuitActive = false;
                    Player.speed = Player.originalSpeed || Player.baseSpeed;
                    Player.damageReduction = Math.max(0, (Player.damageReduction || 0) - 80);
                    Player.guidedMissilesActive = false;
                    console.log('?? MECH-SUIT deactivated!');
                }, 10000);

                console.log('?? MECH-SUIT activated! -20% speed, +80% defense, guided missiles for 10s!');
            },

            orbitalRagnarok() {
                // Satélite Orbital "Ragnarok" - Rayo láser devastador
                const targetX = Player.x + (Math.random() - 0.5) * 300;
                const targetY = Player.y + (Math.random() - 0.5) * 300;

                const orbital = {
                    x: targetX,
                    y: targetY,
                    radius: 150,
                    warningTime: 3000,
                    startTime: Date.now(),
                    fired: false
                };

                if (!this.orbitalStrikes) this.orbitalStrikes = [];
                this.orbitalStrikes.push(orbital);

                console.log('??? Orbital Ragnarok targeting... 3 seconds until impact!');

                // Fire after warning
                setTimeout(() => {
                    if (!orbital.fired) {
                        orbital.fired = true;

                        // Vaporize everything in area
                        const allMobs = [...this.mobs, ...this.bosses];
                        let hitCount = 0;

                        allMobs.forEach(mob => {
                            const dx = mob.x - orbital.x;
                            const dy = mob.y - orbital.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < orbital.radius) {
                                this.damageMob(mob.id, 9999); // Pure damage
                                hitCount++;
                            }
                        });

                        // Create burned ground
                        const burnedGround = {
                            x: orbital.x,
                            y: orbital.y,
                            radius: orbital.radius,
                            duration: 5000,
                            startTime: Date.now()
                        };

                        if (!this.burnedGrounds) this.burnedGrounds = [];
                        this.burnedGrounds.push(burnedGround);

                        // Damage over time on burned ground
                        const burnInterval = setInterval(() => {
                            if (Date.now() - burnedGround.startTime > burnedGround.duration) {
                                clearInterval(burnInterval);
                                this.burnedGrounds = this.burnedGrounds.filter(b => b !== burnedGround);
                                return;
                            }

                            const currentMobs = [...this.mobs, ...this.bosses];
                            currentMobs.forEach(mob => {
                                const dx = mob.x - burnedGround.x;
                                const dy = mob.y - burnedGround.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist < burnedGround.radius) {
                                    this.damageMob(mob.id, 10);
                                }
                            });
                        }, 500);

                        // Increase heat massively on ultimate use
                        Player.heat = Math.min(Player.maxHeat, Player.heat + 25);
                        this.checkHeatSystem();

                        console.log(`??? RAGNAROK FIRED! ${hitCount} enemies vaporized! Heat: ${Player.heat}%`);

                        // Remove orbital marker
                        setTimeout(() => {
                            this.orbitalStrikes = this.orbitalStrikes.filter(o => o !== orbital);
                        }, 1000);
                    }
                }, 3000);
            },

            // ===== ROMAN LEGIONARY ABILITIES =====

            gladiusFulminante() {
                // Gladius Fulminante - Serie de estocadas rápidas con aumento de velocidad de ataque
                const allMobs = [...this.mobs, ...this.bosses];
                if (allMobs.length === 0) {
                    console.log('?? No hay enemigos para Gladius Fulminante!');
                    return;
                }

                // Encontrar enemigos cercanos (radio 200)
                const nearbyEnemies = allMobs.filter(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    return dist < 200;
                });

                if (nearbyEnemies.length === 0) {
                    console.log('?? No hay enemigos cercanos!');
                    return;
                }

                // Ejecutar 5 estocadas rápidas
                const thrustCount = 5;
                let thrustIndex = 0;
                let enemiesHit = new Set();

                const thrustInterval = setInterval(() => {
                    if (thrustIndex >= thrustCount) {
                        clearInterval(thrustInterval);
                        return;
                    }

                    // Seleccionar enemigo aleatorio cercano
                    const currentNearby = allMobs.filter(mob => {
                        const dx = mob.x - Player.x;
                        const dy = mob.y - Player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        return dist < 200;
                    });

                    if (currentNearby.length > 0) {
                        const target = currentNearby[Math.floor(Math.random() * currentNearby.length)];

                        // Crear efecto visual de estocada (línea roja carmesí)
                        const angle = Math.atan2(target.y - Player.y, target.x - Player.x);
                        const thrustEffect = {
                            startX: Player.x,
                            startY: Player.y,
                            endX: target.x,
                            endY: target.y,
                            color: '#dc143c',
                            width: 4,
                            lifetime: 150,
                            createdAt: Date.now()
                        };

                        if (!this.gladiusThrusts) this.gladiusThrusts = [];
                        this.gladiusThrusts.push(thrustEffect);

                        // Daño por estocada
                        this.damageMob(target.id, 22);
                        enemiesHit.add(target.id);

                        // Crear partículas de sangre dorada (gloria romana)
                        for (let i = 0; i < 8; i++) {
                            const particleAngle = Math.random() * Math.PI * 2;
                            const particleSpeed = 100 + Math.random() * 150;
                            this.projectiles.push({
                                x: target.x,
                                y: target.y,
                                vx: Math.cos(particleAngle) * particleSpeed,
                                vy: Math.sin(particleAngle) * particleSpeed,
                                size: 4 + Math.random() * 4,
                                damage: 0,
                                color: Math.random() > 0.5 ? '#dc143c' : '#ffd700',
                                life: 400,
                                isPlayerProjectile: false,
                                isParticle: true
                            });
                        }
                    }

                    thrustIndex++;
                }, 120); // 120ms entre estocadas = muy rápido

                // Buff acumulativo de velocidad de ataque (5% por golpe)
                if (!Player.gladiusStacks) Player.gladiusStacks = 0;
                Player.gladiusStacks = Math.min(Player.gladiusStacks + 1, 10); // Máximo 10 stacks = 50%

                const attackSpeedBonus = Player.gladiusStacks * 0.05;

                // Aplicar buff visual al jugador
                Player.attackSpeedBonus = attackSpeedBonus;

                // El buff dura 8 segundos
                setTimeout(() => {
                    if (Player.gladiusStacks > 0) {
                        Player.gladiusStacks--;
                        Player.attackSpeedBonus = Player.gladiusStacks * 0.05;
                    }
                }, 8000);

                console.log(`?? Gladius Fulminante! ${thrustCount} estocadas! Velocidad de ataque: +${(attackSpeedBonus * 100).toFixed(0)}%`);
            },

            formacionTestudo() {
                // Formación Testudo - Escudo defensivo legendario romano
                console.log('??? FORMACIÓN TESTUDO! Defensa romana activada!');

                // Activar escudo testudo
                Player.testudoActive = true;
                Player.testudoStartTime = Date.now();
                Player.testudoDuration = 5000; // 5 segundos

                // Reducir daño recibido en 70%
                const originalDamageReduction = Player.damageReduction || 0;
                Player.damageReduction = 0.70;

                // Activar reflejo de daño (30% del daño bloqueado)
                Player.testudoReflect = 0.30;

                // Crear efecto visual de escudos romanos alrededor del jugador
                const shieldCount = 8;
                const testudoShields = [];

                for (let i = 0; i < shieldCount; i++) {
                    const angle = (Math.PI * 2 / shieldCount) * i;
                    testudoShields.push({
                        angle: angle,
                        distance: 60,
                        rotation: 0
                    });
                }

                Player.testudoShields = testudoShields;

                // Crear aura dorada pulsante
                Player.testudoAura = {
                    radius: 80,
                    pulseSpeed: 0.003,
                    color: '#ffd700'
                };

                // Después de 5 segundos, desactivar
                setTimeout(() => {
                    Player.testudoActive = false;
                    Player.damageReduction = originalDamageReduction;
                    Player.testudoReflect = 0;
                    Player.testudoShields = null;
                    Player.testudoAura = null;
                    console.log('??? Formación Testudo terminada');
                }, 5000);

                // Efecto de ondas de choque al activar
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const shockwave = {
                            x: Player.x,
                            y: Player.y,
                            radius: 0,
                            maxRadius: 150,
                            speed: 300,
                            color: '#dc143c',
                            lifetime: 800,
                            createdAt: Date.now()
                        };

                        if (!this.testudoShockwaves) this.testudoShockwaves = [];
                        this.testudoShockwaves.push(shockwave);
                    }, i * 200);
                }
            },

            lanzamientoPilum() {
                // Lanzamiento de Pilum - Tres jabalinas que atraviesan enemigos
                console.log('??? LANZAMIENTO DE PILUM! Jabalinas romanas!');

                const allMobs = [...this.mobs, ...this.bosses];
                if (allMobs.length === 0) {
                    console.log('??? No hay enemigos para lanzar pilum!');
                    return;
                }

                // Encontrar el enemigo más cercano para apuntar
                let closest = null;
                let minDist = Infinity;
                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        closest = mob;
                    }
                });

                if (!closest) return;

                // Lanzar 3 pilums en formación (centro, izquierda, derecha)
                const baseAngle = Math.atan2(closest.y - Player.y, closest.x - Player.x);
                const spreadAngles = [0, -0.25, 0.25]; // Centro, izquierda, derecha

                spreadAngles.forEach((angleOffset, index) => {
                    setTimeout(() => {
                        const angle = baseAngle + angleOffset;

                        // Crear pilum con efecto especial (daño escalado con nivel)
                        const pilumDamage = Math.floor(35 + Player.getCurrentDamage() * 0.8);
                        const pilum = {
                            x: Player.x,
                            y: Player.y,
                            vx: Math.cos(angle) * 500,
                            vy: Math.sin(angle) * 500,
                            angle: angle,
                            size: 25,
                            damage: pilumDamage,
                            color: '#8b4513', // Marrón para la madera
                            life: 3000,
                            isPlayerProjectile: true,
                            isPilum: true,
                            piercing: true, // Atraviesa enemigos
                            hitEnemies: new Set(), // Rastrear enemigos golpeados
                            armorReduction: 0.40, // 40% reducción de armadura
                            bleedDamage: 8, // Daño de sangrado por segundo
                            bleedDuration: 5000, // 5 segundos de sangrado
                            trail: [] // Estela del pilum
                        };

                        this.projectiles.push(pilum);

                        // Efecto de lanzamiento (partículas)
                        for (let i = 0; i < 5; i++) {
                            const particleAngle = angle + (Math.random() - 0.5) * 0.5;
                            this.projectiles.push({
                                x: Player.x,
                                y: Player.y,
                                vx: Math.cos(particleAngle) * (200 + Math.random() * 100),
                                vy: Math.sin(particleAngle) * (200 + Math.random() * 100),
                                size: 3,
                                damage: 0,
                                color: '#ffd700',
                                life: 300,
                                isPlayerProjectile: false,
                                isParticle: true
                            });
                        }
                    }, index * 100); // 100ms entre cada pilum
                });
            },

            gritoCenturion() {
                // Grito del Centurión - Aturde enemigos y aumenta daño
                console.log('?? GRITO DEL CENTURIÓN! ¿Por Roma!');

                const allMobs = [...this.mobs, ...this.bosses];
                if (allMobs.length === 0) {
                    console.log('?? No hay enemigos para el grito!');
                    return;
                }

                // Crear onda de sonido visual expansiva
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const soundWave = {
                            x: Player.x,
                            y: Player.y,
                            radius: 0,
                            maxRadius: 300,
                            speed: 400,
                            color: '#dc143c',
                            lifetime: 1000,
                            createdAt: Date.now(),
                            isSoundWave: true
                        };

                        if (!this.centurionWaves) this.centurionWaves = [];
                        this.centurionWaves.push(soundWave);
                    }, i * 150);
                }

                // Aturdir enemigos cercanos (radio 250)
                let stunnedCount = 0;
                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 250) {
                        // Aturdir por 2 segundos
                        mob.stunned = true;
                        mob.stunnedTime = 2000;
                        mob.stunnedStartTime = Date.now();

                        // Guardar velocidad original
                        if (!mob.originalSpeed) {
                            mob.originalSpeed = mob.speed;
                        }
                        mob.speed = 0;

                        // Restaurar velocidad después del aturdimiento
                        setTimeout(() => {
                            if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                mob.stunned = false;
                                mob.speed = mob.originalSpeed;
                            }
                        }, 2000);

                        // Efecto visual de aturdimiento
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                const starX = mob.x + (Math.random() - 0.5) * 40;
                                const starY = mob.y - mob.size - 20 + (Math.random() - 0.5) * 20;

                                this.projectiles.push({
                                    x: starX,
                                    y: starY,
                                    vx: 0,
                                    vy: -30,
                                    size: 12,
                                    damage: 0,
                                    color: '#ffff00',
                                    life: 800,
                                    isPlayerProjectile: false,
                                    isParticle: true,
                                    isStunStar: true
                                });
                            }, i * 200);
                        }

                        stunnedCount++;
                    }
                });

                // Buff de daño para el jugador (+50% durante 8 segundos)
                Player.centurionBoost = true;
                Player.centurionBoostMultiplier = 1.5;
                Player.centurionBoostTime = 8000;
                Player.centurionBoostStartTime = Date.now();

                setTimeout(() => {
                    Player.centurionBoost = false;
                    Player.centurionBoostMultiplier = 1.0;
                    console.log('?? Grito del Centurión terminado');
                }, 8000);

                // Crear aura carmesí alrededor del jugador
                Player.centurionAura = {
                    radius: 80,
                    color: '#dc143c',
                    duration: 8000,
                    startTime: Date.now()
                };

                console.log(`?? ${stunnedCount} enemigos aturdidos! +50% daño por 8s!`);
            },

            aguilaImperial() {
                // Águila Imperial - Semi-Ultimate Épica
                console.log('?? ÁGUILA IMPERIAL! ¡El espíritu de Roma desciende!');

                const allMobs = [...this.mobs, ...this.bosses];

                // Invulnerabilidad por 3 segundos
                Player.invulnerable = true;
                Player.invulnerableTime = 3000;

                // Crear Águila dorada gigante
                const eagle = {
                    x: Player.x,
                    y: -100, // Empieza arriba de la pantalla
                    targetY: Player.y,
                    size: 80,
                    descending: true,
                    startTime: Date.now(),
                    duration: 3000
                };

                if (!this.imperialEagles) this.imperialEagles = [];
                this.imperialEagles.push(eagle);

                // Animación de descenso del Águila
                const descentInterval = setInterval(() => {
                    if (eagle.descending && eagle.y < eagle.targetY) {
                        eagle.y += 15; // Velocidad de descenso
                    } else if (eagle.descending) {
                        eagle.descending = false;

                        // Al llegar, emitir ondas de choque doradas
                        for (let wave = 0; wave < 6; wave++) {
                            setTimeout(() => {
                                const shockwave = {
                                    x: Player.x,
                                    y: Player.y,
                                    radius: 0,
                                    maxRadius: 250,
                                    color: '#ffd700',
                                    lifetime: 800,
                                    createdAt: Date.now(),
                                    isEagleWave: true
                                };

                                if (!this.eagleShockwaves) this.eagleShockwaves = [];
                                this.eagleShockwaves.push(shockwave);

                                // Daño y empuje a enemigos
                                allMobs.forEach(mob => {
                                    const dx = mob.x - Player.x;
                                    const dy = mob.y - Player.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);

                                    if (dist < 250 && dist > 0) {
                                        // Daño escalado con nivel
                                        const eagleDamage = Math.floor(40 + Player.getCurrentDamage() * 0.8);
                                        this.damageMob(mob.id, eagleDamage);

                                        // Empuje
                                        const pushForce = 80;
                                        mob.x += (dx / dist) * pushForce;
                                        mob.y += (dy / dist) * pushForce;
                                    }
                                });
                            }, wave * 500);
                        }

                        clearInterval(descentInterval);
                    }
                }, 50);

                // Garantizar crítico en el siguiente ataque
                Player.guaranteedCrit = true;
                Player.guaranteedCritTime = 5000; // 5 segundos para usar el crítico

                setTimeout(() => {
                    Player.guaranteedCrit = false;
                    console.log('?? Águila Imperial terminada');
                }, 5000);

                // Partículas doradas cayendo del cielo
                for (let i = 0; i < 30; i++) {
                    setTimeout(() => {
                        const particleX = Player.x + (Math.random() - 0.5) * 200;
                        const particleY = -50;

                        this.projectiles.push({
                            x: particleX,
                            y: particleY,
                            vx: (Math.random() - 0.5) * 50,
                            vy: 200 + Math.random() * 100,
                            size: 6 + Math.random() * 6,
                            damage: 0,
                            color: '#ffd700',
                            life: 2000,
                            isPlayerProjectile: false,
                            isParticle: true,
                            isGoldenFeather: true
                        });
                    }, i * 50);
                }

                console.log('?? Invulnerable por 3s! Próximo ataque: CRÍTICO GARANTIZADO!');
            },

            legioAeterna() {
                // Legio Aeterna - Ultimate definitiva del Legionario Romano
                console.log('?? LEGIO AETERNA! ¡LA LEGIÓN ETERNA DE ROMA!');

                const allMobs = [...this.mobs, ...this.bosses];

                // Oscurecer el campo de batalla
                Player.legioAeternaActive = true;
                Player.legioAeternaStartTime = Date.now();
                Player.legioAeternaDuration = 4500;

                // Invulnerabilidad total durante la ultimate
                Player.invulnerable = true;
                Player.invulnerableTime = 4500;

                // Crear 20 legionarios fantasmales en formación de V (MÁXIMA OPTIMIZACIÓN)
                const legionaries = [];
                const rows = 5; // Solo 5 filas
                const legsPerRow = 4; // Solo 4 por fila
                const spacing = 70;
                const vAngle = Math.PI / 6; // íngulo de la V

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < legsPerRow; col++) {
                        const side = col < legsPerRow / 2 ? -1 : 1;
                        const colOffset = Math.abs(col - legsPerRow / 2);

                        const x = Player.x + side * (colOffset * spacing * Math.cos(vAngle));
                        const y = Player.y + 200 + (row * spacing) + (colOffset * spacing * Math.sin(vAngle));

                        legionaries.push({
                            x: x,
                            y: y,
                            speed: 12 + Math.random() * 6
                        });
                    }
                }

                Player.legioAeternaLegionaries = legionaries;

                // Aura dorada radiante y capa carmesí ondeando
                Player.legioAeternaAura = {
                    radius: 120,
                    color: '#ffd700',
                    capeWave: 0
                };

                // Daño masivo a todos los enemigos cada 0.5 segundos
                let damageCount = 0;
                const damageInterval = setInterval(() => {
                    if (damageCount >= 9) { // 9 ticks = 4.5 segundos
                        clearInterval(damageInterval);
                        return;
                    }

                    // Daño masivo escalado con nivel
                    const legionDamage = Math.floor(80 + Player.getCurrentDamage() * 2.0);

                    allMobs.forEach(mob => {
                        // Daño masivo
                        this.damageMob(mob.id, legionDamage);

                        // Aplicar Terror Romano
                        if (!mob.terrorRomano) {
                            mob.terrorRomano = true;
                            mob.originalSpeed = mob.speed;
                            mob.originalDamage = mob.damage;
                            mob.speed *= 0.2; // -80% velocidad
                            mob.damage *= 0.2; // -80% daño

                            // Restaurar después de la ultimate
                            setTimeout(() => {
                                if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                    mob.speed = mob.originalSpeed;
                                    mob.damage = mob.originalDamage;
                                    mob.terrorRomano = false;
                                }
                            }, 4500);
                        }
                    });

                    damageCount++;
                }, 500);

                // Efectos visuales Épicos
                // Partículas doradas y carmesí
                for (let i = 0; i < 100; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 300;
                        const particleX = Player.x + Math.cos(angle) * distance;
                        const particleY = Player.y + Math.sin(angle) * distance;

                        this.projectiles.push({
                            x: particleX,
                            y: particleY,
                            vx: (Math.random() - 0.5) * 100,
                            vy: -100 - Math.random() * 100,
                            size: 8 + Math.random() * 8,
                            damage: 0,
                            color: Math.random() > 0.5 ? '#ffd700' : '#dc143c',
                            life: 2000,
                            isPlayerProjectile: false,
                            isParticle: true
                        });
                    }, i * 30);
                }

                // Terminar después de 4.5 segundos
                setTimeout(() => {
                    Player.legioAeternaActive = false;
                    Player.legioAeternaLegionaries = null;
                    Player.legioAeternaAura = null;
                    console.log('?? Legio Aeterna terminada - ¡Gloria a Roma!');
                }, 4500);

                console.log('?? LEGIO AETERNA ACTIVADA! 20 legionarios de Élite cargan! Terror Romano aplicado!');
            },

            // ===== LEVEL SYSTEM HELPERS =====

            assignMobLevel(mob) {
                // Assign level based on player level with some variation
                const minLevel = Math.max(1, Player.level - 2);
                const maxLevel = Player.level + 3;
                mob.level = minLevel + Math.floor(Math.random() * (maxLevel - minLevel + 1));

                // Scale HP and damage based on level
                const levelMultiplier = 1 + (mob.level - 1) * 0.08; // +8% per level
                mob.maxHp = Math.floor(mob.maxHp * levelMultiplier);
                mob.hp = mob.maxHp;
                mob.damage = Math.floor(mob.damage * levelMultiplier);

                return mob;
            },

            // ===== SPARTAN HOPLITE ABILITIES =====

            doruPenetrante() {
                // Doru Penetrante - Lanza espartana que atraviesa enemigos
                console.log('??? DORU PENETRANTE! Lanza espartana!');

                const allMobs = [...this.mobs, ...this.bosses];
                if (allMobs.length === 0) {
                    console.log('??? No hay enemigos para lanzar el doru!');
                    return;
                }

                // Encontrar dirección hacia el enemigo más cercano
                let closest = null;
                let minDist = Infinity;
                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        closest = mob;
                    }
                });

                if (!closest) return;

                const angle = Math.atan2(closest.y - Player.y, closest.x - Player.x);

                // Crear doru (lanza espartana) con daño escalado
                const doruDamage = Math.floor(40 + Player.getCurrentDamage() * 0.9);
                const doru = {
                    x: Player.x,
                    y: Player.y,
                    vx: Math.cos(angle) * 550,
                    vy: Math.sin(angle) * 550,
                    angle: angle,
                    size: 30,
                    damage: doruDamage,
                    color: '#CD7F32', // Bronce
                    life: 3500,
                    isPlayerProjectile: true,
                    isDoru: true,
                    piercing: true,
                    hitEnemies: new Set(),
                    bleedDamage: 10,
                    bleedDuration: 6000,
                    trail: []
                };

                this.projectiles.push(doru);

                // Partículas de bronce al lanzar
                for (let i = 0; i < 8; i++) {
                    const particleAngle = angle + (Math.random() - 0.5) * 0.6;
                    this.projectiles.push({
                        x: Player.x,
                        y: Player.y,
                        vx: Math.cos(particleAngle) * (250 + Math.random() * 150),
                        vy: Math.sin(particleAngle) * (250 + Math.random() * 150),
                        size: 4,
                        damage: 0,
                        color: '#CD7F32',
                        life: 400,
                        isPlayerProjectile: false,
                        isParticle: true
                    });
                }

                console.log('??? Doru lanzado! Atravesarí a todos los enemigos!');
            },

            falangeEspartana() {
                // Falange Espartana - Formación defensiva con escudo hoplon
                console.log('??? FALANGE ESPARTANA! ¿Por Esparta!');

                const allMobs = [...this.mobs, ...this.bosses];

                // Activar falange
                Player.phalanxActive = true;
                Player.phalanxStartTime = Date.now();
                Player.phalanxDuration = 6000; // 6 segundos

                // Reducir daño recibido en 75%
                const originalDamageReduction = Player.damageReduction || 0;
                Player.damageReduction = 0.75;

                // Empujar enemigos cercanos
                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 150 && dist > 0) {
                        const pushForce = 120;
                        mob.x += (dx / dist) * pushForce;
                        mob.y += (dy / dist) * pushForce;
                        this.damageMob(mob.id, 25);
                    }
                });

                // Crear escudos hoplon alrededor del jugador
                const shieldCount = 6;
                const phalanxShields = [];

                for (let i = 0; i < shieldCount; i++) {
                    const angle = (Math.PI * 2 / shieldCount) * i;
                    phalanxShields.push({
                        angle: angle,
                        distance: 65,
                        rotation: 0
                    });
                }

                Player.phalanxShields = phalanxShields;

                // Aura roja espartana
                Player.phalanxAura = {
                    radius: 85,
                    pulseSpeed: 0.004,
                    color: '#8B0000'
                };

                // Después de 6 segundos, desactivar
                setTimeout(() => {
                    Player.phalanxActive = false;
                    Player.damageReduction = originalDamageReduction;
                    Player.phalanxShields = null;
                    Player.phalanxAura = null;
                    console.log('??? Falange Espartana terminada');
                }, 6000);

                // Ondas de choque al activar
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const shockwave = {
                            x: Player.x,
                            y: Player.y,
                            radius: 0,
                            maxRadius: 160,
                            speed: 320,
                            color: '#8B0000',
                            lifetime: 900,
                            createdAt: Date.now()
                        };

                        if (!this.phalanxShockwaves) this.phalanxShockwaves = [];
                        this.phalanxShockwaves.push(shockwave);
                    }, i * 250);
                }

                console.log('??? Falange Espartana activada! -75% daño recibido!');
            },

            cargaEspartana() {
                // Carga Espartana - Dash agresivo con escudo
                console.log('? CARGA ESPARTANA! ¡Adelante!');

                const allMobs = [...this.mobs, ...this.bosses];

                // Dirección de la carga (hacia el mouse o enemigo más cercano)
                let chargeAngle = 0;

                if (allMobs.length > 0) {
                    const closest = allMobs.reduce((prev, curr) => {
                        const prevDist = Math.sqrt((prev.x - Player.x) ** 2 + (prev.y - Player.y) ** 2);
                        const currDist = Math.sqrt((curr.x - Player.x) ** 2 + (curr.y - Player.y) ** 2);
                        return prevDist < currDist ? prev : curr;
                    });
                    chargeAngle = Math.atan2(closest.y - Player.y, closest.x - Player.x);
                } else {
                    chargeAngle = 0; // Carga hacia la derecha por defecto
                }

                // Guardar posición inicial
                const startX = Player.x;
                const startY = Player.y;

                // Distancia de carga
                const chargeDistance = 250;
                const targetX = Player.x + Math.cos(chargeAngle) * chargeDistance;
                const targetY = Player.y + Math.sin(chargeAngle) * chargeDistance;

                // Crear estela de carga
                const chargeTrail = [];
                const steps = 15;

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const trailX = startX + (targetX - startX) * t;
                    const trailY = startY + (targetY - startY) * t;

                    setTimeout(() => {
                        // Mover jugador
                        if (i === steps) {
                            Player.x = targetX;
                            Player.y = targetY;

                            // Asegurar que está dentro del canvas
                            const canvas = document.getElementById('game-canvas');
                            Player.x = Math.max(35, Math.min(canvas.width - 35, Player.x));
                            Player.y = Math.max(35, Math.min(canvas.height - 35, Player.y));
                        }

                        // Dañar y empujar enemigos en el camino
                        allMobs.forEach(mob => {
                            const dx = mob.x - trailX;
                            const dy = mob.y - trailY;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < 60) {
                                const chargeDamage = Math.floor(35 + Player.getCurrentDamage() * 0.7);
                                this.damageMob(mob.id, chargeDamage);

                                // Empujar y aturdir
                                const pushForce = 100;
                                mob.x += Math.cos(chargeAngle) * pushForce;
                                mob.y += Math.sin(chargeAngle) * pushForce;

                                // Aturdir por 1.5 segundos
                                if (!mob.stunned) {
                                    mob.stunned = true;
                                    mob.originalSpeed = mob.speed;
                                    mob.speed = 0;

                                    setTimeout(() => {
                                        if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                            mob.stunned = false;
                                            mob.speed = mob.originalSpeed;
                                        }
                                    }, 1500);
                                }
                            }
                        });

                        // Partículas de polvo
                        for (let j = 0; j < 3; j++) {
                            this.projectiles.push({
                                x: trailX,
                                y: trailY,
                                vx: (Math.random() - 0.5) * 100,
                                vy: (Math.random() - 0.5) * 100,
                                size: 5 + Math.random() * 5,
                                damage: 0,
                                color: '#8B0000',
                                life: 500,
                                isPlayerProjectile: false,
                                isParticle: true
                            });
                        }
                    }, i * 30); // 30ms por paso = carga rápida
                }

                // Buff de velocidad después de la carga
                Player.chargeSpeedBoost = true;
                Player.speed *= 1.5;

                setTimeout(() => {
                    Player.chargeSpeedBoost = false;
                    Player.speed = Player.baseSpeed;
                }, 3000);

                // Invulnerabilidad breve durante la carga
                Player.invulnerable = true;
                Player.invulnerableTime = 450; // Duración de la carga

                console.log('? Carga Espartana! +50% velocidad por 3s!');
            },

            gritoAroo() {
                // Grito de Guerra: ¡AROO! - El legendario grito espartano
                console.log('?? ¡AROO! ¡AROO! ¡AROO!');

                const allMobs = [...this.mobs, ...this.bosses];

                // Crear ondas de sonido masivas
                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        const soundWave = {
                            x: Player.x,
                            y: Player.y,
                            radius: 0,
                            maxRadius: 350,
                            speed: 450,
                            color: '#8B0000',
                            lifetime: 1200,
                            createdAt: Date.now(),
                            isArooWave: true
                        };

                        if (!this.arooWaves) this.arooWaves = [];
                        this.arooWaves.push(soundWave);
                    }, i * 180);
                }

                // Intimidar enemigos cercanos
                let intimidatedCount = 0;
                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 300) {
                        // Intimidación: reducir velocidad y daño temporalmente
                        mob.intimidated = true;
                        mob.originalSpeed = mob.speed;
                        mob.originalDamage = mob.damage;
                        mob.speed *= 0.7; // -30% velocidad
                        mob.damage *= 0.7; // -30% daño

                        setTimeout(() => {
                            if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                mob.speed = mob.originalSpeed;
                                mob.damage = mob.originalDamage;
                                mob.intimidated = false;
                            }
                        }, 10000);

                        intimidatedCount++;
                    }
                });

                // Buff masivo para el jugador
                Player.arooBoost = true;
                Player.arooDamageMultiplier = 1.6; // +60% daño
                Player.arooResistance = 0.4; // +40% resistencia
                Player.arooBoostTime = 10000;
                Player.arooBoostStartTime = Date.now();

                // Reducir daño recibido
                const originalDamageReduction = Player.damageReduction || 0;
                Player.damageReduction = Math.min(0.9, originalDamageReduction + Player.arooResistance);

                setTimeout(() => {
                    Player.arooBoost = false;
                    Player.arooDamageMultiplier = 1.0;
                    Player.damageReduction = originalDamageReduction;
                    console.log('?? Grito AROO terminado');
                }, 10000);

                // Aura roja intensa alrededor del jugador
                Player.arooAura = {
                    radius: 100,
                    color: '#8B0000',
                    duration: 10000,
                    startTime: Date.now()
                };

                console.log(`?? ¡AROO! ${intimidatedCount} enemigos intimidados! +60% daño, +40% resistencia!`);
            },

            bendicionAres() {
                // Bendición de Ares - El dios de la guerra bendice al guerrero
                console.log('?? BENDICIÓN DE ARES! ¡El dios de la guerra me bendice!');

                // Invulnerabilidad a control de masas
                Player.ccImmune = true;
                Player.aresBlessing = true;
                Player.aresBlessingStartTime = Date.now();
                Player.aresBlessingDuration = 8000;

                // Doble daño
                Player.aresDamageMultiplier = 2.0;

                // Curación por daño (20% lifesteal)
                Player.aresLifesteal = 0.20;

                // Invulnerabilidad total por 1 segundo al activar
                Player.invulnerable = true;
                Player.invulnerableTime = 1000;

                // Crear símbolo de Ares (espadas cruzadas) sobre el jugador
                Player.aresSymbol = {
                    active: true,
                    rotation: 0
                };

                // Partículas de fuego rojo alrededor
                for (let i = 0; i < 40; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 150;
                        const particleX = Player.x + Math.cos(angle) * distance;
                        const particleY = Player.y + Math.sin(angle) * distance;

                        this.projectiles.push({
                            x: particleX,
                            y: particleY,
                            vx: (Math.random() - 0.5) * 120,
                            vy: -150 - Math.random() * 100,
                            size: 8 + Math.random() * 8,
                            damage: 0,
                            color: Math.random() > 0.5 ? '#8B0000' : '#CD7F32',
                            life: 1500,
                            isPlayerProjectile: false,
                            isParticle: true
                        });
                    }, i * 40);
                }

                // Terminar después de 8 segundos
                setTimeout(() => {
                    Player.ccImmune = false;
                    Player.aresBlessing = false;
                    Player.aresDamageMultiplier = 1.0;
                    Player.aresLifesteal = 0;
                    Player.aresSymbol = null;
                    console.log('?? Bendición de Ares terminada');
                }, 8000);

                console.log('?? Bendición de Ares! x2 daño, 20% lifesteal, inmune a CC!');
            },

            lasTermopilas() {
                // Las Termópilas - Ultimate: Los 300 espartanos (18 hoplitas optimizados)
                console.log('?? LAS TERMÓPILAS! ¡Esta noche cenamos en el Hades!');

                const allMobs = [...this.mobs, ...this.bosses];

                // Oscurecer el campo de batalla
                Player.thermopylaeActive = true;
                Player.thermopylaeStartTime = Date.now();
                Player.thermopylaeDuration = 5000;

                // Invulnerabilidad total
                Player.invulnerable = true;
                Player.invulnerableTime = 5000;

                // Crear 18 hoplitas espartanos en formación de falange
                const hoplites = [];
                const rows = 6; // 6 filas
                const hoplitesPerRow = 3; // 3 por fila = 18 total
                const spacing = 60;

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < hoplitesPerRow; col++) {
                        const x = Player.x - (hoplitesPerRow * spacing / 2) + (col * spacing) + spacing / 2;
                        const y = Player.y + 150 + (row * spacing);

                        hoplites.push({
                            x: x,
                            y: y,
                            speed: 8 + Math.random() * 4
                        });
                    }
                }

                Player.thermopylaeHoplites = hoplites;

                // Aura dorada y roja
                Player.thermopylaeAura = {
                    radius: 110,
                    color: '#8B0000',
                    capeWave: 0
                };

                // Daño masivo cada 0.5 segundos
                let damageCount = 0;
                const damageInterval = setInterval(() => {
                    if (damageCount >= 10) {
                        clearInterval(damageInterval);
                        return;
                    }

                    // Daño escalado con nivel
                    const thermopylaeDamage = Math.floor(75 + Player.getCurrentDamage() * 1.8);

                    allMobs.forEach(mob => {
                        this.damageMob(mob.id, thermopylaeDamage);

                        // Aplicar Miedo Espartano
                        if (!mob.spartanFear) {
                            mob.spartanFear = true;
                            mob.originalSpeed = mob.speed;
                            mob.originalDamage = mob.damage;
                            mob.speed *= 0.3; // -70% velocidad
                            mob.damage *= 0.3; // -70% daño

                            setTimeout(() => {
                                if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                    mob.speed = mob.originalSpeed;
                                    mob.damage = mob.originalDamage;
                                    mob.spartanFear = false;
                                }
                            }, 5000);
                        }
                    });

                    damageCount++;
                }, 500);

                // Partículas Épicas
                for (let i = 0; i < 60; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 250;
                        const particleX = Player.x + Math.cos(angle) * distance;
                        const particleY = Player.y + Math.sin(angle) * distance;

                        this.projectiles.push({
                            x: particleX,
                            y: particleY,
                            vx: (Math.random() - 0.5) * 100,
                            vy: -120 - Math.random() * 80,
                            size: 6 + Math.random() * 6,
                            damage: 0,
                            color: Math.random() > 0.5 ? '#8B0000' : '#CD7F32',
                            life: 1800,
                            isPlayerProjectile: false,
                            isParticle: true
                        });
                    }, i * 50);
                }

                // Terminar después de 5 segundos
                setTimeout(() => {
                    Player.thermopylaeActive = false;
                    Player.thermopylaeHoplites = null;
                    Player.thermopylaeAura = null;
                    console.log('?? Las Termópilas terminadas - ¡Gloria a Esparta!');
                }, 5000);

                console.log('?? LAS TERMÓPILAS! 18 hoplitas de Élite! Miedo Espartano aplicado!');
            },

            checkHeatSystem() {
                // Check heat levels and apply effects
                if (Player.heat >= 100 && !Player.overheated) {
                    // OVERHEAT - Explosion + Silence
                    Player.overheated = true;
                    Player.silenced = true;
                    Player.silencedTime = 2000;

                    // Area explosion
                    const allMobs = [...this.mobs, ...this.bosses];
                    let hitCount = 0;

                    allMobs.forEach(mob => {
                        const dx = mob.x - Player.x;
                        const dy = mob.y - Player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 200) {
                            this.damageMob(mob.id, 70);
                            hitCount++;

                            // Knockback
                            const angle = Math.atan2(dy, dx);
                            mob.x += Math.cos(angle) * 60;
                            mob.y += Math.sin(angle) * 60;
                        }
                    });

                    // Reset heat
                    Player.heat = 0;

                    // Remove silence after duration
                    setTimeout(() => {
                        Player.silenced = false;
                        Player.overheated = false;
                    }, 2000);

                    console.log(`?? OVERHEAT! Explosion hit ${hitCount} enemies! Silenced for 2s!`);
                }
            },

            // CYBER GUNSLINGER BASE ABILITIES
            orbitalStrike() {
                // Track ability usage for mastery missions
                LoadoutManager.trackAbilityUsage('gun_ultimate');

                // Orbital Strike - Ataque orbital que marca una zona y luego dispara
                const targetX = Player.x + (Math.random() - 0.5) * 250;
                const targetY = Player.y + (Math.random() - 0.5) * 250;

                const orbital = {
                    x: targetX,
                    y: targetY,
                    radius: 120,
                    warningTime: 2000,
                    startTime: Date.now(),
                    fired: false
                };

                if (!this.orbitalStrikes) this.orbitalStrikes = [];
                this.orbitalStrikes.push(orbital);

                console.log('?? Orbital Strike targeting... 2 seconds until impact!');

                // Fire after warning
                setTimeout(() => {
                    if (!orbital.fired) {
                        orbital.fired = true;

                        // Damage all enemies in area
                        const allMobs = [...this.mobs, ...this.bosses];
                        let hitCount = 0;

                        allMobs.forEach(mob => {
                            const dx = mob.x - orbital.x;
                            const dy = mob.y - orbital.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < orbital.radius) {
                                this.damageMob(mob.id, 150); // High damage
                                hitCount++;

                                // Knockback
                                const angle = Math.atan2(dy, dx);
                                mob.x += Math.cos(angle) * 50;
                                mob.y += Math.sin(angle) * 50;
                            }
                        });

                        console.log(`?? Orbital Strike FIRED! ${hitCount} enemies hit!`);

                        // Remove orbital marker
                        setTimeout(() => {
                            this.orbitalStrikes = this.orbitalStrikes.filter(o => o !== orbital);
                        }, 1000);
                    }
                }, 2000);
            },

            toxicAirBubbles() {
                // Burbujas de Aire Tóxico - 5 burbujas que explotan al contacto
                const bubbleCount = 5;

                for (let i = 0; i < bubbleCount; i++) {
                    setTimeout(() => {
                        // Random position near or far from player
                        const distance = 100 + Math.random() * 250; // 100-350 pixels away
                        const angle = Math.random() * Math.PI * 2;

                        const bubbleX = Player.x + Math.cos(angle) * distance;
                        const bubbleY = Player.y + Math.sin(angle) * distance;

                        // Create bubble object
                        const bubble = {
                            x: bubbleX,
                            y: bubbleY,
                            size: 35,
                            color: '#00ff88',
                            lifetime: 8000, // 8 seconds before auto-explode
                            createdAt: Date.now(),
                            exploded: false
                        };

                        // Add to bubbles array (we'll create this if it doesn't exist)
                        if (!this.toxicBubbles) this.toxicBubbles = [];
                        this.toxicBubbles.push(bubble);

                        // Check for collision with enemies periodically
                        const checkInterval = setInterval(() => {
                            if (bubble.exploded || Date.now() - bubble.createdAt > bubble.lifetime) {
                                clearInterval(checkInterval);
                                // Remove bubble
                                if (this.toxicBubbles) {
                                    this.toxicBubbles = this.toxicBubbles.filter(b => b !== bubble);
                                }
                                return;
                            }

                            const allMobs = [...this.mobs, ...this.bosses];
                            allMobs.forEach(mob => {
                                const dx = mob.x - bubble.x;
                                const dy = mob.y - bubble.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist < bubble.size + mob.size && !bubble.exploded) {
                                    // Explode bubble!
                                    bubble.exploded = true;

                                    // Apply poison to enemy
                                    mob.poisoned = true;
                                    mob.poisonTime = 2000; // 2 seconds
                                    mob.poisonDamage = 10; // BUFFED v19.11.2025: 8 ? 10
                                    mob.poisonTickInterval = 400; // Damage every 0.4s

                                    // Reduce defense and speed
                                    if (!mob.originalDefense) mob.originalDefense = mob.damageReduction || 0;
                                    if (!mob.originalSpeed) mob.originalSpeed = mob.speed;

                                    mob.damageReduction = Math.max(0, (mob.damageReduction || 0) - 15); // -15% defense
                                    mob.speed *= 0.4; // 60% speed reduction

                                    // Restore after poison ends
                                    setTimeout(() => {
                                        if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                            mob.poisoned = false;
                                            if (mob.originalDefense !== undefined) {
                                                mob.damageReduction = mob.originalDefense;
                                            }
                                            if (mob.originalSpeed !== undefined) {
                                                mob.speed = mob.originalSpeed;
                                            }
                                        }
                                    }, mob.poisonTime);

                                    console.log(`?? Burbuja explotí! ${mob.name} envenenado!`);
                                    clearInterval(checkInterval);
                                }
                            });
                        }, 50);
                    }, i * 200); // Stagger bubble creation
                }

                console.log('?? Burbujas de Aire Tóxico - 5 burbujas desplegadas!');
            },

            strongWindAttraction() {
                // Atracción del Viento Fuerte - Ultimate ability
                const allMobs = [...this.mobs, ...this.bosses];
                const pullRadius = 350; // Medium radius
                let affectedMobs = [];

                // Find all enemies in radius
                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < pullRadius) {
                        affectedMobs.push(mob);
                        // Store original position for pull effect
                        mob.pullStartX = mob.x;
                        mob.pullStartY = mob.y;
                        mob.beingPulled = true;
                    }
                });

                if (affectedMobs.length === 0) {
                    console.log('?? No hay enemigos cerca para atraer!');
                    return;
                }

                // Player gets invulnerability for 6 seconds
                Player.invulnerable = true;
                Player.invulnerableTime = 6000;

                // Pull enemies towards player for 3 seconds
                const pullDuration = 3000;
                const pullStartTime = Date.now();

                const pullInterval = setInterval(() => {
                    const elapsed = Date.now() - pullStartTime;

                    if (elapsed >= pullDuration) {
                        clearInterval(pullInterval);

                        // After 3 seconds, throw enemies in random directions
                        affectedMobs.forEach(mob => {
                            if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;

                            mob.beingPulled = false;

                            // Random direction and high speed
                            const throwAngle = Math.random() * Math.PI * 2;
                            const throwSpeed = 400 + Math.random() * 200; // 400-600 speed

                            // Apply velocity
                            mob.throwVelocityX = Math.cos(throwAngle) * throwSpeed;
                            mob.throwVelocityY = Math.sin(throwAngle) * throwSpeed;
                            mob.beingThrown = true;

                            // Damage from impact
                            this.damageMob(mob.id, 40);

                            // 65% chance to confuse
                            if (Math.random() < 0.65) {
                                mob.confused = true;
                                mob.confusedTime = 4000; // 4 seconds confusion
                            }

                            // Stop throw after 1 second
                            setTimeout(() => {
                                if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                    mob.beingThrown = false;
                                    mob.throwVelocityX = 0;
                                    mob.throwVelocityY = 0;
                                }
                            }, 1000);
                        });

                        console.log(`?? Enemigos lanzados en direcciones aleatorias! ${affectedMobs.filter(m => m.confused).length} confundidos!`);
                    } else {
                        // Pull enemies towards player
                        affectedMobs.forEach(mob => {
                            if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;

                            const dx = Player.x - mob.x;
                            const dy = Player.y - mob.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist > 50) { // Don't pull if too close
                                const pullSpeed = 8;
                                mob.x += (dx / dist) * pullSpeed;
                                mob.y += (dy / dist) * pullSpeed;
                            }
                        });
                    }
                }, 16); // ~60 FPS

                console.log(`?? Atracción del Viento Fuerte - ${affectedMobs.length} enemigos siendo atraídos!`);
            },

            // TORNADO OVERLORD ABILITIES (MASTER CLASS)
            windSingularity() {
                // Singularidad Eólica - Crea agujero negro de viento estático
                const singularity = {
                    x: Player.x,
                    y: Player.y,
                    radius: 150, // Large radius
                    pullStrength: 12,
                    duration: 5000,
                    startTime: Date.now()
                };

                if (!this.windSingularities) this.windSingularities = [];
                this.windSingularities.push(singularity);

                // Pull and stun enemies
                const pullInterval = setInterval(() => {
                    if (Date.now() - singularity.startTime > singularity.duration) {
                        clearInterval(pullInterval);
                        this.windSingularities = this.windSingularities.filter(s => s !== singularity);
                        return;
                    }

                    const allMobs = [...this.mobs, ...this.bosses];
                    allMobs.forEach(mob => {
                        const dx = singularity.x - mob.x;
                        const dy = singularity.y - mob.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < singularity.radius) {
                            // Pull toward center
                            if (dist > 20) {
                                mob.x += (dx / dist) * singularity.pullStrength;
                                mob.y += (dy / dist) * singularity.pullStrength;
                            }

                            // Stun enemies near center
                            if (dist < 50 && !mob.stunned) {
                                mob.stunned = true;
                                mob.originalSpeed = mob.speed;
                                mob.speed = 0;

                                setTimeout(() => {
                                    if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                        mob.stunned = false;
                                        mob.speed = mob.originalSpeed;
                                    }
                                }, 3000);
                            }
                        }
                    });
                }, 50);

                console.log('? Wind Singularity created! Pulling and stunning enemies!');
            },

            atmosphericPressure() {
                // Presión Atmosférica - Aplasta enemigos, inmoviliza y rompe armadura
                const allMobs = [...this.mobs, ...this.bosses];
                let affectedCount = 0;

                allMobs.forEach(mob => {
                    const dx = mob.x - Player.x;
                    const dy = mob.y - Player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 250) { // Area around player
                        // Immediate damage
                        this.damageMob(mob.id, 40);

                        // Root (immobilize) for 2s
                        mob.rooted = true;
                        mob.originalSpeed = mob.speed;
                        mob.speed = 0;

                        setTimeout(() => {
                            if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                mob.rooted = false;
                                mob.speed = mob.originalSpeed;
                            }
                        }, 2000);

                        // Break armor for 4s
                        mob.armorBroken = true;
                        mob.originalDamageReduction = mob.damageReduction || 0;
                        mob.damageReduction = 0;
                        mob.damageAmplification = 1.2; // +20% damage taken

                        setTimeout(() => {
                            if (this.mobs.includes(mob) || this.bosses.includes(mob)) {
                                mob.armorBroken = false;
                                mob.damageReduction = mob.originalDamageReduction;
                                mob.damageAmplification = 1.0;
                            }
                        }, 4000);

                        affectedCount++;
                    }
                });

                console.log(`?? Atmospheric Pressure - ${affectedCount} enemies crushed! Rooted 2s + Armor broken 4s!`);
            },

            tornadoBarrage() {
                // Ráfaga de Tornados - Lanza 5 tornados en diferentes direcciones
                const allMobs = [...this.mobs, ...this.bosses];
                if (allMobs.length === 0) {
                    console.log('??? No enemies for Tornado Barrage!');
                    return;
                }

                // Launch 5 tornados in spread pattern
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 / 5) * i;

                    this.projectiles.push({
                        x: Player.x,
                        y: Player.y,
                        vx: Math.cos(angle) * 350,
                        vy: Math.sin(angle) * 350,
                        size: 20,
                        damage: 45,
                        color: '#39ff14',
                        life: 4000,
                        isPiercing: true,
                        piercedEnemies: [],
                        isPlayerProjectile: true,
                        onHit: (mob) => {
                            // Apply confusion
                            mob.confused = true;
                            mob.confusedTime = 4000;
                            mob.confusedIntensity = 0.5;
                            return 45;
                        }
                    });
                }

                console.log('??? Tornado Barrage - 5 tornados launched!');
            },

            stormShield() {
                // Escudo de Tormenta - Shield that reflects projectiles and gives damage reduction
                Player.invulnerable = true;
                Player.invulnerableTime = 4000; // 4 seconds

                // Damage reduction buff
                if (!Player.damageReduction) Player.damageReduction = 0;
                Player.damageReduction = 30; // 30% damage reduction

                setTimeout(() => {
                    Player.damageReduction = 0;
                }, 6000); // 6 seconds total

                // Create visual shield effect
                const shieldEffect = {
                    x: Player.x,
                    y: Player.y,
                    radius: 80,
                    duration: 4000,
                    startTime: Date.now()
                };

                if (!this.stormShields) this.stormShields = [];
                this.stormShields.push(shieldEffect);

                console.log('??? Storm Shield activated! 4s invulnerability + 30% damage reduction for 6s!');
            },

            apocalypticStorm() {
                // Tormenta Apocalíptica - Ultimate: Massive storm that devastates everything
                const allMobs = [...this.mobs, ...this.bosses];

                console.log('??? APOCALYPTIC STORM UNLEASHED!');

                // Phase 1: Pull all enemies (2s)
                const pullDuration = 2000;
                const pullStartTime = Date.now();

                const pullInterval = setInterval(() => {
                    if (Date.now() - pullStartTime >= pullDuration) {
                        clearInterval(pullInterval);
                        return;
                    }

                    allMobs.forEach(mob => {
                        if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;

                        const dx = Player.x - mob.x;
                        const dy = Player.y - mob.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist > 50) {
                            mob.x += (dx / dist) * 10;
                            mob.y += (dy / dist) * 10;
                        }
                    });
                }, 16);

                // Phase 2: Massive damage + confusion (2.5s)
                setTimeout(() => {
                    allMobs.forEach(mob => {
                        const dx = mob.x - Player.x;
                        const dy = mob.y - Player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 400) {
                            // Massive damage
                            this.damageMob(mob.id, 120);

                            // Apply confusion
                            mob.confused = true;
                            mob.confusedTime = 10000; // 10 seconds
                            mob.confusedIntensity = 0.7;

                            // Apply radioactive
                            mob.radioactive = true;
                            mob.radioactiveTime = 8000;
                        }
                    });

                    console.log('??? Phase 2: Massive damage + confusion + radioactive!');
                }, 2500);

                // Phase 3: Launch 20 tornados in all directions (3s)
                setTimeout(() => {
                    for (let i = 0; i < 20; i++) {
                        const angle = (Math.PI * 2 / 20) * i;

                        this.projectiles.push({
                            x: Player.x,
                            y: Player.y,
                            vx: Math.cos(angle) * 400,
                            vy: Math.sin(angle) * 400,
                            size: 18,
                            damage: 60,
                            color: '#00ffaa',
                            life: 5000,
                            isPiercing: true,
                            piercedEnemies: [],
                            isPlayerProjectile: true
                        });
                    }

                    console.log('??? Phase 3: 20 tornados launched!');
                }, 3000);

                // Player invulnerability during entire ultimate
                Player.invulnerable = true;
                Player.invulnerableTime = 5000;

                // Massive damage boost
                Player.applyDamageBoost(50, 10000); // +50% damage for 10s
            },

            // GUARDIAN ANCESTRAL ABILITIES (SSS TIER)
            guardianGlyph() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('guardian_glyph');
                const targets = this.getAllTargets();
                let angle = 0;
                if (targets.length > 0) {
                    const nearest = targets.reduce((best, t) => {
                        const d = Math.hypot(t.x - Player.x, t.y - Player.y);
                        return !best || d < best.d ? { t, d } : best;
                    }, null);
                    if (nearest && nearest.t) {
                        angle = Math.atan2(nearest.t.y - Player.y, nearest.t.x - Player.x);
                    }
                }

                const hitX = Player.x + Math.cos(angle) * 140;
                const hitY = Player.y + Math.sin(angle) * 140;
                EffectRenderer.playEffect('guardian_glyph', hitX, hitY);
                this.addAttackIndicator(hitX, hitY, 145, 145, 380, '#b8915f', 'circle');

                setTimeout(() => {
                    this.checkAbilityHit(hitX, hitY, 145, 110, (mob) => {
                        const k = Math.atan2(mob.y - Player.y, mob.x - Player.x);
                        mob.x += Math.cos(k) * 55;
                        mob.y += Math.sin(k) * 55;
                        mob.stunned = true;
                        mob.stunnedTime = Math.max(mob.stunnedTime || 0, 500);
                    });
                    EffectRenderer.playEffect('guardian_shatter', hitX, hitY);
                }, 380);
            },

            guardianHurl() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('guardian_hurl');
                const targets = this.getAllTargets();
                let baseAngle = 0;
                if (targets.length > 0) {
                    const nearest = targets.reduce((best, t) => {
                        const d = Math.hypot(t.x - Player.x, t.y - Player.y);
                        return !best || d < best.d ? { t, d } : best;
                    }, null);
                    if (nearest && nearest.t) {
                        baseAngle = Math.atan2(nearest.t.y - Player.y, nearest.t.x - Player.x);
                    }
                }

                // 3 primary alternating strikes.
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const angle = baseAngle + (i % 2 === 0 ? 0.55 : -0.55);
                        const x = Player.x + Math.cos(angle) * 165;
                        const y = Player.y + Math.sin(angle) * 165;
                        this.addAttackIndicator(x, y, 165, 165, 320, '#c98745', 'circle');
                        setTimeout(() => {
                            this.checkAbilityHit(x, y, 165, 105, (mob) => {
                                mob.stunned = true;
                                mob.stunnedTime = Math.max(mob.stunnedTime || 0, 420);
                            });
                            EffectRenderer.playEffect('guardian_hurl', x, y);
                        }, 320);
                    }, i * 290);
                }

                // 7 adjacent sweeps, two cycles.
                const start = 980;
                for (let cycle = 0; cycle < 2; cycle++) {
                    for (let i = 0; i < 7; i++) {
                        const seq = cycle * 7 + i;
                        setTimeout(() => {
                            const spread = (i - 3) * 0.26 + (cycle * 0.11);
                            const angle = baseAngle + spread;
                            const x = Player.x + Math.cos(angle) * 230;
                            const y = Player.y + Math.sin(angle) * 230;
                            this.addAttackIndicator(x, y, 115, 115, 240, '#9f6f43', 'circle');
                            setTimeout(() => {
                                this.checkAbilityHit(x, y, 115, 74);
                            }, 240);
                        }, start + seq * 135);
                    }
                }
            },

            guardianTablets() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('guardian_tablets');
                const canvas = document.getElementById('game-canvas');
                const width = canvas ? canvas.width : 1280;
                const height = canvas ? canvas.height : 720;
                const centerX = Player.x;
                const centerY = Player.y;

                EffectRenderer.playEffect('guardian_tablets', centerX, centerY);
                this.addAttackIndicator(centerX, centerY, 220, 220, 850, '#d1a868', 'circle');

                for (let i = 0; i < 25; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * 200;
                        const x = Math.max(30, Math.min(width - 30, centerX + Math.cos(angle) * dist));
                        const y = Math.max(30, Math.min(height - 30, centerY + Math.sin(angle) * dist));
                        this.addAttackIndicator(x, y, 68, 68, 460, '#b88e58', 'circle');

                        setTimeout(() => {
                            this.checkAbilityHit(x, y, 68, 42, (mob) => {
                                mob.poisoned = true;
                                mob.poisonDamage = Math.max(mob.poisonDamage || 0, 9);
                                mob.poisonTickInterval = 500;
                                mob.poisonLastTick = Date.now();
                                mob.poisonEndTime = Math.max(mob.poisonEndTime || 0, Date.now() + 4000);
                            });
                        }, 460);
                    }, 600 + i * 80);
                }

                setTimeout(() => {
                    this.addAttackIndicator(Player.x, Player.y, 310, 310, 760, '#7b5430', 'circle');
                    setTimeout(() => {
                        this.checkAbilityHit(Player.x, Player.y, 310, 170);
                        EffectRenderer.playEffect('guardian_shatter', Player.x, Player.y);
                    }, 760);
                }, 2850);
            },

            guardianBurrow() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('guardian_burrow');
                // Pillar Guard: defensive stance + empowered close combat window.
                EffectRenderer.playEffect('guardian_burrow', Player.x, Player.y);
                const duration = 5000;
                const oldReduction = Player.damageReduction || 0;
                const oldSpeed = Player.speed;
                Player.guardianPillarGuard = true;
                Player.guardianPillarGuardEndTime = Date.now() + duration;
                Player.damageReduction = Math.max(oldReduction, 35);
                Player.speed = oldSpeed * 1.15;

                setTimeout(() => {
                    Player.guardianPillarGuard = false;
                    Player.damageReduction = oldReduction;
                    Player.speed = oldSpeed;
                }, duration);
            },

            guardianConstruct() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('guardian_construct');
                // Titan Dive.
                const targets = this.getAllTargets();
                let targetX = Player.x;
                let targetY = Player.y;
                if (targets.length > 0) {
                    const nearest = targets.reduce((best, t) => {
                        const d = Math.hypot(t.x - Player.x, t.y - Player.y);
                        return !best || d < best.d ? { t, d } : best;
                    }, null);
                    if (nearest && nearest.t) {
                        targetX = nearest.t.x;
                        targetY = nearest.t.y;
                    }
                }

                Player.invulnerable = true;
                Player.invulnerableTime = 1200;
                this.addAttackIndicator(targetX, targetY, 285, 285, 950, '#58ff95', 'circle');
                setTimeout(() => {
                    Player.x = targetX;
                    Player.y = targetY;
                    this.checkAbilityHit(targetX, targetY, 285, 230, (mob) => {
                        mob.stunned = true;
                        mob.stunnedTime = Math.max(mob.stunnedTime || 0, 900);
                    });
                    EffectRenderer.playEffect('guardian_construct', targetX, targetY);
                    AbilityManager.screenShake();
                }, 950);
            },

            guardianWorldbreaker() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('guardian_worldbreaker');
                // Pillar Cannon: recursive meteor split ending with 27 impacts.
                const canvas = document.getElementById('game-canvas');
                const width = canvas ? canvas.width : 1280;
                const height = canvas ? canvas.height : 720;
                const baseX = Player.x;
                const baseY = Player.y;
                EffectRenderer.playEffect('guardian_worldbreaker', baseX, baseY);
                AbilityManager.screenShake();

                const initialTargets = [];
                for (let i = 0; i < 3; i++) {
                    const a = (Math.PI * 2 / 3) * i + (Math.random() * 0.4);
                    initialTargets.push({
                        x: Math.max(40, Math.min(width - 40, baseX + Math.cos(a) * 120)),
                        y: Math.max(40, Math.min(height - 40, baseY + Math.sin(a) * 120))
                    });
                }

                const levels = [initialTargets];
                for (let level = 0; level < 2; level++) {
                    const next = [];
                    levels[level].forEach((target) => {
                        for (let i = 0; i < 3; i++) {
                            const a = Math.random() * Math.PI * 2;
                            const d = 65 + Math.random() * 75;
                            next.push({
                                x: Math.max(40, Math.min(width - 40, target.x + Math.cos(a) * d)),
                                y: Math.max(40, Math.min(height - 40, target.y + Math.sin(a) * d))
                            });
                        }
                    });
                    levels.push(next);
                }

                levels.forEach((targets, level) => {
                    targets.forEach((target, idx) => {
                        const delay = level * 700 + idx * 65;
                        setTimeout(() => {
                            const radius = level === 2 ? 95 : 58;
                            this.addAttackIndicator(target.x, target.y, radius, radius, 520, level === 2 ? '#5ce784' : '#7c5e41', 'circle');
                            setTimeout(() => {
                                if (level === 2) {
                                    this.checkAbilityHit(target.x, target.y, 95, 135, (mob) => {
                                        mob.poisoned = true;
                                        mob.poisonDamage = Math.max(mob.poisonDamage || 0, 10);
                                        mob.poisonTickInterval = 500;
                                        mob.poisonLastTick = Date.now();
                                        mob.poisonEndTime = Math.max(mob.poisonEndTime || 0, Date.now() + 4000);
                                    });
                                    EffectRenderer.playEffect('guardian_shatter', target.x, target.y);
                                }
                            }, 520);
                        }, delay);
                    });
                });
            },

            // ANUBIS ABILITIES (SSS TIER)
            anubisApplyStun(mob, durationMs = 1200) {
                if (!mob || mob.unyielding) return;
                const now = Date.now();
                const until = now + durationMs;
                if (typeof mob.preStunSpeed !== 'number') {
                    mob.preStunSpeed = mob.speed;
                }
                mob.stunned = true;
                mob.stunnedTime = Math.max(mob.stunnedTime || 0, durationMs);
                mob.stunUntil = Math.max(mob.stunUntil || 0, until);
                mob.speed = 0;
            },

            anubisApplySlow(mob, multiplier = 0.75, durationMs = 2000, key = 'anubisSlow') {
                if (!mob || mob.unyielding) return;
                const token = Date.now() + Math.random();
                const tokenKey = `${key}Token`;
                const baseKey = `${key}BaseSpeed`;

                if (typeof mob[baseKey] !== 'number') {
                    mob[baseKey] = mob.speed;
                }
                mob[tokenKey] = token;
                mob.speed = Math.max(8, mob[baseKey] * multiplier);

                setTimeout(() => {
                    if (!this.mobs.includes(mob) && !this.bosses.includes(mob)) return;
                    if (mob[tokenKey] !== token) return;
                    if (typeof mob[baseKey] === 'number') {
                        mob.speed = mob[baseKey];
                    }
                    delete mob[tokenKey];
                    delete mob[baseKey];
                }, durationMs);
            },

            anubisApplyDeathMark(mob, durationMs = 7000, multiplier = 1.3) {
                if (!mob || mob.isDummy) return;
                mob.deathMarked = true;
                mob.deathMarkTime = durationMs;
                mob.deathMarkUntil = Date.now() + durationMs;
                mob.deathMarkMultiplier = Math.max(mob.deathMarkMultiplier || 1, multiplier);
            },

            anubisJudgment() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('anubis_judgment');
                console.log('Anubis Judgment activated.');
                AbilityManager.screenShake();
                EffectRenderer.playEffect('anubis_judgment', Player.x, Player.y);

                const nearbyTargets = this.getAllTargets()
                    .map(target => {
                        const dx = target.x - Player.x;
                        const dy = target.y - Player.y;
                        return { target, dist: Math.sqrt(dx * dx + dy * dy) };
                    })
                    .filter(t => t.dist < 520)
                    .sort((a, b) => a.dist - b.dist)
                    .slice(0, 3);

                this.checkAbilityHit(Player.x, Player.y, 185, 60, (mob) => {
                    mob.confused = true;
                    mob.confusedTime = Math.max(mob.confusedTime || 0, 900);
                });

                nearbyTargets.forEach((entry, index) => {
                    setTimeout(() => {
                        const target = entry.target;
                        if (!target) return;
                        EffectRenderer.playEffect('anubis_judgment', target.x, target.y);
                        const hpRatio = Math.max(0, target.hp / Math.max(1, target.maxHp || 1));
                        const missingHp = 1 - hpRatio;
                        let burstDamage = 95 + (missingHp * 70);
                        if (hpRatio < 0.5) burstDamage *= 1.28;
                        this.damageTarget(target, burstDamage);

                        if (!target.isDummy) {
                            this.anubisApplyDeathMark(target, 8000, hpRatio < 0.5 ? 1.45 : 1.24);
                            this.anubisApplySlow(target, 0.72, 1800, 'anubisJudgmentSlow');
                            if (hpRatio <= 0.22) {
                                this.damageTarget(target, (target.hp || 0) + 1);
                            }
                        }
                    }, index * 180);
                });
            },

            anubisSandstorm() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('anubis_sandstorm');
                console.log('Anubis Sandstorm activated.');
                EffectRenderer.playEffect('anubis_sandstorm', Player.x, Player.y);
                const startTime = Date.now();
                const duration = 7000;
                const tickMs = 450;
                Player.applyDamageBoost(12, duration);

                const interval = setInterval(() => {
                    if ((!this.active && !PracticeModeManager.active) || Date.now() - startTime > duration) {
                        clearInterval(interval);
                        return;
                    }

                    const phase = (Date.now() - startTime) / duration;
                    const radius = 230 + (Math.sin(phase * Math.PI) * 70);
                    let hitCount = 0;
                    this.checkAbilityHit(Player.x, Player.y, radius, 18, (mob) => {
                        hitCount++;
                        mob.confused = true;
                        mob.confusedTime = Math.max(mob.confusedTime || 0, 850);
                        this.anubisApplySlow(mob, 0.78, 900, 'anubisSandSlow');
                    });

                    const sustain = 8 + Math.min(10, hitCount * 0.9);
                    Player.hp = Math.min(Player.maxHp, Player.hp + sustain);
                }, tickMs);
            },

            anubisJackal() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('anubis_jackal');
                console.log('Anubis Jackal Form activated.');
                EffectRenderer.playEffect('anubis_jackal', Player.x, Player.y);
                const duration = 8000;
                const endAt = Date.now() + duration;
                if (!Player.anubisJackalBaseSpeed) {
                    Player.anubisJackalBaseSpeed = Player.speed;
                }

                Player.anubisJackalEndsAt = endAt;
                Player.speed = Math.max(Player.speed, Player.anubisJackalBaseSpeed * 1.75);
                Player.isJackal = true;

                if (this.anubisJackalInterval) clearInterval(this.anubisJackalInterval);
                this.anubisJackalInterval = setInterval(() => {
                    if ((!this.active && !PracticeModeManager.active) || Date.now() >= (Player.anubisJackalEndsAt || 0)) {
                        clearInterval(this.anubisJackalInterval);
                        this.anubisJackalInterval = null;
                        Player.speed = Player.anubisJackalBaseSpeed || Player.speed;
                        Player.isJackal = false;
                        delete Player.anubisJackalEndsAt;
                        return;
                    }

                    const targetEntry = this.getAllTargets()
                        .map(target => {
                            const dx = target.x - Player.x;
                            const dy = target.y - Player.y;
                            return { target, dx, dy, dist: Math.sqrt(dx * dx + dy * dy) };
                        })
                        .filter(entry => entry.dist < 340)
                        .sort((a, b) => a.dist - b.dist)[0];

                    if (!targetEntry) return;
                    const { target, dx, dy, dist } = targetEntry;
                    if (dist > 0) {
                        const dash = Math.min(85, dist * 0.45);
                        Player.x += (dx / dist) * dash;
                        Player.y += (dy / dist) * dash;
                        const canvas = document.getElementById('game-canvas');
                        if (canvas) {
                            Player.x = Math.max(35, Math.min(canvas.width - 35, Player.x));
                            Player.y = Math.max(35, Math.min(canvas.height - 35, Player.y));
                        }
                    }

                    this.damageTarget(target, 72);
                    if (!target.isDummy) {
                        target.poisoned = true;
                        target.poisonDamage = Math.max(target.poisonDamage || 0, 9);
                        target.poisonTickInterval = 500;
                        target.poisonTime = Math.max(target.poisonTime || 0, 3600);
                        if ((target.hp / Math.max(1, target.maxHp || 1)) < 0.18 && Math.random() < 0.32) {
                            this.damageTarget(target, (target.hp || 0) + 1);
                        }
                    }
                    Player.hp = Math.min(Player.maxHp, Player.hp + 9);
                }, 460);
            },

            anubisAnkh() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('anubis_ankh');
                console.log('Anubis Ankh of Resurrection activated.');
                EffectRenderer.playEffect('anubis_ankh', Player.x, Player.y);

                const startTime = Date.now();
                const duration = 10000;
                const tickMs = 500;
                const sanctuaryRadius = 220;
                const token = Date.now() + Math.random();
                Player.anubisAnkhToken = token;
                Player.resurrectionAvailable = true;
                Player.applyDamageBoost(28, duration);

                const interval = setInterval(() => {
                    if ((!this.active && !PracticeModeManager.active) || Date.now() - startTime > duration) {
                        clearInterval(interval);
                        if (Player.anubisAnkhToken === token) {
                            Player.resurrectionAvailable = false;
                            delete Player.anubisAnkhToken;
                        }
                        return;
                    }

                    let hitCount = 0;
                    this.checkAbilityHit(Player.x, Player.y, sanctuaryRadius, 22, (mob) => {
                        hitCount++;
                        mob.healingReduction = true;
                        mob.healingReductionTime = Math.max(mob.healingReductionTime || 0, 1800);
                        this.anubisApplySlow(mob, 0.85, 650, 'anubisAnkhSlow');
                    });

                    const healing = 14 + Math.min(10, hitCount);
                    Player.hp = Math.min(Player.maxHp, Player.hp + healing);
                }, tickMs);
            },

            anubisPlague() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('anubis_plague');
                console.log('Anubis Plague of Ten Curses activated.');
                EffectRenderer.playEffect('anubis_plague', Player.x, Player.y);
                Player.invulnerable = true;
                Player.invulnerableTime = Math.max(Player.invulnerableTime || 0, 1800);

                const waves = [
                    { radius: 430, damage: 42, name: 'Blood' },
                    { radius: 460, damage: 34, name: 'Locusts' },
                    { radius: 500, damage: 48, name: 'Darkness' },
                    { radius: 520, damage: 56, name: 'Hailfire' },
                    { radius: 560, damage: 70, name: 'Death Seal' }
                ];

                waves.forEach((wave, i) => {
                    setTimeout(() => {
                        if (!this.active && !PracticeModeManager.active) return;
                        AbilityManager.screenShake();
                        this.checkAbilityHit(Player.x, Player.y, wave.radius, wave.damage, (mob) => {
                            if (mob.isDummy) return;

                            if (i === 0) {
                                mob.poisoned = true;
                                mob.poisonDamage = Math.max(mob.poisonDamage || 0, 10);
                                mob.poisonTickInterval = 500;
                                mob.poisonTime = Math.max(mob.poisonTime || 0, 4200);
                                this.anubisApplyDeathMark(mob, 4500, 1.15);
                            } else if (i === 1) {
                                mob.confused = true;
                                mob.confusedTime = Math.max(mob.confusedTime || 0, 1500);
                                this.anubisApplySlow(mob, 0.68, 1700, 'anubisPlagueLocust');
                            } else if (i === 2) {
                                this.anubisApplyStun(mob, 1200);
                                mob.silenced = true;
                                mob.silencedTime = Math.max(mob.silencedTime || 0, 1800);
                            } else if (i === 3) {
                                this.anubisApplySlow(mob, 0.62, 1800, 'anubisPlagueHail');
                            } else if (i === 4) {
                                this.anubisApplyDeathMark(mob, 7000, 1.42);
                                if ((mob.hp / Math.max(1, mob.maxHp || 1)) < 0.3) {
                                    this.damageMob(mob.id, (mob.hp || 0) + 1);
                                }
                            }
                        });
                    }, i * 1600);
                });
            },

            anubisUnderworld() {
                if (typeof SfxManager !== 'undefined') SfxManager.playAbility('anubis_underworld');
                console.log('Anubis Underworld Portal opened.');
                AbilityManager.screenShake();
                EffectRenderer.playEffect('anubis_underworld', Player.x, Player.y);

                const startTime = Date.now();
                const duration = 12000;
                const pulseMs = 500;
                const pullRadius = 640;

                Player.invulnerable = true;
                Player.invulnerableTime = Math.max(Player.invulnerableTime || 0, 2500);
                Player.applyDamageBoost(20, duration);

                const interval = setInterval(() => {
                    if ((!this.active && !PracticeModeManager.active) || Date.now() - startTime > duration) {
                        clearInterval(interval);
                        return;
                    }

                    const allTargets = this.getAllTargets();
                    allTargets.forEach(target => {
                        const dx = Player.x - target.x;
                        const dy = Player.y - target.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0 && dist < pullRadius && dist > 70 && !target.unyielding) {
                            target.x += (dx / dist) * 16;
                            target.y += (dy / dist) * 16;
                        }
                    });

                    this.checkAbilityHit(Player.x, Player.y, pullRadius, 28, (mob) => {
                        if (mob.isDummy) return;
                        if (Math.random() < 0.25) this.anubisApplyStun(mob, 800);
                        if (Math.random() < 0.4) {
                            mob.silenced = true;
                            mob.silencedTime = Math.max(mob.silencedTime || 0, 1400);
                        }
                    });
                }, pulseMs);

                for (let i = 0; i < 4; i++) {
                    setTimeout(() => {
                        if (!this.active && !PracticeModeManager.active) return;
                        AbilityManager.screenShake();
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 140 + Math.random() * 320;
                        const strikeX = Player.x + Math.cos(angle) * distance;
                        const strikeY = Player.y + Math.sin(angle) * distance;
                        EffectRenderer.playEffect('anubis_judgment', strikeX, strikeY);
                        this.checkAbilityHit(strikeX, strikeY, 170, 160, (mob) => {
                            this.anubisApplyDeathMark(mob, 5500, 1.28);
                        });
                    }, 2200 + (i * 2200));
                }

                setTimeout(() => {
                    if (!this.active && !PracticeModeManager.active) return;
                    AbilityManager.screenShake();
                    EffectRenderer.playEffect('anubis_underworld', Player.x, Player.y);
                    const scoreBefore = this.score;
                    this.checkAbilityHit(Player.x, Player.y, 710, 260, (mob) => {
                        this.anubisApplyDeathMark(mob, 6500, 1.36);
                    });
                    const scoreDelta = Math.max(0, this.score - scoreBefore);
                    const soulCount = Math.floor(scoreDelta / 10);
                    if (soulCount > 0) {
                        const healAmount = Player.maxHp * Math.min(0.28, soulCount * 0.04);
                        Player.hp = Math.min(Player.maxHp, Player.hp + healAmount);
                    }
                }, duration);
            },

            dropClassTicket(mob, isBoss) {
                // Check if mob drops specific class ticket
                if (!mob.dropsTicketFor) return;

                // If a raid has a specific objective target, only that target can progress
                if (this.selectedDropTarget && mob.dropsTicketFor !== this.selectedDropTarget) {
                    return;
                }

                let dropChance = 0;

                // Bosses have higher drop rates
                if (isBoss) {
                    dropChance = 0.65; // 65% for bosses (increased from 35%)
                } else {
                    dropChance = 0.35; // 35% for regular mobs (increased from 15%)
                }

                // Apply custom raid penalty (reduced from 10% to 5%)
                if (this.isCustomRaid) {
                    dropChance -= 0.05; // Only 5% penalty now
                    dropChance = Math.max(0, dropChance); // Don't go below 0
                }

                if (Math.random() < dropChance) {
                    const classId = mob.dropsTicketFor;

                    // Initialize if doesn't exist
                    if (!EquipmentManager.classTickets[classId]) {
                        EquipmentManager.classTickets[classId] = 0;
                    }

                    EquipmentManager.classTickets[classId]++;

                    // Update total counter
                    const totalTickets = Object.values(EquipmentManager.classTickets).reduce((a, b) => a + b, 0);
                    document.getElementById('ticket-counter').textContent = totalTickets;

                    EquipmentManager.saveProgress();
                    this.showTicketDrop(mob.x, mob.y, classId);
                    console.log(`?? ${classId} Ticket dropped! Total:`, EquipmentManager.classTickets[classId]);
                }
            },

            resolveRewardDisplayName(rewardId) {
                if (!rewardId) return 'Unknown';
                const role = [...(rolesData.classes || []), ...(rolesData.characters || []), ...(rolesData.fruits || [])]
                    .find(r => r.id === rewardId);
                if (role?.name) return role.name;
                return String(rewardId)
                    .replace(/^class_/, '')
                    .replace(/[-_]+/g, ' ')
                    .replace(/\b\w/g, c => c.toUpperCase());
            },

            showTicketDrop(x, y, classId) {
                const className = this.resolveRewardDisplayName(classId);

                // Add to canvas notifications for fullscreen
                this.canvasNotifications = this.canvasNotifications || [];
                this.canvasNotifications.push({
                    text: `+1 ${className} Ticket`,
                    x: x,
                    y: y,
                    startTime: Date.now(),
                    duration: 2000,
                    color: '#ffd700'
                });

                // Also show DOM popup for non-fullscreen
                const popup = document.createElement('div');
                popup.style.cssText = `
                    position: fixed;
                    left: ${x}px;
                    top: ${y}px;
                    color: #ffd700;
                    font-size: 24px;
                    font-weight: bold;
                    z-index: 9999;
                    pointer-events: none;
                    animation: floatUp 2s ease-out forwards;
                    text-shadow: 0 0 10px #ffd700, 0 0 20px #ffd700;
                `;
                popup.textContent = `+1 ${className} Ticket`;
                document.body.appendChild(popup);

                setTimeout(() => popup.remove(), 2000);

                // Check if any class can be unlocked now
                this.checkUnlockableClasses();
            },

            checkUnlockableClasses() {
                const unlockable = this.getUnlockableRoles();
                if (unlockable.length === 0) return;
                this.showUnlockReadyBatch(unlockable);
            }
        };

        // ===== PRACTICE MODE / PLAYGROUND =====
        const PracticeModeManager = {
            active: false,
            savedGameState: null,
            settings: {
                infiniteResources: true,
                enhancedEffects: false,
                dummyImmortal: true,
                dummyHealth: 10000,
                dummyDefense: 0
            },
            controlPanel: {
                collapsed: false,
                x: 20,
                y: 20,
                width: 280,
                headerHeight: 50,
                contentHeight: 400
            },

            // Save current game state before entering practice mode
            saveGameState() {
                this.savedGameState = {
                    playerHp: Player.hp,
                    playerMaxHp: Player.maxHp,
                    playerLevel: Player.level,
                    playerExp: Player.exp,
                    playerX: Player.x,
                    playerY: Player.y,
                    equippedRole: EquipmentManager.equippedRole ? {
                        id: EquipmentManager.equippedRole.id,
                        type: EquipmentManager.equippedRole.type
                    } : null,
                    raidActive: MobRaidSystem.active
                };
                console.log('?? Game state saved for practice mode');
            },

            // Restore game state when exiting practice mode
            restoreGameState() {
                if (!this.savedGameState) return;

                Player.hp = this.savedGameState.playerHp;
                Player.maxHp = this.savedGameState.playerMaxHp;
                Player.level = this.savedGameState.playerLevel;
                Player.exp = this.savedGameState.playerExp;
                Player.x = this.savedGameState.playerX;
                Player.y = this.savedGameState.playerY;

                // Restore equipped role if it was different
                if (this.savedGameState.equippedRole) {
                    const allRoles = [...rolesData.characters, ...rolesData.classes, ...rolesData.masterClasses];
                    const role = allRoles.find(r => r.id === this.savedGameState.equippedRole.id);
                    if (role && EquipmentManager.equippedRole?.id !== role.id) {
                        EquipmentManager.equipRole(role);
                    }
                }

                console.log('?? Game state restored');
                this.savedGameState = null;
            },

            // Enter practice mode
            enterPracticeMode() {
                if (MobRaidSystem.active) {
                    console.log('?? Stopping active raid before entering practice mode');
                    MobRaidSystem.stopRaid(false);
                }

                // Ensure raid is not paused
                MobRaidSystem.paused = false;

                // Enter fullscreen
                const canvas = document.getElementById('game-canvas');
                if (canvas.requestFullscreen) {
                    canvas.requestFullscreen().catch(err => {
                        console.log('Fullscreen request failed:', err);
                    });
                } else if (canvas.webkitRequestFullscreen) {
                    canvas.webkitRequestFullscreen();
                } else if (canvas.msRequestFullscreen) {
                    canvas.msRequestFullscreen();
                }

                // Save current state
                this.saveGameState();

                // Activate practice mode
                this.active = true;

                console.log('?? Practice Mode: Movement should be enabled. MobRaidSystem.paused:', MobRaidSystem.paused);

                // Reset player to full health
                Player.hp = Player.maxHp;

                // Reset all cooldowns
                if (EquipmentManager.equippedRole) {
                    const role = EquipmentManager.equippedRole;
                    if (role.abilities) {
                        role.abilities.forEach(ability => ability.currentCooldown = 0);
                    }
                    if (role.semiUltimate) role.semiUltimate.currentCooldown = 0;
                    if (role.ultimateAbility) role.ultimateAbility.currentCooldown = 0;
                }

                // Initialize subsystems
                TrainingDummySystem.init();
                ComboTracker.init();

                // Show practice UI
                this.showPracticeUI();

                // Spawn initial dummy after a short delay to ensure Player is ready
                setTimeout(() => {
                    console.log('?? Attempting to spawn initial dummy. Player:', Player);
                    console.log('?? Player position:', Player.x, Player.y);

                    if (Player && Player.x !== undefined && Player.y !== undefined) {
                        const dummyX = Player.x + 200;
                        const dummyY = Player.y;
                        console.log('?? Spawning dummy at:', dummyX, dummyY);

                        TrainingDummySystem.spawnDummy(
                            dummyX,
                            dummyY,
                            {
                                hp: this.settings.dummyHealth,
                                defense: this.settings.dummyDefense,
                                immortal: this.settings.dummyImmortal
                            }
                        );
                        console.log('? Initial dummy spawned successfully');
                        console.log('?? Current dummies:', TrainingDummySystem.dummies);
                    } else {
                        console.error('? Player not ready for dummy spawn. Player:', Player);
                    }
                }, 200);

                console.log('?? Practice Mode activated!');
            },

            // Exit practice mode
            exitPracticeMode() {
                this.active = false;

                // Hide UI
                this.hidePracticeUI();

                // Clear subsystems
                TrainingDummySystem.clear();
                ComboTracker.reset();

                // Restore game state
                this.restoreGameState();

                console.log('?? Practice Mode deactivated');
            },

            // Toggle infinite resources
            toggleInfiniteResources() {
                this.settings.infiniteResources = !this.settings.infiniteResources;
                console.log(`?? Infinite Resources: ${this.settings.infiniteResources ? 'ON' : 'OFF'}`);
                this.savePracticeSettings();
            },

            // Toggle enhanced effects
            toggleEnhancedEffects() {
                this.settings.enhancedEffects = !this.settings.enhancedEffects;
                console.log(`? Enhanced Effects: ${this.settings.enhancedEffects ? 'ON' : 'OFF'}`);
                this.savePracticeSettings();
            },

            // Reset practice session
            resetPracticeSession() {
                // Reset player stats
                Player.hp = Player.maxHp;

                // Reset all cooldowns
                if (EquipmentManager.equippedRole) {
                    const role = EquipmentManager.equippedRole;
                    if (role.abilities) {
                        role.abilities.forEach(ability => ability.currentCooldown = 0);
                    }
                    if (role.semiUltimate) role.semiUltimate.currentCooldown = 0;
                    if (role.ultimateAbility) role.ultimateAbility.currentCooldown = 0;
                }

                // Reset dummies
                TrainingDummySystem.resetAllDummies();

                // Reset combo tracker
                ComboTracker.reset();

                // Show visual confirmation
                this.showResetConfirmation();

                console.log('?? Practice session reset');
            },

            showResetConfirmation() {
                const flash = document.createElement('div');
                flash.style.cssText = `
                    position: fixed;
                    inset: 0;
                    background: rgba(0, 255, 0, 0.3);
                    z-index: 9999;
                    pointer-events: none;
                    animation: fadeOut 0.3s ease-out forwards;
                `;
                document.body.appendChild(flash);
                setTimeout(() => flash.remove(), 300);
            },

            // Save practice settings to localStorage
            savePracticeSettings() {
                try {
                    localStorage.setItem('wildDestinyPracticeSettings', JSON.stringify(this.settings));
                } catch (e) {
                    console.error('Failed to save practice settings:', e);
                }
            },

            // Load practice settings from localStorage
            loadPracticeSettings() {
                try {
                    const saved = localStorage.getItem('wildDestinyPracticeSettings');
                    if (saved) {
                        this.settings = { ...this.settings, ...JSON.parse(saved) };
                        console.log('?? Practice settings loaded');
                    }
                } catch (e) {
                    console.error('Failed to load practice settings:', e);
                }
            },

            update(deltaTime) {
                if (!this.active) return;

                // Update subsystems
                TrainingDummySystem.update(deltaTime);
                ComboTracker.update(deltaTime);

                // Apply infinite resources
                if (this.settings.infiniteResources) {
                    // Keep player at full health (god mode)
                    if (Player.hp < Player.maxHp) {
                        Player.hp = Player.maxHp;
                    }

                    // Reset cooldowns
                    if (EquipmentManager.equippedRole) {
                        const role = EquipmentManager.equippedRole;
                        if (role.abilities) {
                            role.abilities.forEach(ability => {
                                if (ability.currentCooldown > 0) {
                                    ability.currentCooldown = 0;
                                }
                            });
                        }
                        if (role.semiUltimate && role.semiUltimate.currentCooldown > 0) {
                            role.semiUltimate.currentCooldown = 0;
                        }
                        if (role.ultimateAbility && role.ultimateAbility.currentCooldown > 0) {
                            role.ultimateAbility.currentCooldown = 0;
                        }
                    }
                }
            },

            render(ctx) {
                if (!this.active) return;

                // Render practice arena background
                this.renderArena(ctx);

                // Render subsystems
                TrainingDummySystem.render(ctx);
                ComboTracker.render(ctx);

                // Render practice mode indicator
                this.renderModeIndicator(ctx);

                // Render control panel
                this.renderControlPanel(ctx);

                // Render ability cooldowns (same as in raids)
                MobRaidSystem.renderAbilityCooldowns(ctx);
            },

            renderArena(ctx) {
                const canvas = ctx.canvas;

                // Draw grid lines
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;

                // Vertical lines
                for (let x = 0; x < canvas.width; x += 100) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }

                // Horizontal lines
                for (let y = 0; y < canvas.height; y += 100) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }

                // Draw distance markers from player
                const distances = [200, 400, 600, 800]; // 5m, 10m, 15m, 20m intervals
                ctx.strokeStyle = 'rgba(0, 217, 255, 0.3)';
                ctx.lineWidth = 2;

                distances.forEach((dist, index) => {
                    ctx.beginPath();
                    ctx.arc(Player.x, Player.y, dist, 0, Math.PI * 2);
                    ctx.stroke();

                    // Distance label
                    ctx.fillStyle = 'rgba(0, 217, 255, 0.6)';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${(index + 1) * 5}m`, Player.x, Player.y - dist - 5);
                });

                ctx.restore();
            },

            renderModeIndicator(ctx) {
                // Removed - now part of control panel
            },

            renderControlPanel(ctx) {
                const panel = this.controlPanel;
                const canvas = ctx.canvas;

                ctx.save();

                // Panel background
                const totalHeight = panel.collapsed ? panel.headerHeight : panel.headerHeight + panel.contentHeight;
                ctx.fillStyle = 'rgba(138, 43, 226, 0.95)';
                ctx.strokeStyle = '#8a2be2';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(138, 43, 226, 0.5)';
                ctx.beginPath();
                ctx.roundRect(panel.x, panel.y, panel.width, totalHeight, 15);
                ctx.fill();
                ctx.stroke();

                // Header
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.roundRect(panel.x, panel.y, panel.width, panel.headerHeight, [15, 15, 0, 0]);
                ctx.fill();

                // Title
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Orbitron';
                ctx.textAlign = 'left';
                ctx.fillText('?? CONTROLES', panel.x + 15, panel.y + 25);

                // Subtitle
                ctx.font = '10px Arial';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillText('Presiona P para colapsar', panel.x + 15, panel.y + 40);

                // Collapse indicator
                ctx.font = '20px Arial';
                ctx.fillStyle = '#00d9ff';
                ctx.textAlign = 'right';
                ctx.fillText(panel.collapsed ? '?' : '?', panel.x + panel.width - 15, panel.y + 30);

                // Content (if not collapsed)
                if (!panel.collapsed) {
                    let yPos = panel.y + panel.headerHeight + 20;

                    // Settings section
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.roundRect(panel.x + 15, yPos, panel.width - 30, 80, 10);
                    ctx.fill();

                    ctx.fillStyle = '#00d9ff';
                    ctx.font = 'bold 11px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('?? CONFIGURACIÓN', panel.x + 25, yPos + 18);

                    // Infinite Resources toggle
                    yPos += 35;
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px Arial';
                    ctx.fillText('Recursos Infinitos', panel.x + 25, yPos);
                    this.renderToggle(ctx, panel.x + panel.width - 70, yPos - 12, this.settings.infiniteResources);

                    // Enhanced Effects toggle
                    yPos += 25;
                    ctx.fillText('Efectos Mejorados', panel.x + 25, yPos);
                    this.renderToggle(ctx, panel.x + panel.width - 70, yPos - 12, this.settings.enhancedEffects);

                    // Dummy section
                    yPos += 40;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.roundRect(panel.x + 15, yPos, panel.width - 30, 140, 10);
                    ctx.fill();

                    ctx.fillStyle = '#00d9ff';
                    ctx.font = 'bold 11px Arial';
                    ctx.fillText('?? TRAINING DUMMY', panel.x + 25, yPos + 18);

                    // Dummy HP
                    yPos += 35;
                    ctx.fillStyle = '#fff';
                    ctx.font = '11px Arial';
                    ctx.fillText('HP:', panel.x + 25, yPos);
                    ctx.fillStyle = '#ffbe0b';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(this.settings.dummyHealth.toLocaleString(), panel.x + panel.width - 25, yPos);

                    // Dummy Defense
                    yPos += 20;
                    ctx.fillStyle = '#fff';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('Defensa:', panel.x + 25, yPos);
                    ctx.fillStyle = '#ffbe0b';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(this.settings.dummyDefense.toString(), panel.x + panel.width - 25, yPos);

                    // Immortal toggle
                    yPos += 25;
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('Inmortal', panel.x + 25, yPos);
                    this.renderToggle(ctx, panel.x + panel.width - 70, yPos - 12, this.settings.dummyImmortal);

                    // Add Dummy button
                    yPos += 30;
                    this.renderButton(ctx, panel.x + 15, yPos, panel.width - 30, 35, '? Agregar Dummy', '#00d9ff');

                    // Action buttons
                    yPos += 45;
                    this.renderButton(ctx, panel.x + 15, yPos, panel.width - 30, 30, '?? Reset', '#ffbe0b');

                    yPos += 38;
                    this.renderButton(ctx, panel.x + 15, yPos, panel.width - 30, 30, '? Salir', '#ff006e');
                }

                ctx.restore();
            },

            renderToggle(ctx, x, y, isOn) {
                // Toggle background
                ctx.fillStyle = isOn ? '#00d9ff' : '#666';
                ctx.beginPath();
                ctx.roundRect(x, y, 45, 22, 11);
                ctx.fill();

                // Toggle circle
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x + (isOn ? 33 : 12), y + 11, 8, 0, Math.PI * 2);
                ctx.fill();
            },

            renderButton(ctx, x, y, width, height, text, color) {
                // Button background
                ctx.fillStyle = color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.beginPath();
                ctx.roundRect(x, y, width, height, 8);
                ctx.fill();

                // Button text
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(text, x + width / 2, y + height / 2 + 4);
            },

            handleCanvasClick(x, y) {
                const panel = this.controlPanel;

                // Check if click is within panel bounds
                if (x < panel.x || x > panel.x + panel.width) return;
                if (y < panel.y) return;

                const totalHeight = panel.collapsed ? panel.headerHeight : panel.headerHeight + panel.contentHeight;
                if (y > panel.y + totalHeight) return;

                // Header click - toggle collapse
                if (y < panel.y + panel.headerHeight) {
                    panel.collapsed = !panel.collapsed;
                    return;
                }

                if (panel.collapsed) return;

                // Calculate relative Y position
                let relY = y - (panel.y + panel.headerHeight + 20);

                // Infinite Resources toggle (around y: 35)
                if (relY >= 15 && relY <= 50 && x > panel.x + panel.width - 70) {
                    this.settings.infiniteResources = !this.settings.infiniteResources;
                    this.savePracticeSettings();
                    return;
                }

                // Enhanced Effects toggle (around y: 60)
                if (relY >= 40 && relY <= 75 && x > panel.x + panel.width - 70) {
                    this.settings.enhancedEffects = !this.settings.enhancedEffects;
                    this.savePracticeSettings();
                    return;
                }

                // Immortal toggle (around y: 195)
                if (relY >= 180 && relY <= 215 && x > panel.x + panel.width - 70) {
                    this.settings.dummyImmortal = !this.settings.dummyImmortal;
                    this.savePracticeSettings();
                    return;
                }

                // Add Dummy button (around y: 225)
                if (relY >= 220 && relY <= 260) {
                    TrainingDummySystem.spawnDummy(
                        Player.x + (Math.random() - 0.5) * 400,
                        Player.y + (Math.random() - 0.5) * 400,
                        {
                            hp: this.settings.dummyHealth,
                            defense: this.settings.dummyDefense,
                            immortal: this.settings.dummyImmortal
                        }
                    );
                    return;
                }

                // Reset button (around y: 270)
                if (relY >= 265 && relY <= 300) {
                    this.resetPracticeSession();
                    return;
                }

                // Exit button (around y: 310)
                if (relY >= 303 && relY <= 338) {
                    this.exitPracticeMode();
                    return;
                }
            },

            showPracticeUI() {
                // UI is now rendered directly on canvas - no HTML elements needed
                console.log('?? Practice UI initialized (canvas-based)');
                return;

                /* OLD HTML-BASED UI - DISABLED
                const ui = document.createElement('div');
                ui.id = 'practice-mode-ui';
                ui.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 20px;
                    background: linear-gradient(135deg, rgba(138, 43, 226, 0.95), rgba(75, 0, 130, 0.95));
                    backdrop-filter: blur(15px);
                    border: 3px solid #8a2be2;
                    border-radius: 15px;
                    z-index: 99999;
                    box-shadow: 0 10px 40px rgba(138, 43, 226, 0.5);
                    min-width: 280px;
                    max-width: 320px;
                    pointer-events: auto;
                `;
                
                ui.innerHTML = `
                    <div id="practice-header" style="padding: 15px 20px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid rgba(255, 255, 255, 0.1);">
                        <div>
                            <h3 style="color: #fff; font-size: 18px; font-weight: 900; margin: 0; font-family: 'Orbitron', sans-serif;">?? CONTROLES</h3>
                            <p style="color: rgba(255, 255, 255, 0.7); font-size: 10px; margin: 2px 0 0 0;">Click para expandir/colapsar</p>
                        </div>
                        <div id="practice-toggle-icon" style="color: #00d9ff; font-size: 24px; transition: transform 0.3s;">?</div>
                    </div>
                    
                    <div id="practice-content" style="max-height: 70vh; overflow-y: auto; padding: 20px;">
                    
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 12px; margin-bottom: 12px;">
                        <div style="color: #00d9ff; font-size: 12px; font-weight: 700; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">?? Configuraciín</div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="color: #fff; font-size: 13px; font-weight: 600;">Recursos Infinitos</span>
                            <label style="position: relative; display: inline-block; width: 50px; height: 24px;">
                                <input type="checkbox" id="practice-infinite-resources" checked style="opacity: 0; width: 0; height: 0;">
                                <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #00d9ff; transition: .4s; border-radius: 24px;"></span>
                            </label>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: #fff; font-size: 13px; font-weight: 600;">Efectos Mejorados</span>
                            <label style="position: relative; display: inline-block; width: 50px; height: 24px;">
                                <input type="checkbox" id="practice-enhanced-effects" style="opacity: 0; width: 0; height: 0;">
                                <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px;"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 12px; margin-bottom: 12px;">
                        <div style="color: #00d9ff; font-size: 12px; font-weight: 700; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">?? Training Dummy</div>
                        <div style="margin-bottom: 8px;">
                            <label style="color: #fff; font-size: 12px; display: block; margin-bottom: 4px;">HP:</label>
                            <input type="number" id="practice-dummy-hp" value="10000" min="1000" max="1000000" step="1000" style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.5); border: 2px solid rgba(0, 217, 255, 0.3); border-radius: 6px; color: #fff; font-size: 13px;">
                        </div>
                        <div style="margin-bottom: 8px;">
                            <label style="color: #fff; font-size: 12px; display: block; margin-bottom: 4px;">Defensa:</label>
                            <input type="number" id="practice-dummy-defense" value="0" min="0" max="1000" step="10" style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.5); border: 2px solid rgba(0, 217, 255, 0.3); border-radius: 6px; color: #fff; font-size: 13px;">
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <span style="color: #fff; font-size: 13px; font-weight: 600;">Inmortal</span>
                            <label style="position: relative; display: inline-block; width: 50px; height: 24px;">
                                <input type="checkbox" id="practice-dummy-immortal" checked style="opacity: 0; width: 0; height: 0;">
                                <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #00d9ff; transition: .4s; border-radius: 24px;"></span>
                            </label>
                        </div>
                        <button id="practice-spawn-dummy" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #00d9ff, #0099cc); border: none; border-radius: 8px; color: #fff; font-weight: 700; cursor: pointer; font-size: 13px; transition: all 0.3s;">
                            ? Agregar Dummy
                        </button>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <button id="practice-reset" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #ffbe0b, #ff8c00); border: none; border-radius: 8px; color: #fff; font-weight: 700; cursor: pointer; margin-bottom: 8px; font-size: 13px; transition: all 0.3s;">
                            ?? Reset
                        </button>
                        <button id="practice-exit" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #ff006e, #cc0055); border: none; border-radius: 8px; color: #fff; font-weight: 700; cursor: pointer; font-size: 13px; transition: all 0.3s;">
                            ? Salir
                        </button>
                    </div>
                </div>
                `;
                
                document.body.appendChild(ui);
                
                // Toggle collapse functionality
                let isCollapsed = false;
                const header = document.getElementById('practice-header');
                const content = document.getElementById('practice-content');
                const toggleIcon = document.getElementById('practice-toggle-icon');
                
                header.addEventListener('click', () => {
                    isCollapsed = !isCollapsed;
                    if (isCollapsed) {
                        content.style.display = 'none';
                        toggleIcon.style.transform = 'rotate(-90deg)';
                        toggleIcon.textContent = '?';
                    } else {
                        content.style.display = 'block';
                        toggleIcon.style.transform = 'rotate(0deg)';
                        toggleIcon.textContent = '?';
                    }
                });
                
                // Event listeners
                document.getElementById('practice-infinite-resources').addEventListener('change', (e) => {
                    this.toggleInfiniteResources();
                    e.target.nextElementSibling.style.backgroundColor = this.settings.infiniteResources ? '#00d9ff' : '#ccc';
                });
                
                document.getElementById('practice-enhanced-effects').addEventListener('change', (e) => {
                    this.toggleEnhancedEffects();
                    e.target.nextElementSibling.style.backgroundColor = this.settings.enhancedEffects ? '#00d9ff' : '#ccc';
                });
                
                document.getElementById('practice-dummy-hp').addEventListener('change', (e) => {
                    this.settings.dummyHealth = parseInt(e.target.value);
                    this.savePracticeSettings();
                });
                
                document.getElementById('practice-dummy-defense').addEventListener('change', (e) => {
                    this.settings.dummyDefense = parseInt(e.target.value);
                    this.savePracticeSettings();
                });
                
                document.getElementById('practice-dummy-immortal').addEventListener('change', (e) => {
                    this.settings.dummyImmortal = e.target.checked;
                    e.target.nextElementSibling.style.backgroundColor = e.target.checked ? '#00d9ff' : '#ccc';
                    this.savePracticeSettings();
                });
                
                document.getElementById('practice-spawn-dummy').addEventListener('click', () => {
                    TrainingDummySystem.spawnDummy(
                        Player.x + (Math.random() - 0.5) * 400,
                        Player.y + (Math.random() - 0.5) * 400,
                        {
                            hp: this.settings.dummyHealth,
                            defense: this.settings.dummyDefense,
                            immortal: this.settings.dummyImmortal
                        }
                    );
                });
                
                document.getElementById('practice-reset').addEventListener('click', () => this.resetPracticeSession());
                document.getElementById('practice-exit').addEventListener('click', () => this.exitPracticeMode());
                
                // Hover effects
                const buttons = ui.querySelectorAll('button');
                buttons.forEach(btn => {
                    btn.addEventListener('mouseenter', () => {
                        btn.style.transform = 'translateY(-2px)';
                        btn.style.boxShadow = '0 5px 15px rgba(0, 0, 0, 0.3)';
                    });
                    btn.addEventListener('mouseleave', () => {
                        btn.style.transform = '';
                        btn.style.boxShadow = '';
                    });
                });
                END OF OLD HTML-BASED UI */
            },

            hidePracticeUI() {
                const ui = document.getElementById('practice-mode-ui');
                if (ui) ui.remove();
            },

            // Helper method to apply damage to dummies in practice mode
            applyDamageToDummies(x, y, range, damage) {
                if (!this.active) return 0;

                let hitCount = 0;
                TrainingDummySystem.dummies.forEach(dummy => {
                    const dx = dummy.x - x;
                    const dy = dummy.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= range + dummy.size) {
                        TrainingDummySystem.damageDummy(dummy.id, damage);
                        hitCount++;
                    }
                });

                return hitCount;
            }
        };

        // ===== TRAINING DUMMY SYSTEM =====
        const TrainingDummySystem = {
            dummies: [],
            maxDummies: 5,
            nextId: 1,

            init() {
                this.dummies = [];
                this.nextId = 1;
            },

            spawnDummy(x, y, config) {
                if (this.dummies.length >= this.maxDummies) {
                    console.log('?? Máximo de 5 dummies alcanzado');
                    // Show warning message
                    const warning = document.createElement('div');
                    warning.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(255, 0, 0, 0.9);
                        color: white;
                        padding: 20px 40px;
                        border-radius: 10px;
                        font-size: 18px;
                        font-weight: 700;
                        z-index: 9999;
                        animation: fadeOut 2s ease-out forwards;
                    `;
                    warning.textContent = '?? Máximo de 5 dummies alcanzado';
                    document.body.appendChild(warning);
                    setTimeout(() => warning.remove(), 2000);
                    return null;
                }

                const dummy = {
                    id: this.nextId++,
                    x: x,
                    y: y,
                    hp: config.hp || 10000,
                    maxHp: config.hp || 10000,
                    defense: config.defense || 0,
                    immortal: config.immortal !== undefined ? config.immortal : true,
                    damageReceived: 0,
                    lastHitTime: 0,
                    regenerating: false,
                    regenTimer: 0,
                    size: 40,
                    color: '#ff9900'
                };

                this.dummies.push(dummy);
                console.log(`?? Dummy #${dummy.id} spawned`);
                return dummy;
            },

            removeDummy(dummyId) {
                const index = this.dummies.findIndex(d => d.id === dummyId);
                if (index !== -1) {
                    this.dummies.splice(index, 1);
                    console.log(`??? Dummy #${dummyId} removed`);
                }
            },

            damageDummy(dummyId, damage) {
                const dummy = this.dummies.find(d => d.id === dummyId);
                if (!dummy) return;

                // Apply defense
                const actualDamage = Math.max(1, damage - dummy.defense);
                dummy.hp = Math.max(0, dummy.hp - actualDamage);
                dummy.damageReceived += actualDamage;
                dummy.lastHitTime = Date.now();

                // Register damage with combo tracker
                if (ComboTracker.active) {
                    ComboTracker.registerDamage(actualDamage);
                }

                // Check for death and regeneration
                if (dummy.hp <= 0 && dummy.immortal) {
                    dummy.regenerating = true;
                    dummy.regenTimer = 1000; // 1 second
                }

                console.log(`?? Dummy #${dummyId} took ${actualDamage} damage (HP: ${dummy.hp}/${dummy.maxHp})`);
            },

            updateDummyConfig(dummyId, config) {
                const dummy = this.dummies.find(d => d.id === dummyId);
                if (!dummy) return;

                if (config.hp !== undefined) {
                    dummy.maxHp = config.hp;
                    dummy.hp = Math.min(dummy.hp, dummy.maxHp);
                }
                if (config.defense !== undefined) dummy.defense = config.defense;
                if (config.immortal !== undefined) dummy.immortal = config.immortal;
            },

            resetAllDummies() {
                this.dummies.forEach(dummy => {
                    dummy.hp = dummy.maxHp;
                    dummy.damageReceived = 0;
                    dummy.regenerating = false;
                    dummy.regenTimer = 0;
                });
                console.log('?? All dummies reset');
            },

            clear() {
                this.dummies = [];
                this.nextId = 1;
            },

            update(deltaTime) {
                this.dummies.forEach(dummy => {
                    if (dummy.regenerating) {
                        dummy.regenTimer -= deltaTime;
                        if (dummy.regenTimer <= 0) {
                            dummy.hp = dummy.maxHp;
                            dummy.regenerating = false;
                            console.log(`?? Dummy #${dummy.id} regenerated`);
                        }
                    }
                });
            },

            render(ctx) {
                this.dummies.forEach(dummy => {
                    ctx.save();

                    // Regenerating effect
                    if (dummy.regenerating) {
                        const pulse = 1 + Math.sin(Date.now() * 0.01) * 0.3;
                        ctx.globalAlpha = 0.5 + pulse * 0.3;
                    }

                    // Dummy body
                    ctx.fillStyle = dummy.color;
                    ctx.shadowColor = dummy.color;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(dummy.x, dummy.y, dummy.size, 0, Math.PI * 2);
                    ctx.fill();

                    // Border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Icon
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#fff';
                    ctx.font = '30px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('??', dummy.x, dummy.y);

                    // HP bar
                    const barWidth = 100;
                    const barHeight = 10;
                    const hpPercent = dummy.hp / dummy.maxHp;

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(dummy.x - barWidth / 2, dummy.y - dummy.size - 20, barWidth, barHeight);

                    ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
                    ctx.fillRect(dummy.x - barWidth / 2, dummy.y - dummy.size - 20, barWidth * hpPercent, barHeight);

                    // Stats text
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Arial';
                    ctx.shadowBlur = 3;
                    ctx.shadowColor = '#000';
                    ctx.fillText(`HP: ${Math.ceil(dummy.hp)}/${dummy.maxHp}`, dummy.x, dummy.y - dummy.size - 30);

                    ctx.font = '10px Arial';
                    ctx.fillText(`DEF: ${dummy.defense}`, dummy.x - 30, dummy.y - dummy.size - 42);
                    if (dummy.immortal) {
                        ctx.fillStyle = '#ffbe0b';
                        ctx.fillText('?? Inmortal', dummy.x + 30, dummy.y - dummy.size - 42);
                    }

                    // Regenerating indicator
                    if (dummy.regenerating) {
                        ctx.fillStyle = '#00ff00';
                        ctx.font = 'bold 14px Arial';
                        ctx.fillText('?? Regenerando...', dummy.x, dummy.y + dummy.size + 20);
                    }

                    ctx.restore();
                });
            }
        };

        // ===== COMBO TRACKER =====
        const ComboTracker = {
            active: false,
            currentCombo: 0,
            comboTimer: 0,
            comboTimeout: 3000,
            totalDamage: 0,
            comboStartTime: 0,
            abilitiesUsed: [],
            topCombos: [],

            init() {
                this.active = true;
                this.reset();
            },

            registerAbilityUse(abilityId, abilityName) {
                if (!this.active) return;

                // Start combo if first ability
                if (this.currentCombo === 0) {
                    this.comboStartTime = Date.now();
                }

                this.currentCombo++;
                this.comboTimer = this.comboTimeout;
                this.abilitiesUsed.push({
                    id: abilityId,
                    name: abilityName,
                    timestamp: Date.now()
                });

                console.log(`?? Combo: ${this.currentCombo} | ${abilityName}`);
            },

            registerDamage(damage) {
                if (!this.active || this.currentCombo === 0) return;
                this.totalDamage += damage;
            },

            getDPS() {
                if (this.currentCombo === 0) return 0;
                const duration = (Date.now() - this.comboStartTime) / 1000;
                return duration > 0 ? Math.round(this.totalDamage / duration) : 0;
            },

            endCombo() {
                if (this.currentCombo === 0) return;

                const comboData = {
                    comboCount: this.currentCombo,
                    totalDamage: this.totalDamage,
                    dps: this.getDPS(),
                    duration: (Date.now() - this.comboStartTime) / 1000,
                    abilitiesUsed: [...this.abilitiesUsed]
                };

                // Add to top combos if it qualifies
                this.topCombos.push(comboData);
                this.topCombos.sort((a, b) => b.comboCount - a.comboCount);
                if (this.topCombos.length > 5) {
                    this.topCombos = this.topCombos.slice(0, 5);
                }

                // Show summary
                this.showComboSummary(comboData);

                // Reset for next combo
                this.currentCombo = 0;
                this.totalDamage = 0;
                this.abilitiesUsed = [];
                this.comboTimer = 0;

                console.log(`? Combo ended: ${comboData.comboCount} hits, ${comboData.totalDamage} damage, ${comboData.dps} DPS`);
            },

            showComboSummary(comboData) {
                const summary = document.createElement('div');
                summary.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, rgba(0, 217, 255, 0.95), rgba(255, 0, 110, 0.95));
                    border: 3px solid #00d9ff;
                    border-radius: 15px;
                    padding: 30px;
                    z-index: 9999;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
                    min-width: 400px;
                    animation: scaleIn 0.3s ease-out;
                `;

                const abilityCount = {};
                comboData.abilitiesUsed.forEach(a => {
                    abilityCount[a.name] = (abilityCount[a.name] || 0) + 1;
                });

                const abilityList = Object.entries(abilityCount)
                    .map(([name, count]) => `<div style="color: rgba(255, 255, 255, 0.9); font-size: 13px;">í ${name} (x${count})</div>`)
                    .join('');

                summary.innerHTML = `
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h2 style="color: #fff; font-size: 28px; font-weight: 900; margin-bottom: 5px; font-family: 'Orbitron', sans-serif;">?? COMBO FINALIZADO</h2>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 20px; margin-bottom: 15px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                            <div style="text-align: center;">
                                <div style="color: #ffbe0b; font-size: 36px; font-weight: 900; font-family: 'Orbitron', sans-serif;">${comboData.comboCount}</div>
                                <div style="color: rgba(255, 255, 255, 0.8); font-size: 12px;">COMBO</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="color: #ff006e; font-size: 36px; font-weight: 900; font-family: 'Orbitron', sans-serif;">${comboData.totalDamage}</div>
                                <div style="color: rgba(255, 255, 255, 0.8); font-size: 12px;">DAÑO TOTAL</div>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div style="text-align: center;">
                                <div style="color: #00d9ff; font-size: 28px; font-weight: 900; font-family: 'Orbitron', sans-serif;">${comboData.dps}</div>
                                <div style="color: rgba(255, 255, 255, 0.8); font-size: 12px;">DPS</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="color: #00ff88; font-size: 28px; font-weight: 900; font-family: 'Orbitron', sans-serif;">${comboData.duration.toFixed(1)}s</div>
                                <div style="color: rgba(255, 255, 255, 0.8); font-size: 12px;">DURACIÓN</div>
                            </div>
                        </div>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px; margin-bottom: 15px; max-height: 150px; overflow-y: auto;">
                        <div style="color: #00d9ff; font-size: 12px; font-weight: 700; margin-bottom: 10px;">HABILIDADES USADAS:</div>
                        ${abilityList}
                    </div>
                    <button onclick="this.parentElement.remove()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #00d9ff, #0099cc); border: none; border-radius: 8px; color: #fff; font-weight: 700; cursor: pointer; font-size: 14px;">
                        Continuar
                    </button>
                `;

                document.body.appendChild(summary);

                // Auto-remove after 10 seconds
                setTimeout(() => {
                    if (summary.parentElement) summary.remove();
                }, 10000);
            },

            reset() {
                this.currentCombo = 0;
                this.comboTimer = 0;
                this.totalDamage = 0;
                this.abilitiesUsed = [];
                this.comboStartTime = 0;
            },

            update(deltaTime) {
                if (!this.active) return;

                if (this.currentCombo > 0) {
                    this.comboTimer -= deltaTime;
                    if (this.comboTimer <= 0) {
                        this.endCombo();
                    }
                }
            },

            render(ctx) {
                if (!this.active || this.currentCombo === 0) return;

                const canvas = ctx.canvas;
                ctx.save();

                // Combo display (top-right corner)
                const x = canvas.width - 200;
                const y = 100;

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.strokeStyle = '#00d9ff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.roundRect(x, y, 180, 120, 10);
                ctx.fill();
                ctx.stroke();

                // Combo count
                ctx.fillStyle = '#ffbe0b';
                ctx.font = 'bold 48px Orbitron';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffbe0b';
                ctx.fillText(this.currentCombo, x + 90, y + 50);

                ctx.font = 'bold 14px Arial';
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 5;
                ctx.fillText('COMBO', x + 90, y + 70);

                // Damage
                ctx.font = 'bold 16px Arial';
                ctx.fillStyle = '#ff006e';
                ctx.shadowColor = '#ff006e';
                ctx.fillText(`?? ${this.totalDamage}`, x + 90, y + 90);

                // DPS
                ctx.font = 'bold 14px Arial';
                ctx.fillStyle = '#00d9ff';
                ctx.shadowColor = '#00d9ff';
                ctx.fillText(`? ${this.getDPS()} DPS`, x + 90, y + 110);

                ctx.restore();
            }
        };

        // ===== MOBILE CONTROLS SYSTEM =====
        const MobileControlsSystem = {
            enabled: false,
            joystick: {
                active: false,
                baseX: 0,
                baseY: 0,
                stickX: 0,
                stickY: 0,
                radius: 60,
                stickRadius: 25,
                touchId: null,
                maxDistance: 50
            },
            abilityButtons: [],
            touchStartX: 0,
            touchStartY: 0,

            init() {
                // Detectar si es dispositivo móvil
                this.enabled = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                if (!this.enabled) return;

                console.log('📱 Mobile Controls initialized');

                // Configurar orientación horizontal
                this.setupOrientation();

                // Configurar eventos táctiles
                this.setupTouchEvents();

                // Crear botones de habilidades para móvil
                this.createAbilityButtons();
            },

            setupOrientation() {
                // Diseño móvil completo y optimizado
                const style = document.createElement('style');
                style.textContent = `
                    /* ===== DISEÑO MÓVIL COMPLETO ===== */
                    @media screen and (max-width: 768px) {
                        
                        /* Prevenir scroll horizontal */
                        body {
                            overflow-x: hidden !important;
                            max-width: 100vw !important;
                        }
                        
                        * {
                            max-width: 100vw !important;
                        }
                        
                        /* Layout móvil - Mostrar todo de forma accesible */
                        .game-layout {
                            grid-template-areas:
                                "header"
                                "main"
                                "abilities";
                            grid-template-columns: 1fr;
                            grid-template-rows: 60px 1fr 90px;
                            gap: 0;
                            overflow-x: hidden !important;
                        }
                        
                        /* Header móvil - Compacto pero visible */
                        .game-header {
                            padding: 0 15px !important;
                            height: 60px !important;
                            border-bottom: 2px solid rgba(0, 217, 255, 0.3) !important;
                        }
                        
                        .logo {
                            gap: 10px !important;
                        }
                        
                        .logo-icon {
                            width: 40px !important;
                            height: 40px !important;
                            font-size: 24px !important;
                        }
                        
                        .logo-text h1 {
                            font-size: 16px !important;
                            letter-spacing: 1px !important;
                        }
                        
                        .logo-text p {
                            font-size: 8px !important;
                            letter-spacing: 2px !important;
                        }
                        
                        .header-actions {
                            gap: 8px !important;
                        }
                        
                        .header-btn {
                            padding: 6px 12px !important;
                            font-size: 10px !important;
                            display: none; /* Ocultar botones, usar menú hamburguesa */
                        }
                        
                        .menu-toggle {
                            width: 40px !important;
                            height: 40px !important;
                            display: flex !important;
                        }
                        
                        /* Sidebar y Stats Panel - Ocultos en móvil, accesibles por menú */
                        .sidebar, .stats-panel {
                            display: none !important;
                        }
                        
                        /* Menú lateral móvil - Más ancho y accesible */
                        .side-menu {
                            width: 85vw !important;
                            max-width: 350px !important;
                            right: -85vw !important;
                        }
                        
                        .side-menu.open {
                            right: 0 !important;
                        }
                        
                        .side-menu-header {
                            padding: 20px 15px !important;
                        }
                        
                        .side-menu-header h2 {
                            font-size: 20px !important;
                        }
                        
                        .menu-item {
                            padding: 12px 15px !important;
                        }
                        
                        .menu-item:hover {
                            padding-left: 20px !important;
                        }
                        
                        .menu-item-icon {
                            width: 35px !important;
                            height: 35px !important;
                            font-size: 20px !important;
                        }
                        
                        .menu-item-title {
                            font-size: 14px !important;
                        }
                        
                        .menu-item-desc {
                            font-size: 10px !important;
                        }
                        
                        /* Canvas principal - Optimizado para móvil */
                        .main-canvas {
                            padding: 10px !important;
                        }
                        
                        #game-canvas {
                            border-width: 2px !important;
                            border-radius: 10px !important;
                        }
                        
                        .canvas-overlay {
                            top: 10px !important;
                            right: 10px !important;
                            left: 10px !important;
                            padding: 12px 15px !important;
                            gap: 15px !important;
                            flex-direction: row !important;
                            justify-content: space-around !important;
                            border-width: 2px !important;
                            border-radius: 12px !important;
                            backdrop-filter: blur(10px) !important;
                            background: linear-gradient(135deg, rgba(10, 14, 39, 0.98), rgba(5, 8, 20, 0.98)) !important;
                        }
                        
                        .overlay-item {
                            flex-direction: column !important;
                            gap: 4px !important;
                            text-align: center !important;
                            flex: 1 !important;
                        }
                        
                        .overlay-item::after {
                            display: none !important;
                        }
                        
                        .overlay-label {
                            font-size: 28px !important;
                            margin-bottom: 2px !important;
                        }
                        
                        .overlay-value {
                            font-size: 16px !important;
                            font-weight: 900 !important;
                            letter-spacing: 0.5px !important;
                        }
                        
                        /* Barra de habilidades móvil - Rediseñada */
                        .ability-bar {
                            padding: 6px 3px !important;
                            min-height: 80px !important;
                            max-height: 80px !important;
                            gap: 3px !important;
                            overflow-x: auto !important;
                            overflow-y: hidden !important;
                            background: linear-gradient(0deg, rgba(10, 14, 39, 0.98), rgba(5, 8, 20, 0.95)) !important;
                            -webkit-overflow-scrolling: touch !important;
                            scrollbar-width: thin !important;
                        }
                        
                        .ability-bar::-webkit-scrollbar {
                            height: 4px !important;
                        }
                        
                        .ability-bar::-webkit-scrollbar-track {
                            background: rgba(0, 0, 0, 0.3) !important;
                        }
                        
                        .ability-bar::-webkit-scrollbar-thumb {
                            background: linear-gradient(90deg, var(--primary), var(--secondary)) !important;
                            border-radius: 2px !important;
                        }
                        
                        .ability-slot {
                            width: 60px !important;
                            min-width: 60px !important;
                            max-width: 60px !important;
                            height: 70px !important;
                            padding: 3px !important;
                            border-width: 2px !important;
                            flex-shrink: 0 !important;
                        }
                        
                        .ability-slot:active {
                            transform: scale(0.95) !important;
                            transition: transform 0.1s !important;
                        }
                        
                        .ability-icon {
                            width: 50px !important;
                            height: 38px !important;
                            font-size: 22px !important;
                            margin-bottom: 2px !important;
                        }
                        
                        .ability-name {
                            font-size: 7px !important;
                            line-height: 1 !important;
                            margin-bottom: 2px !important;
                            max-width: 54px !important;
                        }
                        
                        .ability-key {
                            font-size: 10px !important;
                            padding: 2px 6px !important;
                            font-weight: 800 !important;
                        }
                        
                        .ability-cooldown {
                            font-size: 18px !important;
                        }
                        
                        /* Modales móviles - Pantalla completa */
                        .modal-content {
                            width: 95vw !important;
                            max-width: 95vw !important;
                            max-height: 90vh !important;
                            overflow-y: auto !important;
                        }
                        
                        .modal-header h2 {
                            font-size: 20px !important;
                        }
                        
                        .close-button {
                            width: 35px !important;
                            height: 35px !important;
                            font-size: 20px !important;
                        }
                        
                        /* ===== LOADOUT Y MAESTRÍAS MÓVIL - REDISEÑO COMPLETO GIGANTE ===== */
                        
                        /* Modal principal - Pantalla completa */
                        #loadout-modal .modal-content,
                        #masteries-modal .modal-content {
                            flex-direction: column !important;
                            padding: 0 !important;
                            max-height: 100vh !important;
                            height: 100vh !important;
                            width: 100vw !important;
                            max-width: 100vw !important;
                            border-radius: 0 !important;
                        }
                        
                        /* Sidebar convertida en header horizontal - GIGANTE */
                        #loadout-modal .modal-content > div:first-child,
                        #masteries-modal .modal-content > div:first-child {
                            width: 100% !important;
                            height: auto !important;
                            min-height: 140px !important;
                            max-height: 140px !important;
                            border-right: none !important;
                            border-bottom: 4px solid rgba(0, 217, 255, 0.5) !important;
                            flex-direction: row !important;
                            overflow-x: auto !important;
                            overflow-y: hidden !important;
                            -webkit-overflow-scrolling: touch !important;
                            background: linear-gradient(180deg, rgba(10, 14, 39, 0.98), rgba(5, 8, 20, 0.95)) !important;
                            display: flex !important;
                            align-items: stretch !important;
                        }
                        
                        /* Logo/Header del loadout - OCULTO EN MÓVIL */
                        #loadout-modal .modal-content > div:first-child > div:first-child,
                        #masteries-modal .modal-content > div:first-child > div:first-child {
                            display: none !important;
                        }
                        
                        /* Container de tabs - Horizontal COMPLETO */
                        #loadout-modal .modal-content > div:first-child > div:nth-child(2),
                        #masteries-modal .modal-content > div:first-child > div:nth-child(2) {
                            flex-direction: row !important;
                            padding: 20px 15px !important;
                            overflow-x: auto !important;
                            overflow-y: hidden !important;
                            flex: 1 !important;
                            display: flex !important;
                            gap: 15px !important;
                            align-items: center !important;
                            width: 100% !important;
                            height: 100% !important;
                        }
                        
                        /* Scrollbar horizontal de tabs */
                        #loadout-modal .modal-content > div:first-child > div:nth-child(2)::-webkit-scrollbar,
                        #masteries-modal .modal-content > div:first-child > div:nth-child(2)::-webkit-scrollbar {
                            height: 8px !important;
                        }
                        
                        #loadout-modal .modal-content > div:first-child > div:nth-child(2)::-webkit-scrollbar-track,
                        #masteries-modal .modal-content > div:first-child > div:nth-child(2)::-webkit-scrollbar-track {
                            background: rgba(0, 0, 0, 0.3) !important;
                            border-radius: 4px !important;
                        }
                        
                        #loadout-modal .modal-content > div:first-child > div:nth-child(2)::-webkit-scrollbar-thumb,
                        #masteries-modal .modal-content > div:first-child > div:nth-child(2)::-webkit-scrollbar-thumb {
                            background: linear-gradient(90deg, var(--primary), var(--secondary)) !important;
                            border-radius: 4px !important;
                        }
                        
                        /* TABS - GIGANTES Y ESPACIOSOS */
                        #loadout-modal .loadout-nav-item,
                        #loadout-modal .modal-content > div:first-child > div:nth-child(2) > div,
                        #masteries-modal .loadout-nav-item,
                        #masteries-modal .modal-content > div:first-child > div:nth-child(2) > div {
                            padding: 15px 25px !important;
                            min-width: 180px !important;
                            max-width: 180px !important;
                            height: 100px !important;
                            min-height: 100px !important;
                            max-height: 100px !important;
                            border-left: none !important;
                            border-bottom: 6px solid transparent !important;
                            border-radius: 15px !important;
                            flex-shrink: 0 !important;
                            display: flex !important;
                            flex-direction: row !important;
                            align-items: center !important;
                            justify-content: flex-start !important;
                            gap: 15px !important;
                            background: rgba(0, 217, 255, 0.08) !important;
                            transition: all 0.3s !important;
                            border: 3px solid rgba(0, 217, 255, 0.2) !important;
                        }
                        
                        #loadout-modal .loadout-nav-item.active,
                        #loadout-modal .modal-content > div:first-child > div:nth-child(2) > div.active,
                        #masteries-modal .loadout-nav-item.active,
                        #masteries-modal .modal-content > div:first-child > div:nth-child(2) > div.active {
                            border-bottom-color: var(--primary) !important;
                            background: rgba(0, 217, 255, 0.25) !important;
                            transform: scale(1.05) !important;
                            border-color: var(--primary) !important;
                            box-shadow: 0 0 30px rgba(0, 217, 255, 0.5) !important;
                        }
                        
                        /* Icono del tab - GRANDE */
                        #loadout-modal .loadout-nav-item > div:first-child,
                        #loadout-modal .modal-content > div:first-child > div:nth-child(2) > div > div:first-child,
                        #masteries-modal .loadout-nav-item > div:first-child,
                        #masteries-modal .modal-content > div:first-child > div:nth-child(2) > div > div:first-child {
                            width: 55px !important;
                            height: 55px !important;
                            min-width: 55px !important;
                            min-height: 55px !important;
                            font-size: 36px !important;
                            margin-bottom: 0 !important;
                            display: flex !important;
                            align-items: center !important;
                            justify-content: center !important;
                            flex-shrink: 0 !important;
                        }
                        
                        /* Texto del tab */
                        #loadout-modal .loadout-nav-item > div:last-child,
                        #loadout-modal .modal-content > div:first-child > div:nth-child(2) > div > div:last-child,
                        #masteries-modal .loadout-nav-item > div:last-child,
                        #masteries-modal .modal-content > div:first-child > div:nth-child(2) > div > div:last-child {
                            display: flex !important;
                            flex-direction: column !important;
                            align-items: flex-start !important;
                            justify-content: center !important;
                            gap: 4px !important;
                            flex: 1 !important;
                        }
                        
                        /* Título del tab - GRANDE */
                        #loadout-modal .loadout-nav-item > div:last-child > div:first-child,
                        #loadout-modal .modal-content > div:first-child > div:nth-child(2) > div > div:last-child > div:first-child,
                        #masteries-modal .loadout-nav-item > div:last-child > div:first-child,
                        #masteries-modal .modal-content > div:first-child > div:nth-child(2) > div > div:last-child > div:first-child {
                            font-size: 17px !important;
                            font-weight: 900 !important;
                            margin-bottom: 0 !important;
                            text-align: left !important;
                            line-height: 1.2 !important;
                        }
                        
                        /* Subtítulo del tab */
                        #loadout-modal .loadout-nav-item > div:last-child > div:last-child,
                        #loadout-modal .modal-content > div:first-child > div:nth-child(2) > div > div:last-child > div:last-child,
                        #masteries-modal .loadout-nav-item > div:last-child > div:last-child,
                        #masteries-modal .modal-content > div:first-child > div:nth-child(2) > div > div:last-child > div:last-child {
                            font-size: 12px !important;
                            text-align: left !important;
                            line-height: 1.2 !important;
                            opacity: 0.8 !important;
                        }
                        
                        /* Close button container - Posición absoluta fuera del flujo */
                        #loadout-modal .modal-content > div:first-child > div:last-child,
                        #masteries-modal .modal-content > div:first-child > div:last-child {
                            position: fixed !important;
                            top: 20px !important;
                            right: 20px !important;
                            width: auto !important;
                            height: auto !important;
                            padding: 0 !important;
                            border: none !important;
                            background: transparent !important;
                            z-index: 10000 !important;
                            display: block !important;
                        }
                        
                        /* Botón cerrar - GIGANTE Y FLOTANTE */
                        #loadout-modal #close-loadout,
                        #loadout-modal button[id*="close"],
                        #masteries-modal #close-loadout,
                        #masteries-modal button[id*="close"] {
                            position: relative !important;
                            width: 60px !important;
                            height: 60px !important;
                            min-height: 60px !important;
                            font-size: 32px !important;
                            background: linear-gradient(135deg, rgba(255, 0, 110, 0.95), rgba(255, 0, 0, 0.95)) !important;
                            border: 4px solid var(--secondary) !important;
                            border-radius: 50% !important;
                            box-shadow: 0 0 35px rgba(255, 0, 110, 0.7), 0 5px 20px rgba(0, 0, 0, 0.6) !important;
                            display: flex !important;
                            align-items: center !important;
                            justify-content: center !important;
                            cursor: pointer !important;
                            transition: all 0.3s !important;
                            padding: 0 !important;
                            letter-spacing: 0 !important;
                            margin: 0 !important;
                        }
                        
                        #loadout-modal #close-loadout:active,
                        #loadout-modal button[id*="close"]:active,
                        #masteries-modal #close-loadout:active,
                        #masteries-modal button[id*="close"]:active {
                            transform: scale(0.85) !important;
                            box-shadow: 0 0 45px rgba(255, 0, 110, 0.9), 0 2px 12px rgba(0, 0, 0, 0.7) !important;
                        }
                        
                        /* Content area - GIGANTE espacioso */
                        #loadout-modal .modal-content > div:last-child,
                        #masteries-modal .modal-content > div:last-child {
                            flex: 1 !important;
                            overflow-y: auto !important;
                            -webkit-overflow-scrolling: touch !important;
                        }
                        
                        /* Content header - GIGANTE */
                        #loadout-modal .modal-content > div:last-child > div:first-child,
                        #masteries-modal .modal-content > div:last-child > div:first-child {
                            padding: 30px !important;
                            background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(255, 0, 110, 0.1)) !important;
                        }
                        
                        #loadout-modal .modal-content > div:last-child > div:first-child h3,
                        #masteries-modal .modal-content > div:last-child > div:first-child h3 {
                            font-size: 28px !important;
                            margin-bottom: 12px !important;
                            font-weight: 900 !important;
                        }
                        
                        #loadout-modal .modal-content > div:last-child > div:first-child p,
                        #masteries-modal .modal-content > div:last-child > div:first-child p {
                            font-size: 16px !important;
                            line-height: 1.5 !important;
                        }
                        
                        /* Content body - GIGANTE ESPACIOSO */
                        #loadout-modal .modal-body,
                        #loadout-modal #loadout-content,
                        #loadout-modal .modal-content > div:last-child > div:last-child,
                        #masteries-modal .modal-body,
                        #masteries-modal #loadout-content,
                        #masteries-modal .modal-content > div:last-child > div:last-child {
                            padding: 40px 30px !important;
                        }
                        
                        /* Grid - 1 COLUMNA GIGANTE ESPACIOSA */
                        #loadout-modal .role-grid,
                        #loadout-modal #loadout-content .role-grid,
                        #loadout-modal .modal-body .role-grid,
                        #loadout-modal div[id*="loadout"] .role-grid,
                        #masteries-modal .role-grid,
                        #masteries-modal #loadout-content .role-grid,
                        #masteries-modal .modal-body .role-grid,
                        #masteries-modal div[id*="loadout"] .role-grid {
                            display: flex !important;
                            flex-direction: column !important;
                            gap: 40px !important;
                            width: 100% !important;
                            max-width: 100% !important;
                        }
                        
                        /* CARDS - GIGANTES - TODOS LOS SELECTORES POSIBLES */
                        #loadout-modal .role-card,
                        #loadout-modal .equip-card,
                        #loadout-modal #loadout-content .role-card,
                        #loadout-modal .modal-body .role-card,
                        #loadout-modal .role-grid > div,
                        #loadout-modal #loadout-content > div,
                        #loadout-modal [class*="role-card"],
                        #loadout-modal [class*="equip-card"],
                        #masteries-modal .role-card,
                        #masteries-modal .equip-card,
                        #masteries-modal #loadout-content .role-card,
                        #masteries-modal .modal-body .role-card,
                        #masteries-modal .role-grid > div,
                        #masteries-modal #loadout-content > div,
                        #masteries-modal [class*="role-card"],
                        #masteries-modal [class*="equip-card"] {
                            padding: 45px 35px !important;
                            margin: 0 !important;
                            min-height: 220px !important;
                            width: 100% !important;
                            max-width: 100% !important;
                            display: flex !important;
                            flex-direction: column !important;
                            align-items: center !important;
                            justify-content: center !important;
                            text-align: center !important;
                            border-width: 4px !important;
                            border-radius: 20px !important;
                            box-sizing: border-box !important;
                        }
                        
                        /* ICONOS - GIGANTESCOS */
                        #loadout-modal .role-card-icon,
                        #loadout-modal #loadout-content .role-card-icon,
                        #loadout-modal .modal-body .role-card-icon,
                        #loadout-modal .role-card > div:first-child,
                        #loadout-modal [class*="role-card"] > div:first-child,
                        #masteries-modal .role-card-icon,
                        #masteries-modal #loadout-content .role-card-icon,
                        #masteries-modal .modal-body .role-card-icon,
                        #masteries-modal .role-card > div:first-child,
                        #masteries-modal [class*="role-card"] > div:first-child {
                            font-size: 110px !important;
                            margin-bottom: 25px !important;
                            line-height: 1 !important;
                            width: auto !important;
                            height: auto !important;
                        }
                        
                        /* NOMBRES - GIGANTES */
                        #loadout-modal .role-card-name,
                        #loadout-modal #loadout-content .role-card-name,
                        #loadout-modal .modal-body .role-card-name,
                        #loadout-modal [class*="role-card-name"],
                        #masteries-modal .role-card-name,
                        #masteries-modal #loadout-content .role-card-name,
                        #masteries-modal .modal-body .role-card-name,
                        #masteries-modal [class*="role-card-name"] {
                            font-size: 26px !important;
                            margin-bottom: 15px !important;
                            font-weight: 900 !important;
                            line-height: 1.3 !important;
                            letter-spacing: 0.5px !important;
                        }
                        
                        /* TIPOS - GIGANTES */
                        #loadout-modal .role-card-type,
                        #loadout-modal #loadout-content .role-card-type,
                        #loadout-modal .modal-body .role-card-type,
                        #loadout-modal [class*="role-card-type"],
                        #masteries-modal .role-card-type,
                        #masteries-modal #loadout-content .role-card-type,
                        #masteries-modal .modal-body .role-card-type,
                        #masteries-modal [class*="role-card-type"] {
                            font-size: 18px !important;
                            margin-top: 10px !important;
                            font-weight: 700 !important;
                            text-transform: uppercase !important;
                            letter-spacing: 1.5px !important;
                        }
                        
                        /* Tier badges - GIGANTES */
                        #loadout-modal .role-card > div[style*="Tier"],
                        #loadout-modal .role-card > div[style*="tier"],
                        #loadout-modal .role-card > div[style*="TIER"],
                        #loadout-modal .role-card div[style*="Tier"],
                        #loadout-modal [class*="role-card"] div[style*="Tier"],
                        #masteries-modal .role-card > div[style*="Tier"],
                        #masteries-modal .role-card > div[style*="tier"],
                        #masteries-modal .role-card > div[style*="TIER"],
                        #masteries-modal .role-card div[style*="Tier"],
                        #masteries-modal [class*="role-card"] div[style*="Tier"] {
                            font-size: 24px !important;
                            padding: 15px 30px !important;
                            margin-top: 18px !important;
                            font-weight: 900 !important;
                            border-radius: 30px !important;
                        }
                        
                        /* Tickets - GIGANTES */
                        #loadout-modal .role-card > div[style*="Tickets"],
                        #loadout-modal .role-card > div[style*="tickets"],
                        #loadout-modal .role-card > div[style*="Ticket"],
                        #loadout-modal .role-card div[style*="Ticket"],
                        #loadout-modal [class*="role-card"] div[style*="Ticket"],
                        #masteries-modal .role-card > div[style*="Tickets"],
                        #masteries-modal .role-card > div[style*="tickets"],
                        #masteries-modal .role-card > div[style*="Ticket"],
                        #masteries-modal .role-card div[style*="Ticket"],
                        #masteries-modal [class*="role-card"] div[style*="Ticket"] {
                            font-size: 22px !important;
                            margin-top: 15px !important;
                            padding: 12px 20px !important;
                            font-weight: 800 !important;
                            border-radius: 12px !important;
                        }
                        
                        /* Botones - GIGANTES */
                        #loadout-modal button,
                        #loadout-modal #loadout-content button,
                        #loadout-modal .modal-body button,
                        #masteries-modal button,
                        #masteries-modal #loadout-content button,
                        #masteries-modal .modal-body button {
                            padding: 22px 35px !important;
                            font-size: 18px !important;
                            min-height: 65px !important;
                            font-weight: 900 !important;
                            border-radius: 15px !important;
                            letter-spacing: 1.5px !important;
                        }
                        
                        /* Equipamiento actual - GIGANTE espacioso */
                        #loadout-modal .equip-card-content,
                        #masteries-modal .equip-card-content {
                            padding: 30px !important;
                        }
                        
                        #loadout-modal .equip-info h3,
                        #masteries-modal .equip-info h3 {
                            font-size: 24px !important;
                            margin-bottom: 12px !important;
                            font-weight: 900 !important;
                        }
                        
                        #loadout-modal .equip-type,
                        #masteries-modal .equip-type {
                            font-size: 16px !important;
                            font-weight: 700 !important;
                        }
                        
                        #loadout-modal .equip-status,
                        #masteries-modal .equip-status {
                            font-size: 15px !important;
                            padding: 10px 20px !important;
                            font-weight: 800 !important;
                        }
                        
                        /* Imágenes de cards - GIGANTES */
                        #loadout-modal .equip-card-image,
                        #loadout-modal .role-card-image,
                        #masteries-modal .equip-card-image,
                        #masteries-modal .role-card-image {
                            height: 220px !important;
                        }
                        
                        /* ===== ESPACIADO Y SEPARACIÓN DE ELEMENTOS EN CARDS ===== */
                        
                        /* Todos los divs dentro de cards - Espaciado vertical */
                        #loadout-modal .role-card > div,
                        #loadout-modal .equip-card > div,
                        #masteries-modal .role-card > div,
                        #masteries-modal .equip-card > div {
                            margin-bottom: 12px !important;
                        }
                        
                        /* Último elemento sin margen inferior */
                        #loadout-modal .role-card > div:last-child,
                        #loadout-modal .equip-card > div:last-child,
                        #masteries-modal .role-card > div:last-child,
                        #masteries-modal .equip-card > div:last-child {
                            margin-bottom: 0 !important;
                        }
                        
                        /* Divs con posición absoluta (badges) - Espaciado mejorado */
                        #loadout-modal .role-card > div[style*="position: absolute"],
                        #loadout-modal .equip-card > div[style*="position: absolute"],
                        #masteries-modal .role-card > div[style*="position: absolute"],
                        #masteries-modal .equip-card > div[style*="position: absolute"] {
                            margin: 0 !important;
                            padding: 12px 20px !important;
                            font-size: 16px !important;
                            font-weight: 900 !important;
                            border-radius: 12px !important;
                            white-space: nowrap !important;
                        }
                        
                        /* Badge "EQUIPADO" - Más grande y visible */
                        #loadout-modal .role-card > div[style*="EQUIPADO"],
                        #loadout-modal .equip-card > div[style*="EQUIPADO"],
                        #masteries-modal .role-card > div[style*="EQUIPADO"],
                        #masteries-modal .equip-card > div[style*="EQUIPADO"] {
                            font-size: 18px !important;
                            padding: 14px 24px !important;
                        }
                        
                        /* Contenedor de información de equipamiento */
                        #loadout-modal .equip-card-header,
                        #masteries-modal .equip-card-header {
                            margin-bottom: 15px !important;
                        }
                        
                        /* Separación entre elementos de texto */
                        #loadout-modal .role-card h3,
                        #loadout-modal .role-card h4,
                        #loadout-modal .role-card p,
                        #loadout-modal .equip-card h3,
                        #loadout-modal .equip-card h4,
                        #loadout-modal .equip-card p,
                        #masteries-modal .role-card h3,
                        #masteries-modal .role-card h4,
                        #masteries-modal .role-card p,
                        #masteries-modal .equip-card h3,
                        #masteries-modal .equip-card h4,
                        #masteries-modal .equip-card p {
                            display: block !important;
                            margin: 10px 0 !important;
                            line-height: 1.4 !important;
                        }
                        
                        /* Forzar saltos de línea en elementos específicos */
                        #loadout-modal .role-card > *,
                        #loadout-modal .equip-card > *,
                        #masteries-modal .role-card > *,
                        #masteries-modal .equip-card > * {
                            display: block !important;
                            width: 100% !important;
                        }
                        
                        /* Excepciones para elementos que deben ser inline */
                        #loadout-modal .role-card > div[style*="position: absolute"],
                        #loadout-modal .equip-card > div[style*="position: absolute"],
                        #masteries-modal .role-card > div[style*="position: absolute"],
                        #masteries-modal .equip-card > div[style*="position: absolute"] {
                            display: block !important;
                            width: auto !important;
                        }
                        
                        /* Scrollbar del header - Más visible */
                        #loadout-modal .modal-content > div:first-child::-webkit-scrollbar,
                        #masteries-modal .modal-content > div:first-child::-webkit-scrollbar {
                            height: 8px !important;
                        }
                        
                        #loadout-modal .modal-content > div:first-child::-webkit-scrollbar-thumb,
                        #masteries-modal .modal-content > div:first-child::-webkit-scrollbar-thumb {
                            background: linear-gradient(90deg, var(--primary), var(--secondary)) !important;
                            border-radius: 4px !important;
                        }
                        
                        /* ===== MAESTRÍAS - ESTILOS ESPECÍFICOS GIGANTES ===== */
                        
                        /* Progreso de misiones - GIGANTE */
                        #masteries-modal .mission-progress,
                        #masteries-modal [class*="mission"],
                        #masteries-modal [class*="progress"] {
                            font-size: 18px !important;
                            padding: 20px !important;
                            margin: 15px 0 !important;
                        }
                        
                        /* Requisitos de maestría - GIGANTES */
                        #masteries-modal .requirement,
                        #masteries-modal [class*="requirement"] {
                            font-size: 16px !important;
                            padding: 15px 20px !important;
                            margin: 10px 0 !important;
                            border-width: 3px !important;
                            border-radius: 12px !important;
                        }
                        
                        /* Barras de progreso - GIGANTES */
                        #masteries-modal .progress-bar,
                        #masteries-modal [class*="progress-bar"] {
                            height: 20px !important;
                            border-radius: 10px !important;
                            margin: 12px 0 !important;
                        }
                        
                        /* Texto de progreso - GIGANTE */
                        #masteries-modal .progress-text,
                        #masteries-modal [class*="progress-text"] {
                            font-size: 16px !important;
                            font-weight: 700 !important;
                            margin: 8px 0 !important;
                        }
                        
                        /* Descripción de maestría - GIGANTE */
                        #masteries-modal .mastery-description,
                        #masteries-modal [class*="description"] {
                            font-size: 16px !important;
                            line-height: 1.6 !important;
                            padding: 20px !important;
                            margin: 15px 0 !important;
                        }
                        
                        /* Recompensas - GIGANTES */
                        #masteries-modal .reward,
                        #masteries-modal [class*="reward"] {
                            font-size: 18px !important;
                            padding: 18px 25px !important;
                            margin: 12px 0 !important;
                            border-width: 3px !important;
                            border-radius: 15px !important;
                        }
                        
                        /* Tabs móviles */
                        .tabs {
                            gap: 8px !important;
                            flex-wrap: wrap !important;
                            padding: 10px !important;
                        }
                        
                        .tab-button {
                            padding: 10px 16px !important;
                            font-size: 13px !important;
                            min-height: 44px !important;
                        }
                        
                        /* Grid de roles móvil GENERAL (fuera de loadout) */
                        .modal:not(#loadout-modal) .role-grid {
                            grid-template-columns: repeat(2, 1fr) !important;
                            gap: 15px !important;
                        }
                        
                        .modal:not(#loadout-modal) .role-card {
                            padding: 18px !important;
                            min-height: 160px !important;
                        }
                        
                        .modal:not(#loadout-modal) .role-card-icon {
                            font-size: 55px !important;
                            margin-bottom: 12px !important;
                        }
                        
                        .modal:not(#loadout-modal) .role-card-name {
                            font-size: 16px !important;
                            margin-bottom: 6px !important;
                        }
                        
                        .modal:not(#loadout-modal) .role-card-type {
                            font-size: 12px !important;
                        }
                        
                        .role-card-name {
                            font-size: 13px !important;
                        }
                        
                        .role-card-type {
                            font-size: 9px !important;
                        }
                        
                        /* Panel de información móvil */
                        #role-info-panel {
                            width: 100vw !important;
                            right: -100vw !important;
                            padding: 20px 15px !important;
                        }
                        
                        #role-info-panel.open {
                            right: 0 !important;
                        }
                        
                        /* ===== BARRA DE ESTADÍSTICAS INFERIOR - MÓVIL ===== */
                        
                        /* Contenedor principal de stats */
                        .ability-bar[style*="justify-content"] {
                            flex-direction: column !important;
                            padding: 15px 10px !important;
                            gap: 15px !important;
                            min-height: auto !important;
                            max-height: none !important;
                        }
                        
                        /* Contenedor de estadísticas */
                        .ability-bar > div:first-child {
                            width: 100% !important;
                            flex-direction: row !important;
                            justify-content: space-around !important;
                            gap: 8px !important;
                            flex-wrap: wrap !important;
                        }
                        
                        /* Cada stat individual */
                        .ability-bar > div:first-child > div[style*="text-align"] {
                            flex: 1 !important;
                            min-width: 90px !important;
                            padding: 10px 5px !important;
                            background: rgba(0, 217, 255, 0.05) !important;
                            border-radius: 10px !important;
                            border: 2px solid rgba(0, 217, 255, 0.2) !important;
                        }
                        
                        /* Labels de stats */
                        .ability-bar > div:first-child > div[style*="text-align"] > div:first-child {
                            font-size: 9px !important;
                            margin-bottom: 4px !important;
                            letter-spacing: 0.5px !important;
                        }
                        
                        /* Valores de stats */
                        .ability-bar > div:first-child > div[style*="text-align"] > div:last-child {
                            font-size: 20px !important;
                            font-weight: 900 !important;
                        }
                        
                        /* Separadores verticales - Ocultar */
                        .ability-bar > div:first-child > div[style*="width: 2px"] {
                            display: none !important;
                        }
                        
                        /* Quick Info - Ocultar en móvil */
                        .ability-bar > div:last-child {
                            display: none !important;
                        }
                    }
                    
                    /* ===== MODO JUEGO EN MÓVIL (Raids/Práctica) ===== */
                    @media screen and (max-width: 768px) {
                        .mobile-game-mode .game-header {
                            display: none !important;
                        }
                        
                        .mobile-game-mode .game-layout {
                            grid-template-areas: "main";
                            grid-template-columns: 1fr;
                            grid-template-rows: 1fr;
                        }
                        
                        .mobile-game-mode .ability-bar {
                            display: none !important;
                        }
                        
                        .mobile-game-mode .main-canvas {
                            padding: 0 !important;
                        }
                        
                        .mobile-game-mode #game-canvas {
                            border-radius: 0 !important;
                            width: 100vw !important;
                            height: 100vh !important;
                        }
                    }
                    
                    /* ===== ROTACIÓN EN PORTRAIT ===== */
                    @media screen and (max-width: 768px) and (orientation: portrait) {
                        .mobile-game-mode .main-canvas {
                            position: fixed !important;
                            top: 50% !important;
                            left: 50% !important;
                            transform: translate(-50%, -50%) rotate(90deg) !important;
                            width: 100vh !important;
                            height: 100vw !important;
                            z-index: 9999 !important;
                        }
                        
                        .mobile-game-mode #game-canvas {
                            width: 100vh !important;
                            height: 100vw !important;
                        }
                    }
                    
                    /* ===== LANDSCAPE MÓVIL ===== */
                    @media screen and (max-width: 768px) and (orientation: landscape) {
                        .game-header {
                            height: 50px !important;
                        }
                        
                        .logo-icon {
                            width: 35px !important;
                            height: 35px !important;
                        }
                        
                        .logo-text h1 {
                            font-size: 14px !important;
                        }
                        
                        .logo-text p {
                            display: none !important;
                        }
                        
                        .ability-bar {
                            min-height: 70px !important;
                            max-height: 70px !important;
                        }
                        
                        .ability-slot {
                            height: 60px !important;
                        }
                    }
                `;
                document.head.appendChild(style);

                // Agregar clase al body cuando esté en modo juego
                this.addGameModeClass();
            },

            addGameModeClass() {
                // Observar cambios en el estado del juego
                const checkGameMode = () => {
                    const body = document.body;
                    const wasInGameMode = body.classList.contains('mobile-game-mode');
                    const isInGameMode = MobRaidSystem.active || PracticeModeManager.active;

                    if (isInGameMode && !wasInGameMode) {
                        // Entrando al modo juego
                        body.classList.add('mobile-game-mode');
                        this.enterFullscreenMode();
                        this.requestOrientationLock();
                    } else if (!isInGameMode && wasInGameMode) {
                        // Saliendo del modo juego
                        body.classList.remove('mobile-game-mode');
                        this.exitFullscreenMode();
                        this.releaseOrientationLock();
                    }
                };

                // Verificar cada 500ms
                setInterval(checkGameMode, 500);
            },

            enterFullscreenMode() {
                if (!this.enabled) return;

                const canvas = document.getElementById('game-canvas');
                if (!canvas) return;

                // Intentar entrar en pantalla completa
                const requestFullscreen = canvas.requestFullscreen ||
                    canvas.webkitRequestFullscreen ||
                    canvas.mozRequestFullScreen ||
                    canvas.msRequestFullscreen;

                if (requestFullscreen) {
                    requestFullscreen.call(canvas).catch(err => {
                        console.log('No se pudo entrar en pantalla completa:', err);
                    });
                }
            },

            exitFullscreenMode() {
                if (!this.enabled) return;

                // Salir de pantalla completa
                const exitFullscreen = document.exitFullscreen ||
                    document.webkitExitFullscreen ||
                    document.mozCancelFullScreen ||
                    document.msExitFullscreen;

                if (exitFullscreen && (document.fullscreenElement || document.webkitFullscreenElement)) {
                    exitFullscreen.call(document).catch(err => {
                        console.log('No se pudo salir de pantalla completa:', err);
                    });
                }
            },

            requestOrientationLock() {
                if (!this.enabled) return;

                // Intentar bloquear orientación a landscape
                if (screen.orientation && screen.orientation.lock) {
                    screen.orientation.lock('landscape').catch(err => {
                        console.log('No se pudo bloquear la orientación:', err);
                    });
                }
            },

            releaseOrientationLock() {
                if (!this.enabled) return;

                // Liberar bloqueo de orientación
                if (screen.orientation && screen.orientation.unlock) {
                    screen.orientation.unlock();
                }
            },

            setupTouchEvents() {
                const canvas = document.getElementById('game-canvas');

                // Touch start
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();

                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        const rect = canvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;

                        // Convertir coordenadas de canvas a coordenadas del juego
                        const gameX = (x / rect.width) * canvas.width;
                        const gameY = (y / rect.height) * canvas.height;

                        // Si el toque está en la mitad izquierda, activar joystick
                        if (gameX < canvas.width / 2) {
                            this.joystick.active = true;
                            this.joystick.baseX = gameX;
                            this.joystick.baseY = gameY;
                            this.joystick.stickX = gameX;
                            this.joystick.stickY = gameY;
                            this.joystick.touchId = touch.identifier;
                        }
                        // Si está en la mitad derecha, verificar botones de habilidades
                        else {
                            this.checkAbilityButtonTouch(gameX, gameY);

                            // También verificar si está en modo práctica y hacer clic en el panel
                            if (PracticeModeManager.active) {
                                PracticeModeManager.handleCanvasClick(gameX, gameY);
                            }
                        }
                    }
                }, { passive: false });

                // Touch move
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();

                    if (!this.joystick.active) return;

                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];

                        if (touch.identifier === this.joystick.touchId) {
                            const rect = canvas.getBoundingClientRect();
                            const x = touch.clientX - rect.left;
                            const y = touch.clientY - rect.top;

                            const gameX = (x / rect.width) * canvas.width;
                            const gameY = (y / rect.height) * canvas.height;

                            // Calcular distancia desde la base
                            const dx = gameX - this.joystick.baseX;
                            const dy = gameY - this.joystick.baseY;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            // Limitar la distancia máxima
                            if (distance > this.joystick.maxDistance) {
                                const angle = Math.atan2(dy, dx);
                                this.joystick.stickX = this.joystick.baseX + Math.cos(angle) * this.joystick.maxDistance;
                                this.joystick.stickY = this.joystick.baseY + Math.sin(angle) * this.joystick.maxDistance;
                            } else {
                                this.joystick.stickX = gameX;
                                this.joystick.stickY = gameY;
                            }

                            // Actualizar movimiento del jugador
                            this.updatePlayerMovement();
                        }
                    }
                }, { passive: false });

                // Touch end
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();

                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];

                        if (touch.identifier === this.joystick.touchId) {
                            this.joystick.active = false;
                            this.joystick.touchId = null;

                            // Detener movimiento del jugador
                            this.movementDirection = null;
                        }
                    }
                }, { passive: false });

                // Touch cancel
                canvas.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.joystick.active = false;
                    this.joystick.touchId = null;

                    // Detener movimiento del jugador
                    this.movementDirection = null;
                }, { passive: false });
            },

            updatePlayerMovement() {
                if (!this.joystick.active) return;

                // Calcular dirección normalizada
                const dx = this.joystick.stickX - this.joystick.baseX;
                const dy = this.joystick.stickY - this.joystick.baseY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 5) { // Dead zone
                    const normalizedX = dx / this.joystick.maxDistance;
                    const normalizedY = dy / this.joystick.maxDistance;

                    // Guardar dirección para usar en update
                    this.movementDirection = {
                        x: normalizedX,
                        y: normalizedY
                    };
                } else {
                    this.movementDirection = null;
                }
            },

            createAbilityButtons() {
                // Crear botones flotantes en el canvas
                // Se actualizan dinámicamente basados en las habilidades equipadas
                this.updateAbilityButtons();
            },

            updateAbilityButtons() {
                // Actualizar posiciones y estados de los botones de habilidades
                const abilities = EquipmentManager.getAllAbilities();
                this.abilityButtons = [];

                if (!abilities || abilities.length === 0) return;

                const canvas = document.getElementById('game-canvas');
                const buttonSize = 65; // Tamaño optimizado para móvil
                const spacing = 8; // Espacio entre botones
                const marginRight = 15; // Margen desde el borde derecho
                const marginBottom = 20; // Margen desde el borde inferior

                // Posicionar botones en el lado derecho, más abajo para mejor acceso con el pulgar
                const startX = canvas.width - (buttonSize + marginRight);
                const totalHeight = (abilities.length * (buttonSize + spacing)) - spacing;
                const startY = canvas.height - totalHeight - marginBottom;

                abilities.forEach((ability, index) => {
                    this.abilityButtons.push({
                        x: startX,
                        y: startY + (index * (buttonSize + spacing)),
                        width: buttonSize,
                        height: buttonSize,
                        ability: ability,
                        icon: ability.icon || '⚔️',
                        key: ability.keyBinding ? ability.keyBinding.toUpperCase() : (index + 1).toString()
                    });
                });
            },

            checkAbilityButtonTouch(x, y) {
                // Verificar si el toque está sobre algún botón flotante
                for (let i = 0; i < this.abilityButtons.length; i++) {
                    const btn = this.abilityButtons[i];

                    if (x >= btn.x && x <= btn.x + btn.width &&
                        y >= btn.y && y <= btn.y + btn.height) {

                        // Verificar si la habilidad no está en cooldown
                        if (btn.ability.currentCooldown === 0) {
                            AbilityManager.activateAbility(btn.ability.id);

                            // Efecto visual de toque
                            this.showTouchFeedback(btn.x + btn.width / 2, btn.y + btn.height / 2);
                            return true;
                        }
                    }
                }
                return false;
            },

            showTouchFeedback(x, y) {
                // Crear efecto visual temporal de toque
                const feedback = {
                    x: x,
                    y: y,
                    radius: 10,
                    maxRadius: 40,
                    alpha: 1,
                    startTime: Date.now()
                };

                if (!this.touchFeedbacks) this.touchFeedbacks = [];
                this.touchFeedbacks.push(feedback);
            },

            render(ctx) {
                if (!this.enabled) return;

                const inGame = MobRaidSystem.active || PracticeModeManager.active;

                if (inGame) {
                    // Activar clase CSS para rotar canvas en portrait
                    const mainCanvas = document.querySelector('.main-canvas');
                    const gameCanvas = document.getElementById('game-canvas');
                    if (mainCanvas && gameCanvas) {
                        mainCanvas.classList.add('mobile-game-active');
                        gameCanvas.classList.add('mobile-game-active');
                    }

                    // Renderizar joystick si está activo
                    if (this.joystick.active) {
                        this.renderJoystick(ctx);
                    }

                    // Renderizar botones flotantes de habilidades
                    this.renderAbilityButtons(ctx);

                    // Renderizar efectos de toque
                    this.renderTouchFeedbacks(ctx);
                } else {
                    // Desactivar clase CSS cuando no está en juego
                    const mainCanvas = document.querySelector('.main-canvas');
                    const gameCanvas = document.getElementById('game-canvas');
                    if (mainCanvas && gameCanvas) {
                        mainCanvas.classList.remove('mobile-game-active');
                        gameCanvas.classList.remove('mobile-game-active');
                    }

                    // Renderizar indicador de controles móviles
                    this.renderMobileIndicator(ctx);
                }
            },

            renderJoystick(ctx) {
                ctx.save();

                // Base del joystick
                ctx.fillStyle = 'rgba(0, 217, 255, 0.3)';
                ctx.strokeStyle = 'rgba(0, 217, 255, 0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.joystick.baseX, this.joystick.baseY, this.joystick.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Círculo interior de la base
                ctx.strokeStyle = 'rgba(0, 217, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.joystick.baseX, this.joystick.baseY, this.joystick.radius * 0.6, 0, Math.PI * 2);
                ctx.stroke();

                // Stick del joystick
                ctx.fillStyle = 'rgba(0, 217, 255, 0.8)';
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(0, 217, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(this.joystick.stickX, this.joystick.stickY, this.joystick.stickRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Línea de dirección
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.moveTo(this.joystick.baseX, this.joystick.baseY);
                ctx.lineTo(this.joystick.stickX, this.joystick.stickY);
                ctx.stroke();

                ctx.restore();
            },

            renderAbilityButtons(ctx) {
                if (!this.abilityButtons || this.abilityButtons.length === 0) {
                    this.updateAbilityButtons();
                    return;
                }

                ctx.save();

                this.abilityButtons.forEach((btn, index) => {
                    const isOnCooldown = btn.ability.currentCooldown > 0;
                    const isUltimate = btn.ability.id.includes('ultimate');

                    // Fondo del botón con más opacidad para mejor visibilidad
                    ctx.fillStyle = isOnCooldown ? 'rgba(50, 50, 50, 0.85)' :
                        isUltimate ? 'rgba(255, 190, 11, 0.85)' :
                            'rgba(0, 217, 255, 0.85)';
                    ctx.strokeStyle = isOnCooldown ? 'rgba(100, 100, 100, 0.9)' :
                        isUltimate ? 'rgba(255, 190, 11, 1)' :
                            'rgba(0, 217, 255, 1)';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = isOnCooldown ? 0 : 15;
                    ctx.shadowColor = isUltimate ? 'rgba(255, 190, 11, 1)' : 'rgba(0, 217, 255, 1)';

                    // Dibujar botón redondeado
                    ctx.beginPath();
                    ctx.roundRect(btn.x, btn.y, btn.width, btn.height, 12);
                    ctx.fill();
                    ctx.stroke();

                    // Icono de la habilidad - Más grande
                    ctx.shadowBlur = 0;
                    ctx.font = 'bold 34px Arial';
                    ctx.fillStyle = isOnCooldown ? 'rgba(150, 150, 150, 0.8)' : '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(btn.icon, btn.x + btn.width / 2, btn.y + btn.height / 2 - 3);

                    // Tecla de atajo - Más visible
                    ctx.font = 'bold 13px Arial';
                    ctx.fillStyle = isUltimate ? '#ffbe0b' : '#00d9ff';
                    ctx.shadowBlur = 3;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillText(btn.key, btn.x + btn.width / 2, btn.y + btn.height - 10);
                    ctx.shadowBlur = 0;

                    // Cooldown overlay
                    if (isOnCooldown) {
                        const cooldownPercent = btn.ability.currentCooldown / btn.ability.cooldown;
                        const cooldownHeight = btn.height * cooldownPercent;

                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.beginPath();
                        ctx.roundRect(btn.x, btn.y + btn.height - cooldownHeight, btn.width, cooldownHeight, [0, 0, 12, 12]);
                        ctx.fill();

                        // Tiempo restante
                        const secondsLeft = Math.ceil(btn.ability.currentCooldown / 1000);
                        ctx.font = 'bold 20px Arial';
                        ctx.fillStyle = '#ff006e';
                        ctx.fillText(secondsLeft, btn.x + btn.width / 2, btn.y + btn.height / 2);
                    }
                });

                ctx.restore();
            },

            renderTouchFeedbacks(ctx) {
                if (!this.touchFeedbacks || this.touchFeedbacks.length === 0) return;

                ctx.save();

                const now = Date.now();
                this.touchFeedbacks = this.touchFeedbacks.filter(feedback => {
                    const elapsed = now - feedback.startTime;
                    const duration = 300; // ms

                    if (elapsed > duration) return false;

                    const progress = elapsed / duration;
                    feedback.radius = 10 + (feedback.maxRadius - 10) * progress;
                    feedback.alpha = 1 - progress;

                    ctx.strokeStyle = `rgba(0, 217, 255, ${feedback.alpha})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(feedback.x, feedback.y, feedback.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    return true;
                });

                ctx.restore();
            },

            renderMobileIndicator(ctx) {
                if (!MobRaidSystem.active && !PracticeModeManager.active) {
                    // Mostrar indicador de controles móviles en el menú
                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 217, 255, 0.8)';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('📱 Controles Móviles Activos', ctx.canvas.width / 2, 50);
                    ctx.font = '12px Arial';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fillText('Inicia una Raid o Modo Práctica para usar los controles', ctx.canvas.width / 2, 75);
                    ctx.restore();
                }
            },

            update(deltaTime) {
                if (!this.enabled) return;

                // Actualizar movimiento si el joystick está activo
                if (this.joystick.active) {
                    this.updatePlayerMovement();
                }

                // Aplicar movimiento al jugador
                if (this.movementDirection && (MobRaidSystem.active || PracticeModeManager.active)) {
                    // Calcular velocidad basada en el Player.speed
                    const speed = Player.speed || 200; // Velocidad por defecto
                    const moveX = this.movementDirection.x * speed * (deltaTime / 1000);
                    const moveY = this.movementDirection.y * speed * (deltaTime / 1000);

                    // Mover al jugador
                    Player.move(moveX, moveY);
                }

                // Actualizar botones de habilidades si está en juego
                if (MobRaidSystem.active || PracticeModeManager.active) {
                    this.updateAbilityButtons();
                }
            }
        };

        // ===== MOBILE RAID SYSTEM INTEGRATION =====
        // Modificar el sistema de Raids para soportar controles móviles
        const originalRaidRender = MobRaidSystem.render;
        MobRaidSystem.render = function (ctx) {
            originalRaidRender.call(this, ctx);

            // Renderizar controles móviles si están habilitados
            if (MobileControlsSystem.enabled) {
                MobileControlsSystem.render(ctx);
            }
        };

        // ===== MOBILE PRACTICE MODE INTEGRATION =====
        // Modificar el modo práctica para soportar controles móviles
        const originalPracticeRender = PracticeModeManager.render;
        PracticeModeManager.render = function (ctx) {
            originalPracticeRender.call(this, ctx);

            // Renderizar controles móviles si están habilitados
            if (MobileControlsSystem.enabled) {
                MobileControlsSystem.render(ctx);
            }
        };

        // Inicializar controles móviles al cargar el juego
        const originalInitGame = typeof initGame !== 'undefined' ? initGame : function () { };

        function initGameWithMobile() {
            // Inicializar controles móviles primero
            MobileControlsSystem.init();

            // Luego inicializar el juego normal
            if (typeof originalInitGame === 'function') {
                originalInitGame();
            }
        }

        initGameWithMobile();
    </script>
</body>

</html>



